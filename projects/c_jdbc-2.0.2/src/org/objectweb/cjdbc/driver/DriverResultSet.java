/**
 * C-JDBC: Clustered JDBC.
 * Copyright (C) 2002-2005 French National Institute For Research In Computer
 * Science And Control (INRIA).
 * Contact: c-jdbc@objectweb.org
 * 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or any later
 * version.
 * 
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 *
 * Initial developer(s): Mark Matthews. 
 * Contributor(s): Emmanuel Cecchet, Andre Austin, Marc Wick, Jean-Bernard
 * van Zuylen, Marc Herbert.
 */

package org.objectweb.cjdbc.driver;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.NotSerializableException;
import java.io.ObjectInputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;

import org.objectweb.cjdbc.common.exceptions.NotImplementedException;
import org.objectweb.cjdbc.common.exceptions.ProtocolException;
import org.objectweb.cjdbc.common.stream.CJDBCInputStream;
import org.objectweb.cjdbc.common.stream.CJDBCOutputStream;
import org.objectweb.cjdbc.driver.protocol.SQLDataSerialization;
import org.objectweb.cjdbc.driver.protocol.TypeTag;

/**
 * A <code>ResultSet</code> provides access to a table of data generated by
 * executing a Statement. The table rows are retrieved in sequence. Within a row
 * its column values can be accessed in any order.
 * <p>
 * A <code>ResultSet</code> maintains a cursor pointing to its current row of
 * data. Initially the cursor is positioned before the first row. The 'next'
 * method moves the cursor to the next row.
 * <p>
 * The <code>getXXX</code> methods retrieve column values for the current row.
 * You can retrieve values either using the index number of the column, or by
 * using the name of the column. In general using the column index will be more
 * efficient. Columns are numbered from 1.
 * <p>
 * For maximum portability, <code>ResultSet</code> columns within each row
 * should be read in left-to-right order and each column should be read only
 * once.
 * <p>
 * For the <code>getXXX</code> methods, the JDBC driver attempts to convert
 * the underlying data to the specified Java type and returns a suitable Java
 * value. See the JDBC specification for allowable mappings from SQL types to
 * Java types with the <code>ResultSet</code> <code>getXXX</code> methods.
 * <p>
 * Column names used as input to <code>getXXX</code> methods are case
 * insenstive. When performing a <code>getXXX</code> using a column name, if
 * several columns have the same name, then the value of the first matching
 * column will be returned. The column name option is designed to be used when
 * column names are used in the SQL Query. For columns that are NOT explicitly
 * named in the query, it is best to use column numbers. If column names were
 * used there is no way for the programmer to guarentee that they actually refer
 * to the intended columns.
 * <P>
 * A <code>ResultSet</code> is automatically closed by the
 * <code>Statement</code> that generated it when that <code>Statement</code>
 * is closed, re-executed, or is used to retrieve the next result from a
 * sequence of multiple results.
 * <P>
 * The number, types and properties of a ResultSet's columns are provided by the
 * <code>ResultSetMetaData</code> object returned by the
 * <code>getMetaData</code> method.
 * 
 * @see java.sql.ResultSetMetaData
 * @see java.sql.ResultSet
 * @author Mark Matthews <mmatthew@worldserver.com>
 * @author <a href="mailto:Emmanuel.Cecchet@inria.fr">Emmanuel Cecchet </a>
 * @author <a href="mailto:alexander.laamanen@tecnomen.com">Alexander Laamanen
 *         </a>
 * @author <a href="mailto:Nicolas.Modrzyk@inrialpes.fr">Nicolas Modrzyk </a>
 * @author <a href="mailto:jbvanzuylen@transwide.com">Jean-Bernard van Zuylen
 *         </a>
 * @author <a href="mailto:Marc.Herbert@emicnetworks.com">Marc Herbert </a>
 * @version 1.0
 */
public class DriverResultSet
    implements
      java.sql.ResultSet,
      java.io.Serializable,
      java.lang.Cloneable
{
  private static final long                 serialVersionUID      = 7408879935608629886L;

  /** Cursor to current row */
  protected int                             currentRow            = -1;
  /** Number of rows */
  protected int                             nbOfRows              = -1;
  /** Number of columns */
  protected int                             nbOfColumns           = -1;
  /** The results */
  protected ArrayList                       data;
  /** True if there is more data to fetch from the controller */
  private boolean                           hasMoreData;
  /** The fetch direction (not used yet) */
  protected int                             fetchDirection        = FETCH_FORWARD;
  /** The fetch size */
  protected int                             fetchSize             = 0;
  /** ResultSet cursor name */
  private String                            cursorName;

  /** The fields */
  protected Field[]                         fields;

  /** Pointers to column-specific de/serializer */
  private SQLDataSerialization.Serializer[] serializers;

  /** for wasNull() */
  protected boolean                         wasNullFlag           = false;
  /** column name -> index in ResultSet data array */
  protected transient Hashtable             columnNameToIndex     = null;
  /** full column name -> index in ResultSet data array */
  protected transient Hashtable             fullColumnNameToIndex = null;

  /** Type of ResultSet */
  protected int                             resultSetType         = 0;
  /** Concurrency for this ResultSet */
  protected int                             resultSetConcurrency  = 0;
  /** the warning chain */
  protected SQLWarning                      warnings              = null;
  /** Statement corresponding to this ResultSet, if any (not for metadata) */
  protected transient Statement             owningStatement;
  /** The driver connection we were received from (null on the controller side) */
  private final Connection                  connection;

  private boolean                           isClosed              = true;

  /** Statement for deleting rows with Updatable ResultSets * */
  private transient PreparedStatement       deleteStatement       = null;
  /** Statement for inserting rows with Updatable ResultSets * */
  private transient PreparedStatement       insertStatement       = null;
  /** Statement for refreshing rows with Updatable ResultSets * */
  private transient PreparedStatement       refreshStatement      = null;
  /** Statement for updating rows with Updatable ResultSets * */
  private transient PreparedStatement       updateStatement       = null;
  /** Indicates whether cursor is on the insert row * */
  private transient boolean                 inserting             = false;
  /** Indicates if the current row is being updated * */
  private transient boolean                 updating              = false;
  /** Temporary object for not yet comitted ResultSet updates * */
  private transient Object[]                tempRow               = null;
  /** Cache the columns forming the primary key * */
  private transient String[]                primaryKeyColumns     = null;

  private static final String               UPDATEABLE_MESSAGE    = "ResultSet not updateable. The "
                                                                      + "query that generated this result set must select only one table, and must "
                                                                      + "select all primary keys from that table. See the JDBC 2.1 API Specification, "
                                                                      + "section 5.6 for more details.";

  // ---------------------------------------------------------------------
  // Traversal/Positioning
  // ---------------------------------------------------------------------

  /**
   * A ResultSet is initially positioned before its first row, the first call to
   * next makes the first row the current row; the second call makes the second
   * row the current row, etc.
   * <p>
   * If an input stream from the previous row is open, it is implicitly closed.
   * The ResultSet's warning chain is cleared when a new row is read
   * 
   * @return <code>true</code> if the new current is valid; <code>false</code>
   *         if there are no more rows
   * @exception java.sql.SQLException if a database access error occurs
   */
  public boolean next() throws java.sql.SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows == 0)
      return false;

    if (currentRow + 1 >= nbOfRows)
    {
      if (hasMoreData)
      {
        this.connection.fetchNextData(cursorName, fetchSize, this);
        currentRow = 0;
        if (data == null)
        {
          nbOfRows = 0;
          return false;
        }
        else
        {
          nbOfRows = data.size();
          return true;
        }
      }

      // force scroll past end
      currentRow = nbOfRows;
      return false;
    }

    clearWarnings();
    currentRow++;
    return true;
  }

  /**
   * The prev method is not part of JDBC, but because of the architecture of
   * this driver it is possible to move both forward and backward within the
   * result set.
   * <p>
   * If an input stream from the previous row is open, it is implicitly closed.
   * The ResultSet's warning chain is cleared when a new row is read
   * 
   * @return <code>true</code> if the new current is valid; <code>false</code>
   *         if there are no more rows
   * @exception SQLException if a database access error occurs
   */
  public boolean prev() throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (currentRow - 1 >= 0)
    {
      currentRow--;
      return true;
    }

    return false;
  }

  /**
   * JDBC 2.0.
   * <p>
   * Determine if the cursor is before the first row in the result set.
   * 
   * @return <code>true</code> if before the first row, <code>false</code>
   *         otherwise. Returns <code>false</code> when the result set
   *         contains no rows.
   * @exception SQLException if a database-access error occurs.
   */
  public boolean isBeforeFirst() throws SQLException
  {
    checkIfClosed();
    if (nbOfRows == 0)
      return false;
    else
      return (currentRow == -1);
  }

  /**
   * JDBC 2.0
   * <p>
   * Determine if the cursor is after the last row in the result set.
   * 
   * @return <code>true</code> if after the last row, <code>false</code>
   *         otherwise. Returns <code>false</code> when the result set
   *         contains no rows.
   * @exception SQLException if a database-access error occurs.
   */
  public boolean isAfterLast() throws SQLException
  {
    checkIfClosed();
    if (nbOfRows == 0)
      return false;
    else
      return (currentRow >= nbOfRows);
  }

  /**
   * JDBC 2.0
   * <p>
   * Determine if the cursor is on the first row of the result set.
   * 
   * @return <code>true</code> if on the first row, <code>false</code>
   *         otherwise.
   * @exception SQLException if a database-access error occurs.
   */
  public boolean isFirst() throws SQLException
  {
    checkIfClosed();
    if (nbOfRows == 0)
      return false;
    else
      return (currentRow == 0);
  }

  /**
   * JDBC 2.0
   * <p>
   * Determine if the cursor is on the last row of the result set. Note: Calling
   * isLast() may be expensive since the JDBC driver might need to fetch ahead
   * one row in order to determine whether the current row is the last row in
   * the result set.
   * 
   * @return <code>true</code> if on the last row, <code>false</code>
   *         otherwise.
   * @exception SQLException if a database-access error occurs.
   */
  public boolean isLast() throws SQLException
  {
    checkIfClosed();
    if (nbOfRows == 0)
      return false;
    else
      return (currentRow == nbOfRows - 1);
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves to the front of the result set, just before the first row. Has no
   * effect if the result set contains no rows.
   * 
   * @exception SQLException if a database-access error occurs, or result set
   *              type is TYPE_FORWARD_ONLY
   */
  public void beforeFirst() throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    currentRow = -1;
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves to the end of the result set, just after the last row. Has no effect
   * if the result set contains no rows.
   * 
   * @exception SQLException if a database-access error occurs, or result set
   *              type is TYPE_FORWARD_ONLY.
   */
  public void afterLast() throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows != 0)
      currentRow = nbOfRows;
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves to the first row in the result set.
   * 
   * @return <code>true</code> if on a valid row, false if no rows in the
   *         result set.
   * @exception SQLException if a database-access error occurs, or result set
   *              type is TYPE_FORWARD_ONLY.
   */
  public boolean first() throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows == 0)
      return false;

    currentRow = 0;
    return true;
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves to the last row in the result set.
   * 
   * @return <code>true</code> if on a valid row, false if no rows in the
   *         result set.
   * @exception SQLException if a database-access error occurs, or result set
   *              type is TYPE_FORWARD_ONLY.
   */
  public boolean last() throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows == 0)
      return false;

    currentRow = nbOfRows - 1;
    return true;
  }

  /**
   * JDBC 2.0
   * <p>
   * Determine the current row number. The first row is number 1, the second
   * number 2, etc.
   * 
   * @return the current row number, else return 0 if there is no current row
   * @exception SQLException if a database-access error occurs.
   */
  public int getRow() throws SQLException
  {
    checkIfClosed();
    if (currentRow < 0 || currentRow >= nbOfRows || nbOfRows == 0)
      return 0;
    else
      return currentRow + 1;
  }

  /**
   * JDBC 2.0
   * <p>
   * Move to an absolute row number in the result set.
   * <p>
   * If row is positive, moves to an absolute row with respect to the beginning
   * of the result set. The first row is row 1, the second is row 2, etc.
   * <p>
   * If row is negative, moves to an absolute row position with respect to the
   * end of result set. For example, calling absolute(-1) positions the cursor
   * on the last row, absolute(-2) indicates the next-to-last row, etc.
   * <p>
   * An attempt to position the cursor beyond the first/last row in the result
   * set, leaves the cursor before/after the first/last row, respectively.
   * <p>
   * Note: Calling absolute(1) is the same as calling first(). Calling
   * absolute(-1) is the same as calling last().
   * 
   * @param row the row to move to
   * @return <code>true</code> if on the result set, false if off.
   * @exception SQLException if a database-access error occurs, or row is 0, or
   *              result set type is TYPE_FORWARD_ONLY.
   */
  public boolean absolute(int row) throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows == 0)
      return false;

    if (row == 0)
      throw new SQLException("Cannot absolute position to row 0");

    if (row == 1)
      return first();

    if (row == -1)
      return last();

    if (row > nbOfRows)
    {
      afterLast();
      return false;
    }

    if (row < 0)
    { // adjust to reflect after end of result set
      int newRowPosition = nbOfRows + row + 1;

      if (newRowPosition <= 0)
      {
        beforeFirst();
        return false;
      }

      return absolute(newRowPosition);
    }
    else
    {
      row--; // adjust for index difference
      currentRow = row;
      return true;
    }
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves a relative number of rows, either positive or negative. Attempting to
   * move beyond the first/last row in the result set positions the cursor
   * before/after the the first/last row. Calling relative(0) is valid, but does
   * not change the cursor position.
   * <p>
   * Note: Calling relative(1) is different than calling next() since is makes
   * sense to call next() when there is no current row, for example, when the
   * cursor is positioned before the first row or after the last row of the
   * result set.
   * 
   * @param rows the number of rows
   * @return <code>true</code> if on a row, false otherwise.
   * @exception SQLException if a database-access error occurs, or there is no
   *              current row, or result set type is TYPE_FORWARD_ONLY.
   */
  public boolean relative(int rows) throws SQLException
  {
    checkIfClosed();

    if (inserting)
    {
      insertStatement.clearParameters();
      tempRow = null;
      inserting = false;
    }

    if (updating)
      cancelRowUpdates();

    if (nbOfRows == 0)
      return false;

    return absolute(currentRow + rows + 1);
  }

  /**
   * JDBC 2.0
   * <p>
   * Moves to the previous row in the result set.
   * <p>
   * Note: previous() is not the same as relative(-1) since it makes sense to
   * call previous() when there is no current row.
   * 
   * @return <code>true</code> if on a valid row, false if off the result set.
   * @exception SQLException if a database-access error occurs, or result set
   *              type is TYPE_FORWAR_DONLY.
   */
  public boolean previous() throws SQLException
  {
    return prev();
  }

  /**
   * JDBC 2.0 Give a hint as to the direction in which the rows in this result
   * set will be processed. The initial value is determined by the statement
   * that produced the result set. The fetch direction may be changed at any
   * time.
   * 
   * @param direction the fetch direction
   * @exception SQLException if a database-access error occurs, or the result
   *              set type is TYPE_FORWARD_ONLY and direction is not
   *              FETCH_FORWARD. MM.MySQL actually ignores this, because it has
   *              the whole result set anyway, so the direction is immaterial.
   */
  public void setFetchDirection(int direction) throws SQLException
  {
    if (direction != FETCH_FORWARD && direction != FETCH_REVERSE)
      throw new SQLException("Illegal value for fetch direction");
    else
      fetchDirection = direction;
  }

  /**
   * JDBC 2.0 Return the fetch direction for this result set.
   * 
   * @return the fetch direction
   * @exception SQLException if a database-access error occurs
   */
  public int getFetchDirection() throws SQLException
  {
    return fetchDirection;
  }

  /**
   * JDBC 2.0 Give the JDBC driver a hint as to the number of rows that should
   * be fetched from the database when more rows are needed for this result set.
   * If the fetch size specified is zero, then the JDBC driver ignores the
   * value, and is free to make its own best guess as to what the fetch size
   * should be. The default value is set by the statement that creates the
   * result set. The fetch size may be changed at any time.
   * 
   * @param rows the number of rows to fetch
   * @exception SQLException if a database-access error occurs, or the condition
   *              0 <= rows <= statement.getMaxRows() is not satisfied.
   *              Currently ignored by this driver.
   */
  public void setFetchSize(int rows) throws SQLException
  {
    // This is just a hint afterall, let's not try to throw exceptions for
    // nothing
    if (rows < 0)
      throw new SQLException("Value must be between 0 and getMaxRows()");

    fetchSize = rows;
  }

  /**
   * JDBC 2.0 Return the fetch size for this result set.
   * 
   * @return the fetch size
   * @exception SQLException if a database-access error occurs
   */
  public int getFetchSize() throws SQLException
  {
    return fetchSize;
  }

  //
  // ---------------------------------------------------------------------
  // Getter's and Setter's
  // ---------------------------------------------------------------------
  //

  /**
   * Get the value of a column in the current row as a Java String
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return the column value, null for SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public String getString(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    if (inserting || updating)
      return tempRow[columnIndex - 1].toString();
    else
      return (((Object[]) data.get(currentRow))[columnIndex - 1]).toString();
  }

  /**
   * Get the value of a column in the current row as a Java boolean
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return the column value, false for SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public boolean getBoolean(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return false;

    Object object;
    if (inserting || updating)
      object = tempRow[columnIndex - 1];
    else
      object = (((Object[]) data.get(currentRow))[columnIndex - 1]);

    String stringVal = object.toString();
    if ((stringVal != null) && (stringVal.length() > 0))
    {
      stringVal = stringVal.toLowerCase();

      // first we check the connection values to be consistent
      if (this.connection.getPreparedStatementBooleanTrue().equals(
          stringVal))
      {
        return true;
      }
      else if (this.connection.getPreparedStatementBooleanFalse()
          .equals(stringVal))
      {
        return false;
      }

      // now we check some other possible string representations of boolean
      else if ("t".equals(stringVal))
      {
        return true;
      }
      else if ("f".equals(stringVal))
      {
        return false;
      }
      else if ("true".equals(stringVal))
      {
        return true;
      }
      else if ("false".equals(stringVal))
      {
        return false;
      }
      else if ("1".equals(stringVal))
      {
        return true;
      }
      else if ("0".equals(stringVal))
      {
        return false;
      }
      else if ("y".equals(stringVal))
      {
        return true;
      }
      else if ("n".equals(stringVal))
      {
        return false;
      }
      else if ("yes".equals(stringVal))
      {
        return true;
      }
      else if ("no".equals(stringVal))
      {
        return false;
      }
      else if (object instanceof Number)
      {
        int value = ((Number) object).intValue();
        if (value == 0)
          return false;
        else if (value == 1)
          return true;
        // else other value throw an exception
      }

      // we didn't find anything reasonable and throw an exception
      throw new SQLException("column value " + stringVal
          + " could not be converted to boolean");
    }
    else
    {
      return false;
    }
  }

  /**
   * Get the value of a column in the current row as a Java short.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public short getShort(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).shortValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Short.parseShort(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid short number");
    }
  }

  /**
   * Get the value of a column in the current row as a Java int.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public int getInt(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).intValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Integer.parseInt(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid int number");
    }
  }

  /**
   * Get the value of a column in the current row as a Java long.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public long getLong(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).longValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Long.parseLong(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid long number");
    }
  }

  /**
   * Get the value of a column in the current row as a Java float.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public float getFloat(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).floatValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Float.parseFloat(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid float number");
    }
  }

  /**
   * Get the value of a column in the current row as a Java double.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public double getDouble(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).doubleValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Double.parseDouble(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid double number");
    }
  }

  /**
   * Get the value of a column in the current row as a java.lang.BigDecimal
   * object
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @param scale the number of digits to the right of the decimal
   * @return the column value; if the value is SQL NULL, null
   * @exception SQLException if a database access error occurs
   * @deprecated
   */
  public BigDecimal getBigDecimal(int columnIndex, int scale)
      throws SQLException
  {
    BigDecimal bigDecimal = getBigDecimal(columnIndex);
    if (bigDecimal == null)
      return null;
    else
      return bigDecimal.setScale(scale);
  }

  /**
   * Get the value of a column in the current row as a Java byte array.
   * <p>
   * <b>Be warned </b> If the blob is huge, then you may run out of memory.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database access error occurs
   */
  public byte[] getBytes(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object o;
    if (inserting || updating)
      o = tempRow[columnIndex - 1];
    else
      o = ((Object[]) data.get(currentRow))[columnIndex - 1];

    byte[] tmp;
    if (o instanceof java.lang.String)
    {
      tmp = ((String) o).getBytes();
    }
    else
    {
      tmp = (byte[]) o;
    }

    if (this.connection.isDriverProcessed())
      return this.connection.getBlobFilter().decode(tmp);
    else
      return tmp;
  }

  /**
   * Get the value of a column in the current row as a java.sql.Date object
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return the column value; null if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public java.sql.Date getDate(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    // we may be reading a timestamp column and have to convert it to date
    // the client is asking for the date field only, we have to make sure
    // hour,minutes,... are cleared
    String dateString;
    if (inserting || updating)
      dateString = tempRow[columnIndex - 1].toString();
    else
      dateString = ((Object[]) data.get(currentRow))[columnIndex - 1]
          .toString();

    if (dateString.length() == 10)
      return java.sql.Date.valueOf(dateString);
    else
      return java.sql.Date.valueOf(dateString.substring(0, 10));
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return the column value; null if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public Time getTime(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof java.util.Date)
    {
      java.util.Date time = (java.util.Date) obj;
      // the driver returns the format of the column, but we are asking for
      // the time values only.
      String timeString = time.toString();
      if (timeString.length() == 8)
      {
        // ok we have got a timefield of the format HH:mm:ss, exactly the way
        // we need it, no further processing is required
        return new Time(time.getTime());
      }

      // we have got the date fields too and have to clear the year, month and
      // date field
      Calendar cal = Calendar.getInstance();
      cal.setTime(time);
      cal.clear(Calendar.YEAR);
      cal.clear(Calendar.MONTH);
      cal.clear(Calendar.DATE);
      cal.clear(Calendar.MILLISECOND);
      return new Time(cal.getTimeInMillis());
    }

    // the object is not of type date we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Time.valueOf(string);
    }
    catch (IllegalArgumentException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid time");
    }
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp object
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return the column value; null if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public Timestamp getTimestamp(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof java.util.Date)
    {
      return new Timestamp(((java.util.Date) obj).getTime());
    }

    // the object is not of type timestamp we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Timestamp.valueOf(string);
    }
    catch (IllegalArgumentException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid timestamp");
    }
  }

  /**
   * A column value can be retrieved as a stream of ASCII characters and then
   * read in chunks from the stream. This method is particulary suitable for
   * retrieving large LONGVARCHAR values. The JDBC driver will do any necessary
   * conversion from the database format into ASCII.
   * <p>
   * <B>Note: </B> All the data in the returned stream must be read prior to
   * getting the value of any other column. The next call to a get method
   * implicitly closes the stream. Also, a stream may return 0 for available()
   * whether there is data available or not.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return a Java InputStream that delivers the database column value as a
   *         stream of one byte ASCII characters. If the value is SQL NULL then
   *         the result is null
   * @exception SQLException if a database access error occurs
   * @see #getBinaryStream(int)
   */
  public InputStream getAsciiStream(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    return getBinaryStream(columnIndex);
  }

  /**
   * A column value can also be retrieved as a stream of Unicode characters. We
   * implement this as a binary stream.
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return a Java InputStream that delivers the database column value as a
   *         stream of two byte Unicode characters. If the value is SQL NULL,
   *         then the result is null
   * @exception SQLException if a database access error occurs
   * @deprecated
   * @see #getAsciiStream
   * @see #getBinaryStream(int)
   */
  public InputStream getUnicodeStream(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    return getBinaryStream(columnIndex);
  }

  /**
   * A column value can also be retrieved as a binary strea. This method is
   * suitable for retrieving LONGVARBINARY values.
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return a Java InputStream that delivers the database column value as a
   *         stream of bytes. If the value is SQL NULL, then the result is null
   * @exception SQLException if a database access error occurs
   * @see #getAsciiStream(int)
   * @see #getUnicodeStream(int)
   */

  public InputStream getBinaryStream(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    byte[] b = getBytes(columnIndex);
    if (b != null)
      return new ByteArrayInputStream(b);
    else
      return null; // SQL NULL
  }

  /**
   * The following routines simply convert the columnName into a columnIndex and
   * then call the appropriate routine above.
   * 
   * @param columnName is the SQL name of the column
   * @return the column value
   * @exception SQLException if a database access error occurs
   */
  public String getString(String columnName) throws SQLException
  {
    return this.getString(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getBoolean(java.lang.String)
   */
  public boolean getBoolean(String columnName) throws SQLException
  {
    return getBoolean(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getByte(java.lang.String)
   */
  public byte getByte(String columnName) throws SQLException
  {
    return getByte(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getShort(java.lang.String)
   */
  public short getShort(String columnName) throws SQLException
  {
    return getShort(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getInt(java.lang.String)
   */
  public int getInt(String columnName) throws SQLException
  {
    return getInt(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getLong(java.lang.String)
   */
  public long getLong(String columnName) throws SQLException
  {
    return getLong(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getFloat(java.lang.String)
   */
  public float getFloat(String columnName) throws SQLException
  {
    return getFloat(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getDouble(java.lang.String)
   */
  public double getDouble(String columnName) throws SQLException
  {
    return getDouble(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getBigDecimal(String, int)
   * @deprecated
   */
  public BigDecimal getBigDecimal(String columnName, int scale)
      throws SQLException
  {
    return getBigDecimal(findColumn(columnName), scale);
  }

  /**
   * @see java.sql.ResultSet#getBytes(java.lang.String)
   */
  public byte[] getBytes(String columnName) throws SQLException
  {
    return getBytes(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getDate(java.lang.String)
   */
  public java.sql.Date getDate(String columnName) throws SQLException
  {
    return getDate(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getTime(java.lang.String)
   */
  public Time getTime(String columnName) throws SQLException
  {
    return getTime(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getTimestamp(java.lang.String)
   */
  public Timestamp getTimestamp(String columnName) throws SQLException
  {
    return getTimestamp(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getAsciiStream(java.lang.String)
   */
  public InputStream getAsciiStream(String columnName) throws SQLException
  {
    return getAsciiStream(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getUnicodeStream(String)
   * @deprecated
   */
  public InputStream getUnicodeStream(String columnName) throws SQLException
  {
    return getUnicodeStream(findColumn(columnName));
  }

  /**
   * @see java.sql.ResultSet#getBinaryStream(java.lang.String)
   */
  public InputStream getBinaryStream(String columnName) throws SQLException
  {
    return getBinaryStream(findColumn(columnName));
  }

  /**
   * The first warning reported by calls on this ResultSet is returned.
   * Subsequent ResultSet warnings will be chained to this java.sql.SQLWarning.
   * <p>
   * The warning chain is automatically cleared each time a new row is read.
   * <p>
   * <B>Note: </B> This warning chain only covers warnings caused by ResultSet
   * methods. Any warnings caused by statement methods (such as reading OUT
   * parameters) will be chained on the Statement object.
   * 
   * @return the first java.sql.SQLWarning or null;
   * @exception SQLException if a database access error occurs.
   */
  public java.sql.SQLWarning getWarnings() throws SQLException
  {
    return warnings;
  }

  /**
   * After this call, getWarnings returns null until a new warning is reported
   * for this ResultSet
   * 
   * @exception SQLException if a database access error occurs
   */

  public void clearWarnings() throws SQLException
  {
    warnings = null;
  }

  /**
   * @see java.sql.ResultSet#getCursorName()
   */
  public String getCursorName() throws SQLException
  {
    return cursorName;
  }

  /**
   * Get the value of a column in the current row as a Java object
   * <p>
   * This method will return the value of the given column as a Java object. The
   * type of the Java object will be the default Java Object type corresponding
   * to the column's SQL type, following the mapping specified in the JDBC
   * specification.
   * <p>
   * This method may also be used to read database specific abstract data types.
   * 
   * @param columnIndex the first column is 1, the second is 2...
   * @return a Object holding the column value
   * @exception SQLException if a database access error occurs
   */
  public Object getObject(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object o;
    if (inserting || updating)
      o = tempRow[columnIndex];
    else
      o = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (owningStatement != null)
    {
      /**
       * We make the bet that a byte array is a blob we have encoded
       * {@link Blob}, and not some XXXBINARY returned by the backend driver.
       * TODO: could we use some magic number ? Look at the SQL type ?
       */
      if (this.connection.isDriverProcessed() && o instanceof byte[])
      {
        try
        {
          byte[] b = this.connection.getBlobFilter().decode((byte[]) o);
          return new ObjectInputStream(new ByteArrayInputStream(b))
              .readObject();
        }
        catch (ClassNotFoundException e)
        {
          e.printStackTrace();
          throw new SQLException("Missing class while deserializing Blob" + e);
        }
        catch (IOException e)
        {
          e.printStackTrace();
          throw new SQLException("IOException while deserializing Blob" + e);
        }
      }
    }
    return o;
  }

  /**
   * Get the value of a column in the current row as a Java object
   * <p>
   * This method will return the value of the given column as a Java object. The
   * type of the Java object will be the default Java Object type corresponding
   * to the column's SQL type, following the mapping specified in the JDBC
   * specification.
   * <p>
   * This method may also be used to read database specific abstract data types.
   * 
   * @param columnName is the SQL name of the column
   * @return a Object holding the column value
   * @exception SQLException if a database access error occurs
   */
  public Object getObject(String columnName) throws SQLException
  {
    return getObject(findColumn(columnName));
  }

  // --------------------------JDBC 2.0-----------------------------------

  /**
   * @see java.sql.ResultSet#getCharacterStream(int)
   */
  public java.io.Reader getCharacterStream(int columnIndex) throws SQLException
  {
    String s = getString(columnIndex);
    if (s == null)
      return null;
    char[] content = s.toCharArray();
    return new java.io.CharArrayReader(content);
  }

  /**
   * @see java.sql.ResultSet#getCharacterStream(java.lang.String)
   */
  public java.io.Reader getCharacterStream(String columnName)
      throws SQLException
  {
    return getCharacterStream(findColumn(columnName));
  }

  /**
   * JDBC 2.0 Get the value of a column in the current row as a
   * java.math.BigDecimal object.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return the column value (full precision); if the value is SQL NULL, the
   *         result is null
   * @exception SQLException if a database-access error occurs.
   */
  public BigDecimal getBigDecimal(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof BigDecimal)
      return (BigDecimal) obj;
    else if (obj instanceof Long)
    {
      return new BigDecimal(((Long) obj).longValue());
    }
    else if (obj instanceof BigInteger)
    {
      return new BigDecimal(((BigInteger) obj));
    }
    else if (obj instanceof Short)
    {
      return new BigDecimal(((Short) obj).shortValue());
    }
    else if (obj instanceof Integer)
    {
      return new BigDecimal(((Integer) obj).intValue());
    }
    else if (obj instanceof String)
    {
      return new BigDecimal((String) obj);
    }
    else if (obj instanceof Number)
    {
      // float and double have to be converted via string
      // othwerwise we produce errors
      // javadoc for BigDecimal :
      // Note: the results of this constructor can be somewhat unpredictable.
      // One might assume that new BigDecimal(.1) is exactly equal to .1, but
      // it is actually equal to
      // .1000000000000000055511151231257827021181583404541015625. This is so
      // because .1 cannot be represented exactly as a double (or, for that
      // matter, as a binary fraction of any finite length). Thus, the long
      // value that is being passed in to the constructor is not exactly equal
      // to .1, appearances nonwithstanding.

      // The (String) constructor, on the other hand, is perfectly
      // predictable: new BigDecimal(".1") is exactly equal to .1, as one
      // would expect. Therefore, it is generally recommended that the
      // (String) constructor be used in preference to this one.
      return new BigDecimal(obj.toString());
    }
    else
    {
      throw new SQLException("Type " + obj.getClass().getName()
          + " is not compatible with BigDecimal");
    }
  }

  /**
   * @see java.sql.ResultSet#getBigDecimal(java.lang.String)
   */
  public BigDecimal getBigDecimal(String columnName) throws SQLException
  {
    return getBigDecimal(findColumn(columnName));
  }

  /**
   * JDBC 2.0 Returns the value of column as a Java object. Use the map to
   * determine the class from which to construct data of SQL structured and
   * distinct types.
   * 
   * @param i the first column is 1, the second is 2, ...
   * @param map the mapping from SQL type names to Java classes
   * @return an object representing the SQL value
   * @exception SQLException if a database-access error occurs.
   */
 
  public Object getObject(int i, java.util.Map map) throws SQLException
  {
    throw new NotImplementedException("getObject(int, java.util.Map)");
  }

  /**
   * JDBC 2.0 Get a REF(&lt;structured-type&gt;) column.
   * 
   * @param i the first column is 1, the second is 2, ...
   * @return an object representing data of an SQL REF type
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Ref getRef(int i) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(i);

    if (wasNullFlag)
      return null;

    if (inserting || updating)
      return (Ref) tempRow[i - 1];
    else
      return (Ref) (((Object[]) data.get(currentRow))[i - 1]);
  }

  /**
   * JDBC 2.0 Gets a BLOB column.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return an object representing a BLOB
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Blob getBlob(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object o;
    if (inserting || updating)
      o = tempRow[columnIndex - 1];
    else
      o = (((Object[]) data.get(currentRow))[columnIndex - 1]);

    // Test if the type of the Blob is indeed a Blob else we assume these are
    // just bytes.
    if (o instanceof Blob)
      return (java.sql.Blob) o;
    else
      return new Blob(getBytes(columnIndex));
  }

  /**
   * JDBC 2.0 Gets a CLOB column.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return an object representing a CLOB
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Clob getClob(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    Object o;
    if (inserting || updating)
      o = tempRow[columnIndex - 1];
    else
      o = (((Object[]) data.get(currentRow))[columnIndex - 1]);

    // Test if the type of the Clob is indeed a Clob or just a String
    // throw new SQLException("Class:"+o.getClass());
    if (o instanceof String)
      return new Clob((String) o);
    else if (o instanceof Clob)
      return (java.sql.Clob) o;
    else
      return new Clob(new String(o.toString()));
  }

  /**
   * JDBC 2.0 Gets an array column.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @return an object representing an SQL array
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Array getArray(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    if (inserting || updating)
      return (java.sql.Array) tempRow[columnIndex - 1];
    else
      return (java.sql.Array) (((Object[]) data.get(currentRow))[columnIndex - 1]);
  }

  /**
   * JDBC 2.0 Returns the value of column as a Java object. Use the map to
   * determine the class from which to construct data of SQL structured and
   * distinct types.
   * 
   * @param colName the column name
   * @param map the mapping from SQL type names to Java classes
   * @return an object representing the SQL value
   * @exception SQLException if a database-access error occurs.
   */
  public Object getObject(String colName, java.util.Map map)
      throws SQLException
  {
    return getObject(findColumn(colName), map);
  }

  /**
   * JDBC 2.0 Get a REF(&lt;structured-type&gt;) column.
   * 
   * @param colName the column name
   * @return an object representing data of an SQL REF type
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Ref getRef(String colName) throws SQLException
  {
    return getRef(findColumn(colName));
  }

  /**
   * JDBC 2.0 Get a BLOB column.
   * 
   * @param colName the column name
   * @return an object representing a BLOB
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Blob getBlob(String colName) throws SQLException
  {
    return getBlob(findColumn(colName));
  }

  /**
   * JDBC 2.0 Get a CLOB column.
   * 
   * @param colName the column name
   * @return an object representing a CLOB
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Clob getClob(String colName) throws SQLException
  {
    return getClob(findColumn(colName));
  }

  /**
   * JDBC 2.0 Get an array column.
   * 
   * @param colName the column name
   * @return an object representing an SQL array
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Array getArray(String colName) throws SQLException
  {
    return getArray(findColumn(colName));
  }

  /**
   * JDBC 2.0 Get the value of a column in the current row as a java.sql.Date
   * object. Use the calendar to construct an appropriate millisecond value for
   * the Date, if the underlying database doesn't store timezone information.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the date (ignored)
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Date getDate(int columnIndex, Calendar cal)
      throws SQLException
  {
    return getDate(columnIndex);
  }

  /**
   * Get the value of a column in the current row as a java.sql.Date object. Use
   * the calendar to construct an appropriate millisecond value for the Date, if
   * the underlying database doesn't store timezone information.
   * 
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the date
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Date getDate(String columnName, Calendar cal)
      throws SQLException
  {
    return getDate(findColumn(columnName), cal);
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object. Use
   * the calendar to construct an appropriate millisecond value for the Time, if
   * the underlying database doesn't store timezone information.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the time
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Time getTime(int columnIndex, Calendar cal)
      throws SQLException
  {
    return getTime(columnIndex);
  }

  /**
   * Get the value of a column in the current row as a java.sql.Time object. Use
   * the calendar to construct an appropriate millisecond value for the Time, if
   * the underlying database doesn't store timezone information.
   * 
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the time
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Time getTime(String columnName, Calendar cal)
      throws SQLException
  {
    return getTime(findColumn(columnName), cal);
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp
   * object. Use the calendar to construct an appropriate millisecond value for
   * the Timestamp, if the underlying database doesn't store timezone
   * information.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param cal the calendar to use in constructing the timestamp (ignored)
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal)
      throws SQLException
  {
    return getTimestamp(columnIndex);
  }

  /**
   * Get the value of a column in the current row as a java.sql.Timestamp
   * object. Use the calendar to construct an appropriate millisecond value for
   * the Timestamp, if the underlying database doesn't store timezone
   * information.
   * 
   * @param columnName is the SQL name of the column
   * @param cal the calendar to use in constructing the timestamp
   * @return the column value; if the value is SQL NULL, the result is null
   * @exception SQLException if a database-access error occurs.
   */
  public java.sql.Timestamp getTimestamp(String columnName, Calendar cal)
      throws SQLException
  {
    return getTimestamp(findColumn(columnName), cal);
  }

  // ---------------------------------------------------------------------
  // Updates
  // ---------------------------------------------------------------------

  /**
   * JDBC 2.0 Determine if the current row has been updated. The value returned
   * depends on whether or not the result set can detect updates.
   * 
   * @return <code>true</code> if the row has been visibly updated by the
   *         owner or another, and updates are detected
   * @exception SQLException if a database-access error occurs
   * @see DatabaseMetaData#updatesAreDetected
   */
  public boolean rowUpdated() throws SQLException
  {
    throw new NotImplementedException("rowUpdated");
  }

  /**
   * JDBC 2.0 Determine if the current row has been inserted. The value returned
   * depends on whether or not the result set can detect visible inserts.
   * 
   * @return <code>true</code> if inserted and inserts are detected
   * @exception SQLException if a database-access error occurs
   * @see DatabaseMetaData#insertsAreDetected
   */
  public boolean rowInserted() throws SQLException
  {
    throw new NotImplementedException("rowInserted");
  }

  /**
   * JDBC 2.0 Determine if this row has been deleted. A deleted row may leave a
   * visible "hole" in a result set. This method can be used to detect holes in
   * a result set. The value returned depends on whether or not the result set
   * can detect deletions.
   * 
   * @return <code>true</code> if deleted and deletes are detected
   * @exception SQLException if a database-access error occurs
   * @see DatabaseMetaData#deletesAreDetected
   */
  public boolean rowDeleted() throws SQLException
  {
    throw new NotImplementedException("rowDeleted");
  }

  /**
   * JDBC 2.0 Give a nullable column a null value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @exception SQLException if a database-access error occurs
   */
  public void updateNull(int columnIndex) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement
          .setNull(columnIndex, fields[columnIndex - 1].getSqlType());
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement
          .setNull(columnIndex, fields[columnIndex - 1].getSqlType());
    }

    tempRow[columnIndex - 1] = null;
  }

  /**
   * JDBC 2.0 Update a column with a boolean value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */

  public void updateBoolean(int columnIndex, boolean x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setBoolean(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setBoolean(columnIndex, x);
    }

    tempRow[columnIndex - 1] = Boolean.valueOf(x);
  }

  /**
   * JDBC 2.0 Update a column with a byte value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateByte(int columnIndex, byte x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setByte(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setByte(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Byte(x);
  }

  /**
   * JDBC 2.0 Update a column with a short value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateShort(int columnIndex, short x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setShort(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setShort(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Short(x);
  }

  /**
   * JDBC 2.0 Update a column with an integer value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateInt(int columnIndex, int x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setInt(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setInt(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Integer(x);
  }

  /**
   * JDBC 2.0 Update a column with a long value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateLong(int columnIndex, long x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setLong(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setLong(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Long(x);
  }

  /**
   * JDBC 2.0 Update a column with a float value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateFloat(int columnIndex, float x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setFloat(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setFloat(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Float(x);
  }

  /**
   * JDBC 2.0 Update a column with a Double value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateDouble(int columnIndex, double x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setDouble(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setDouble(columnIndex, x);
    }

    tempRow[columnIndex - 1] = new Double(x);
  }

  /**
   * JDBC 2.0 Update a column with a BigDecimal value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateBigDecimal(int columnIndex, BigDecimal x)
      throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setBigDecimal(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setBigDecimal(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a String value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateString(int columnIndex, String x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setString(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setString(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a byte array value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateBytes(int columnIndex, byte[] x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setBytes(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setBytes(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a Date value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateDate(int columnIndex, java.sql.Date x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setDate(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setDate(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a Time value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateTime(int columnIndex, java.sql.Time x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setTime(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setTime(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a Timestamp value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateTimestamp(int columnIndex, java.sql.Timestamp x)
      throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setTimestamp(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setTimestamp(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with an ascii stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateAsciiStream(int columnIndex, java.io.InputStream x,
      int length) throws SQLException
  {
    this.updateBinaryStream(columnIndex, x, length);
  }

  /**
   * JDBC 2.0 Update a column with a binary stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateBinaryStream(int columnIndex, java.io.InputStream x,
      int length) throws SQLException
  {
    checkIfClosed();

    byte[] content = new byte[length];
    try
    {
      x.read(content, 0, length);
    }
    catch (Exception ioe)
    {
      throw new SQLException("Problem with streaming of data");
    }

    this.updateBytes(columnIndex, content);
  }

  /**
   * JDBC 2.0 Update a column with a character stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param length the length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateCharacterStream(int columnIndex, java.io.Reader x,
      int length) throws SQLException
  {
    checkIfClosed();

    char[] content = new char[length];
    try
    {
      x.read(content, 0, length);
    }
    catch (Exception ioe)
    {
      throw new SQLException("Problem with streaming of data");
    }

    this.updateString(columnIndex, new String(content));
  }

  /**
   * JDBC 2.0 Update a column with an Object value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
   *          this is the number of digits after the decimal. For all other
   *          types this value will be ignored.
   * @exception SQLException if a database-access error occurs
   */
  public void updateObject(int columnIndex, Object x, int scale)
      throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setObject(columnIndex, x, scale);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setObject(columnIndex, x, scale);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with an Object value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateObject(int columnIndex, Object x) throws SQLException
  {
    checkIfClosed();

    if (inserting)
      insertStatement.setObject(columnIndex, x);
    else
    {
      checkUpdateFlagAndPrepareUpdateIfNeeded();
      updateStatement.setObject(columnIndex, x);
    }

    tempRow[columnIndex - 1] = x;
  }

  /**
   * JDBC 2.0 Update a column with a null value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @exception SQLException if a database-access error occurs
   */

  public void updateNull(String columnName) throws SQLException
  {
    this.updateNull(findColumn(columnName));
  }

  /**
   * JDBC 2.0 Update a column with a boolean value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateBoolean(String columnName, boolean x) throws SQLException
  {
    this.updateBoolean(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a byte value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateByte(String columnName, byte x) throws SQLException
  {
    this.updateByte(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a short value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateShort(String columnName, short x) throws SQLException
  {
    this.updateShort(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with an integer value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateInt(String columnName, int x) throws SQLException
  {
    this.updateInt(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a long value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateLong(String columnName, long x) throws SQLException
  {
    this.updateLong(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a float value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateFloat(String columnName, float x) throws SQLException
  {
    this.updateFloat(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a double value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateDouble(String columnName, double x) throws SQLException
  {
    this.updateDouble(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a BigDecimal value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateBigDecimal(String columnName, BigDecimal x)
      throws SQLException
  {
    this.updateBigDecimal(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a String value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateString(String columnName, String x) throws SQLException
  {
    this.updateString(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a byte array value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateBytes(String columnName, byte[] x) throws SQLException
  {
    this.updateBytes(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a Date value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateDate(String columnName, java.sql.Date x)
      throws SQLException
  {
    this.updateDate(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a Time value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateTime(String columnName, java.sql.Time x)
      throws SQLException
  {
    this.updateTime(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with a Timestamp value. The updateXXX() methods
   * are used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateTimestamp(String columnName, java.sql.Timestamp x)
      throws SQLException
  {
    this.updateTimestamp(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Update a column with an ascii stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @param length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateAsciiStream(String columnName, java.io.InputStream x,
      int length) throws SQLException
  {
    this.updateAsciiStream(findColumn(columnName), x, length);
  }

  /**
   * JDBC 2.0 Update a column with a binary stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @param length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateBinaryStream(String columnName, java.io.InputStream x,
      int length) throws SQLException
  {
    this.updateBinaryStream(findColumn(columnName), x, length);
  }

  /**
   * JDBC 2.0 Update a column with a character stream value. The updateXXX()
   * methods are used to update column values in the current row, or the insert
   * row. The updateXXX() methods do not update the underlying database, instead
   * the updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param reader the stream
   * @param length of the stream
   * @exception SQLException if a database-access error occurs
   */
  public void updateCharacterStream(String columnName, java.io.Reader reader,
      int length) throws SQLException
  {
    this.updateCharacterStream(findColumn(columnName), reader, length);
  }

  /**
   * JDBC 2.0 Update a column with an Object value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @param scale For java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types
   *          this is the number of digits after the decimal. For all other
   *          types this value will be ignored.
   * @exception SQLException if a database-access error occurs
   */
  public void updateObject(String columnName, Object x, int scale)
      throws SQLException
  {
    this.updateObject(findColumn(columnName), x, scale);
  }

  /**
   * JDBC 2.0 Update a column with an Object value. The updateXXX() methods are
   * used to update column values in the current row, or the insert row. The
   * updateXXX() methods do not update the underlying database, instead the
   * updateRow() or insertRow() methods are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database-access error occurs
   */
  public void updateObject(String columnName, Object x) throws SQLException
  {
    this.updateObject(findColumn(columnName), x);
  }

  /**
   * JDBC 2.0 Insert the contents of the insert row into the result set and the
   * database. Must be on the insert row when this method is called.
   * 
   * @exception SQLException if a database-access error occurs, if called when
   *              not on the insert row, or if all non-nullable columns in the
   *              insert row have not been given a value
   */
  public void insertRow() throws SQLException
  {
    checkIfClosed();

    if (!inserting)
      throw new SQLException("insertRow cannot be called "
          + "when the cursor is not on the insert row");

    // Insert row in underlying database
    try
    {
      insertStatement.executeUpdate();
    }
    finally
    {
      // Clean up
      insertStatement.clearParameters();
    }

    // Insert row in this ResultSet
    if (data == null)
      data = new ArrayList();
    data.add(tempRow);
    nbOfRows++;

    // Prepare for a new insert
    tempRow = new Object[nbOfColumns];
  }

  /**
   * JDBC 2.0 Update the underlying database with the new contents of the
   * current row. Cannot be called when on the insert row.
   * 
   * @exception SQLException if a database-access error occurs, or if called
   *              when on the insert row
   */
  public void updateRow() throws SQLException
  {
    checkIfClosed();

    if (inserting)
      throw new SQLException("updateRow cannot be called "
          + "when the cursor is on the insert row");

    if (!updating)
      return;

    // Add primary key info from current row
    for (int i = 0; i < primaryKeyColumns.length; ++i)
      updateStatement.setObject(nbOfColumns + i + 1, ((Object[]) data
          .get(currentRow))[findColumn(primaryKeyColumns[i]) - 1]);

    // Update row in underlying database
    try
    {
      updateStatement.executeUpdate();
    }
    finally
    {
      // Clean up
      updateStatement.clearParameters();
    }

    // Update row in this ResultSet
    data.set(currentRow, tempRow);

    // Clean up
    tempRow = null;
    updating = false;
  }

  /**
   * JDBC 2.0 Delete the current row from the result set and the underlying
   * database. Cannot be called when on the insert row.
   * 
   * @exception SQLException if a database-access error occurs, or if called
   *              when on the insert row.
   */
  public void deleteRow() throws SQLException
  {
    checkIfClosed();

    if (inserting)
      throw new SQLException("deleteRow cannot be called "
          + "when the cursor is on the insert row");

    this.checkRowPos();

    if (deleteStatement == null)
      this.buildDeleteStatement();

    // Add primary key info from current row
    for (int i = 0; i < primaryKeyColumns.length; ++i)
      deleteStatement
          .setObject(
              i + 1,
              ((Object[]) data.get(currentRow))[findColumn(primaryKeyColumns[i]) - 1]);

    // Delete row from underlying database
    try
    {
      deleteStatement.executeUpdate();
    }
    finally
    {
      // Clean up
      deleteStatement.clearParameters();
    }

    // Delete row from this ResultSet
    data.remove(currentRow);
    nbOfRows--;

    // Deleting cancels all updates on the row
    if (updating)
      this.cancelRowUpdates();
  }

  /**
   * JDBC 2.0 Refresh the value of the current row with its current value in the
   * database. Cannot be called when on the insert row. The refreshRow() method
   * provides a way for an application to explicitly tell the JDBC driver to
   * refetch a row(s) from the database. An application may want to call
   * refreshRow() when caching or prefetching is being done by the JDBC driver
   * to fetch the latest value of a row from the database. The JDBC driver may
   * actually refresh multiple rows at once if the fetch size is greater than
   * one. All values are refetched subject to the transaction isolation level
   * and cursor sensitivity. If refreshRow() is called after calling
   * updateXXX(), but before calling updateRow() then the updates made to the
   * row are lost. Calling refreshRow() frequently will likely slow performance.
   * 
   * @exception SQLException if a database-access error occurs, or if called
   *              when on the insert row.
   */
  public void refreshRow() throws SQLException
  {
    checkIfClosed();

    if (inserting)
      throw new SQLException("refreshRow cannot be called "
          + "when the cursor is on the insert row");

    this.checkRowPos();

    if (refreshStatement == null)
      this.buildRefreshStatement();

    // Add primary key info from current row
    for (int i = 0; i < primaryKeyColumns.length; ++i)
      refreshStatement
          .setObject(
              i + 1,
              ((Object[]) data.get(currentRow))[findColumn(primaryKeyColumns[i]) - 1]);

    // Retrieve row from underlying database
    DriverResultSet res;
    try
    {
      res = (DriverResultSet) refreshStatement.executeQuery();
    }
    finally
    {
      // Clean up
      refreshStatement.clearParameters();
    }

    // Refresh row in this ResultSet
    try
    {
      data.set(currentRow, res.data.get(0));
    }
    catch (NullPointerException e)
    {
      throw new SQLException("The current row has been "
          + "removed from the database");
    }
    finally
    {
      // Clean up
      res.close();
    }

    // Refreshing cancels all updates on the row
    if (updating)
      this.cancelRowUpdates();
  }

  /**
   * JDBC 2.0 The cancelRowUpdates() method may be called after calling an
   * updateXXX() method(s) and before calling updateRow() to rollback the
   * updates made to a row. If no updates have been made or updateRow() has
   * already been called, then this method has no effect.
   * 
   * @exception SQLException if a database-access error occurs, or if called
   *              when on the insert row.
   */
  public void cancelRowUpdates() throws SQLException
  {
    checkIfClosed();

    if (inserting)
      throw new SQLException("cancelRowUpdates cannot be "
          + "called when the cursor is on the insert row");

    if (!updating)
      return;

    updateStatement.clearParameters();
    tempRow = null;
    updating = false;
  }

  /**
   * JDBC 2.0 Move to the insert row. The current cursor position is remembered
   * while the cursor is positioned on the insert row. The insert row is a
   * special row associated with an updatable result set. It is essentially a
   * buffer where a new row may be constructed by calling the updateXXX()
   * methods prior to inserting the row into the result set. Only the
   * updateXXX(), getXXX(), and insertRow() methods may be called when the
   * cursor is on the insert row. All of the columns in a result set must be
   * given a value each time this method is called before calling insertRow().
   * UpdateXXX()must be called before getXXX() on a column.
   * 
   * @exception SQLException if a database-access error occurs, or the result
   *              set is not updatable
   */
  public void moveToInsertRow() throws SQLException
  {
    checkIfClosed();

    if (inserting)
      return;

    if (insertStatement == null)
      this.buildInsertStatement();

    tempRow = new Object[nbOfColumns];
    inserting = true;
  }

  /**
   * JDBC 2.0 Move the cursor to the remembered cursor position, usually the
   * current row. Has no effect unless the cursor is on the insert row.
   * 
   * @exception SQLException if a database-access error occurs, or the result
   *              set is not updatable
   */
  public void moveToCurrentRow() throws SQLException
  {
    checkIfClosed();

    if (!inserting)
      return;

    insertStatement.clearParameters();
    tempRow = null;
    inserting = false;
  }

  //
  // ------------------------------------------
  // ResultSet meta-data related functions
  // ------------------------------------------
  //

  /**
   * JDBC 2.0 Return the type of this result set. The type is determined based
   * on the statement that created the result set.
   * 
   * @return TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or
   *         TYPE_SCROLL_SENSITIVE
   * @exception SQLException if a database-access error occurs
   */
  public int getType() throws SQLException
  {
    return resultSetType;
  }

  /**
   * JDBC 2.0 Return the concurrency of this result set. The concurrency used is
   * determined by the statement that created the result set.
   * 
   * @return CONCUR_READ_ONLY or CONCUR_UPDATABLE
   * @exception SQLException if a database-access error occurs
   */

  public int getConcurrency() throws SQLException
  {
    return resultSetConcurrency;
  }

  /**
   * Closes the remote ResultSet if the ResultSet was streamed else just closes
   * the ResultSet locally.
   * 
   * @exception SQLException if a database access error occurs
   */
  public void close() throws SQLException
  {
    if (hasMoreData)
      this.connection.closeRemoteResultSet(cursorName);
    isClosed = true;
  }

  /**
   * A column may have the value of SQL NULL; wasNull() reports whether the last
   * column read had this special value. Note that you must first call getXXX on
   * a column to try to read its value and then call wasNull() to find if the
   * value was SQL NULL
   * 
   * @return <code>true</code> if the last column read was SQL NULL
   * @exception SQLException if a database access error occurred
   */

  public boolean wasNull() throws SQLException
  {
    return wasNullFlag;
  }

  /**
   * JDBC 2.0 Return the <code>Statement</code> that produced the
   * <code>ResultSet</code>.
   * 
   * @return the <code>Statement</code> that produced the
   *         <code>ResultSet</code>, or null if the result was produced some
   *         other way.
   * @exception SQLException if a database-access error occurs
   */
  public java.sql.Statement getStatement() throws SQLException
  {
    return owningStatement;
  }

  /**
   * Set the ResultSet data with the given ArrayList. This function is used by
   * the ResultSet streaming feature.
   * <p>
   * Note that metadata (currentRow, nbOfRows, ...) are not updated.
   * 
   * @param newData new ResultSet data
   */
  public void setData(ArrayList newData)
  {
    this.data = newData;
    if (newData == null)
      this.nbOfRows = 0;
    else
      this.nbOfRows = newData.size();
  }

  /**
   * Set the hasMoreData boolean (is there more data to fetch from the
   * controller). This function is used by the ResultSet streaming feature.
   * 
   * @param hasMore new value for hasMoreData
   */
  public void setHasMoreData(boolean hasMore)
  {
    hasMoreData = hasMore;
  }

  /**
   * The numbers, types and properties of a <code>ResultSet</code>'s columns
   * are provided by the <code>getMetaData</code> method
   * 
   * @return a description of the <code>ResultSet</code>'s columns
   * @exception SQLException if a database access error occurs
   */
  public java.sql.ResultSetMetaData getMetaData() throws SQLException
  {
    return new ResultSetMetaData(this);
  }

  /**
   * Map a <code>ResultSet</code> column name to a <code>ResultSet</code>
   * column index
   * 
   * @param columnName the name of the column
   * @return the column index
   * @exception SQLException if a database access error occurs
   */
  public int findColumn(String columnName) throws SQLException
  {
    if (columnNameToIndex == null)
      buildIndexMapping();

    Integer index = (Integer) columnNameToIndex.get(columnName);

    if (index == null)
      index = (Integer) fullColumnNameToIndex.get(columnName);

    if (index != null)
      return index.intValue() + 1;
    else
    {
      // Try this inefficient way, now
      String columnNameUC = columnName.toUpperCase();
      for (int i = 0; i < nbOfColumns; i++)
      {
        if (fields[i].getFieldName().toUpperCase().equals(columnNameUC))
          return i + 1;
        else if (fields[i].getFullName().toUpperCase().equals(columnNameUC))
          return i + 1;
      }
      throw new java.sql.SQLException("Column '" + columnName + "' not found.");
    }
  }

  // ****************************************************************
  //
  // END OF PUBLIC INTERFACE
  //
  // ****************************************************************

  /**
   * Initialize serializers based on the analysis of actual Java Objects of the
   * ResultSet to send (typically issued by backend's driver readObject()
   * method).
   */
  private void initSerializers() throws NotSerializableException
  {
    /* we don't expect the column types of "this" result set to change */
    if (this.serializers != null)
      return;

    this.serializers = new SQLDataSerialization.Serializer[nbOfColumns];

    for (int col = 0; col < nbOfColumns; col++)
    {
      int rowIdx = -1;
      while (serializers[col] == null)
      {
        rowIdx++;

        // We browsed the whole column and found nothing but NULLs
        if (rowIdx >= nbOfRows) // ? || rowIdx > 100)
          break;

        Object[] row = (Object[]) data.get(rowIdx);
        Object sqlObj = row[col];

        /*
         * If SQL was NULL, we only have a null reference and can't do much with
         * it. Move down to next row
         */
        if (sqlObj == null)
          continue;

        try
        {
          serializers[col] = SQLDataSerialization.getSerializer(sqlObj);
        }
        catch (NotImplementedException nie)
        {
          if (sqlObj instanceof Short)
          {
            /**
             * This is a workaround for a bug in (at least) PostgreSQL's driver.
             * This bug has been only very recently fixed: 8 jun 2005 in version
             * 1.75 of source file
             * pgjdbc/org/postgresql/jdbc2/AbstractJdbc2ResultSet.java
             * http://jdbc.postgresql.org/development/cvs.html.
             * <p>
             * It seems this java.lang.Short bug happens with multiple DBMS:
             * http://archives.postgresql.org/pgsql-jdbc/2005-07/threads.php#00382
             */

            // Unfortunately we have not access to any logger at this point.
            // TODO: append the following SQLwarning() to this resultset
            // "Buggy backend driver returns a java.lang.Short"
            // + " for column number " + col + ", converting to Integer"
              
            try
            {
              serializers[col] = SQLDataSerialization
                  .getSerializer(TypeTag.INTEGER);
            }
            catch (NotImplementedException e)
            {
              throw new IllegalArgumentException("Internal bug");
            }
          }
          else
          {
            NotSerializableException nse = new NotSerializableException(
                "Backend driver gave an object of an unsupported java type:"
                    + sqlObj.getClass().getName() + ", at colum number " + col
                    + " of name " + fields[col].getFieldName());
            nse.initCause(nie);
            throw nse;
          }
        }

      } // while (row)

      if (serializers[col] == null) // we found nothing
      {
        // TODO: add the following SQLWarning() to this resultset
        // "The whole column number " + col + " was null"

        /**
         * The whole column is null. Fall back on the JDBC type provided by
         * backend's metaData.getColumnType(), hoping it's right. Since we are
         * sending just nulls, a wrong typing should not do much harm anyway ?
         * 
         * @see org.objectweb.cjdbc.controller.virtualdatabase.ControllerResultSet#ControllerResultSet(AbstractRequest,
         *      java.sql.ResultSet, MetadataCache, Statement)
         */
        /**
         * We could (should ?) also use {@link Field#getColumnClassName()}, and
         * do some reflection instead. This is depending on the behaviour and
         * quality of the JDBC driver of the backends we want to support.
         */

        TypeTag javaObjectType = TypeTag.jdbcToJavaObjectType(fields[col]
            .getSqlType());

        if (javaObjectType != TypeTag.TYPE_ERROR)
          try
          {
            serializers[col] = SQLDataSerialization
                .getSerializer(javaObjectType);
          }
          catch (NotImplementedException nie)
          {
            // since we passed a TypeTag it's really impossible to come here
            IllegalArgumentException ipe = new IllegalArgumentException(
                "Really incredible bug, TypeTag was: " + javaObjectType);
            ipe.initCause(nie);
            throw ipe;
          }
        else
        { // javaObjectType == TypeTag.TYPE_ERROR
          throw new NotSerializableException(
              "Could not guess type of column number " + col
                  + "whole column is null and backend does not provide "
                  + "a known JDBC type");
        }
      }

    } // for (column)

  }

  /**
   * Creates a new <code>DriverResultSet</code> from a non-null ArrayList of
   * rows. Allowed only on the controller side. We could use a resultset factory
   * instead in order to be more cleanly isolated from the controller.
   * 
   * @param fields an array of <code>Field</code> objects (basically, the
   *          <code>ResultSet</code> meta data)
   * @param resultData ArrayList of Object[] rows.
   * @throws IllegalArgumentException if resultData argument is null
   */
  public DriverResultSet(Field[] fields, ArrayList resultData)
      throws IllegalArgumentException
  {
    if (resultData == null)
      throw new IllegalArgumentException(
          "Cannot build a DriverResultSet with null data ArrayList");

    this.data = resultData;
    currentRow = -1;
    this.fields = fields;

    nbOfRows = resultData.size();
    nbOfColumns = fields.length;
    isClosed = false;
    // this constructor is allowed only on the controller side.
    this.connection = null;
  }

  /**
   * Creates a new <code>DriverResultSet</code> object from information we get
   * back from a ControllerResultSet. Allowed only on the controller side.
   * 
   * @param fields an array of <code>Field</code> objects (basically, the
   *          <code>ResultSet</code> meta data)
   * @param resultData ArrayList of the actual data. Cannot be null.
   * @param crsHasMoreData true if remote ControllerResultSet has more data to
   *          fetch
   * @param cursorName cursor name for a streamable ResultSet
   * @throws IllegalArgumentException if resultData argument is null
   */
  public DriverResultSet(Field[] fields, ArrayList resultData,
      boolean crsHasMoreData, String cursorName)
      throws IllegalArgumentException
  {
    this(fields, resultData);
    this.cursorName = cursorName;
    hasMoreData = crsHasMoreData;
  }

  /**
   * Creates a new <code>DriverResultSet</code> object, deserializing it from
   * an input stream. Has to mirror the serialization method below.
   * 
   * @param conn the connection we read from and belong to
   * @throws IOException if a network problem occurs
   * @throws ProtocolException if a protocol error occurs
   */

  public DriverResultSet(Connection conn) throws IOException, ProtocolException
  {
    this.connection = conn;
    CJDBCInputStream input = this.connection.socketInput;
    // Get the ResultSet metadata, deserialize columns information
    this.nbOfColumns = input.readInt();
    this.fields = new Field[nbOfColumns];
    for (int f = 0; f < this.nbOfColumns; f++)
      this.fields[f] = new Field(input);

    if (!TypeTag.COL_TYPES.equals(new TypeTag(input)))
      throw new ProtocolException("Column types were expected");

    this.nbOfRows = input.readInt();

    // Receive java types
    if (this.nbOfRows > 0)
    {
      this.serializers = new SQLDataSerialization.Serializer[nbOfColumns];
      for (int col = 0; col < this.nbOfColumns; col++)
      {
        TypeTag tag = new TypeTag(input);
        try
        {
          serializers[col] = SQLDataSerialization.getSerializer(tag);
        }
        catch (NotImplementedException nie)
        {
          // since we passed a TypeTag it's really impossible to come here
          IllegalArgumentException ipe = new IllegalArgumentException(
              "Really incredible bug, TypeTag was: " + tag);
          ipe.initCause(nie);
          throw ipe;
        }
        catch (IllegalArgumentException iae)
        {
          ProtocolException pe = new ProtocolException(
              "Protocol corruption: received unknown TypeTag " + tag
                  + " for column " + col);
          pe.initCause(iae);
          throw pe;
        }
      }
    }

    receiveRows(input);

    if (this.hasMoreData)
      this.cursorName = input.readUTF();

    this.isClosed = false;

  }

  /**
   * Serialize the <code>DriverResultSet</code> on the output stream by
   * sending only the needed parameters to reconstruct it on the driver. Has to
   * mirror the deserialization method above.
   * 
   * @param output destination stream
   * @throws IOException if a network error occurs
   */

  public void sendToStream(
      org.objectweb.cjdbc.common.stream.CJDBCOutputStream output)
      throws IOException
  {
    // serialize columns information
    output.writeInt(this.nbOfColumns);
    for (int f = 0; f < this.nbOfColumns; f++)
      this.fields[f].sendToStream(output);

    TypeTag.COL_TYPES.sendToStream(output);
    output.writeInt(this.nbOfRows);

    // Send Java columns type. We need to do it only once: not for every row!
    if (this.nbOfRows > 0)
    {
      initSerializers();

      for (int col = 0; col < this.nbOfColumns; col++)
        serializers[col].getTypeTag().sendToStream(output);
    }

    // Finally send the actual data
    sendRowsToStream(output);

    if (this.hasMoreData)
    { // Send the cursor name for further references
      output.writeUTF(this.cursorName);
    }
    output.flush();
  }

  /**
   * De-serialize only data rows, not any metadata. Useful for streaming.
   * 
   * @param input the stream to read from
   * @throws IOException stream error
   * @throws ProtocolException protocol corruption
   */

  void receiveRows(CJDBCInputStream input) throws IOException,
      ProtocolException
  {

    this.nbOfRows = input.readInt();

    boolean[] nulls = new boolean[this.nbOfColumns];

    // Receive the actual data
    this.data = new ArrayList(this.nbOfRows);

    for (int r = 0; r < this.nbOfRows; r++)
    {
      if (!TypeTag.ROW.equals(new TypeTag(input)))
        throw new ProtocolException("A row was expected");

      // First let's flag null values using a burst of booleans
      // TODO: we should compress this
      for (int col = 0; col < nbOfColumns; col++)
        nulls[col] = input.readBoolean();

      Object[] row = new Object[this.nbOfColumns];

      /**
       * Here we are sure that serializers are initialized because
       * 
       * @see #sendRowsToStream(CJDBCOutputStream) just below.
       */
      for (int col = 0; col < this.nbOfColumns; col++)
        if (nulls[col])
          row[col] = null;
        else
          row[col] = serializers[col].receiveFromStream(input);

      this.data.add(row);
    }

    this.hasMoreData = input.readBoolean();
  }

  /**
   * Serialize only rows, not any metadata. Useful for streaming. Called by the
   * controller side.
   * 
   * @param output destination stream
   * @throws IOException on stream error
   */
  public void sendRowsToStream(CJDBCOutputStream output) throws IOException
  {

    output.writeInt(this.nbOfRows);

    boolean[] nulls = new boolean[nbOfColumns];

    Iterator rowsIter = this.data.iterator();
    while (rowsIter.hasNext())
    {
      Object[] row = (Object[]) rowsIter.next();
      TypeTag.ROW.sendToStream(output);

      // first flag null values
      for (int col = 0; col < row.length; col++)
      {
        if (null == row[col])
          nulls[col] = true;
        else
          nulls[col] = false;
        // we should compress this
        output.writeBoolean(nulls[col]);
      }

      for (int col = 0; col < row.length; col++)
        if (!nulls[col]) // send only non-nulls
        {
          try
          {
            /**
             * Here we are sure that serializers are initialized because:
             * <p>
             * (1) we went through
             * {@link #sendToStream(CJDBCOutputStream)} at least once before
             * <p>
             * (2) and there was a non-zero ResultSet transfered, else we would
             * not come here again.
             */
            serializers[col].sendToStream(row[col], output);
          }
          catch (ClassCastException cce1)
          {
            ClassCastException cce2 = new ClassCastException("Serializer "
                + serializers[col] + " failed on Java object: " + row[col]
                + " found in column: " + col + ", because of unexpected type "
                + row[col].getClass().getName());
            cce2.initCause(cce1);
            throw cce2;
          }
        } // if !null

    } // while (rows)

    output.writeBoolean(this.hasMoreData);
    output.flush();
  }

  /**
   * Set the statement.
   * 
   * @param stmt The statement to set
   * @throws SQLException if an error occurs
   */
  protected void setStatement(Statement stmt) throws SQLException
  {
    owningStatement = stmt;
    fetchSize = stmt.getFetchSize();
    resultSetConcurrency = stmt.getResultSetConcurrency();
    resultSetType = stmt.getResultSetType();
  }

  /**
   * Builds a hash between column names and their indices for fast retrieval.
   */
  private void buildIndexMapping()
  {
    int numFields = nbOfColumns;

    columnNameToIndex = new Hashtable();
    fullColumnNameToIndex = new Hashtable();

    for (int i = 0; i < numFields; i++)
    {
      Integer index = new Integer(i);

      String columnName = fields[i].getFieldName();
      String fullColumnName = fields[i].getFullName();
      if (columnName != null)
      {
        columnNameToIndex.put(fields[i].getFieldName(), index);
        columnNameToIndex.put(fields[i].getFieldName().toUpperCase(), index);
        columnNameToIndex.put(fields[i].getFieldName().toLowerCase(), index);
      }

      if (fullColumnName != null)
      {
        fullColumnNameToIndex.put(fields[i].getFullName(), index);
        fullColumnNameToIndex.put(fields[i].getFullName().toUpperCase(), index);
        fullColumnNameToIndex.put(fields[i].getFullName().toLowerCase(), index);
      }
    }
  }

  /**
   * Builds a delete statement for deleting rows with Updatable ResultSets
   * 
   * @throws SQLException
   */
  private void buildDeleteStatement() throws SQLException
  {
    // Check that ResultSet can be updated
    this.checkUpdatability();

    // Build delete statement for this ResultSet
    StringBuffer sb = new StringBuffer();
    sb.append("DELETE FROM ");
    sb.append(fields[0].getTableName());
    sb.append(" WHERE ");
    for (int i = 0; i < primaryKeyColumns.length; ++i)
    {
      if (i > 0)
        sb.append(" AND ");
      sb.append(primaryKeyColumns[i]);
      sb.append(" = ?");
    }

    // set delete statement
    deleteStatement = this.connection.prepareStatement(sb.toString());
  }

  /**
   * Builds a insert statement for inserting rows with Updatable ResultSets
   * 
   * @throws SQLException
   */
  private void buildInsertStatement() throws SQLException
  {
    // Check that ResultSet can be updated
    this.checkUpdatability();

    // Build insert statement for this ResultSet
    StringBuffer sb = new StringBuffer();
    sb.append("INSERT INTO ");
    sb.append(fields[0].getTableName());
    sb.append(" (");
    for (int i = 0; i < fields.length; ++i)
    {
      if (i > 0)
        sb.append(", ");
      sb.append(fields[i].getFieldName());
    }
    sb.append(") VALUES (");
    for (int i = 0; i < fields.length; ++i)
    {
      if (i > 0)
        sb.append(", ");
      sb.append("?");
    }
    sb.append(")");

    // set insert statement
    insertStatement = this.connection.prepareStatement(sb.toString());
  }

  /**
   * Builds a select statement for refreshing rows in Updatable ResultSets
   * 
   * @throws SQLException
   */
  private void buildRefreshStatement() throws SQLException
  {
    // Check that ResultSet can be updated
    this.checkUpdatability();

    // Build refresh statement for this ResultSet
    StringBuffer sb = new StringBuffer();
    sb.append("SELECT ");
    for (int i = 0; i < fields.length; ++i)
    {
      if (i > 0)
        sb.append(", ");
      sb.append(fields[i].getFieldName());
    }
    sb.append(" FROM ");
    sb.append(fields[0].getTableName());
    sb.append(" WHERE ");
    for (int i = 0; i < primaryKeyColumns.length; ++i)
    {
      if (i > 0)
        sb.append(" AND ");
      sb.append(primaryKeyColumns[i]);
      sb.append(" = ?");
    }

    // set refresh statement
    refreshStatement = this.connection.prepareStatement(sb.toString());
  }

  /**
   * Builds an update statement for updating rows with Updatable ResultSets
   * 
   * @throws SQLException
   */
  private void buildUpdateStatement() throws SQLException
  {
    // Check that ResultSet can be updated
    this.checkUpdatability();

    // Build update statement for this ResultSet
    StringBuffer sb = new StringBuffer();
    sb.append("UPDATE ");
    sb.append(fields[0].getTableName());
    sb.append(" SET ");
    for (int i = 0; i < fields.length; ++i)
    {
      if (i > 0)
        sb.append(", ");
      sb.append(fields[i].getFieldName());
      sb.append(" = ?");
    }
    sb.append(" WHERE ");
    for (int i = 0; i < primaryKeyColumns.length; ++i)
    {
      if (i > 0)
        sb.append(" AND ");
      sb.append(primaryKeyColumns[i]);
      sb.append(" = ?");
    }

    // set update statement
    updateStatement = this.connection.prepareStatement(sb.toString());
  }

  /**
   * Retrieves the primary key for the table referenced by this ResultSet
   * 
   * @throws SQLException
   */
  private void extractPrimaryKey() throws SQLException
  {
    ResultSet res = this.connection.getPrimaryKeys(null, null, fields[0].getTableName());

    try
    {
      primaryKeyColumns = new String[((DriverResultSet) res).nbOfRows];
      while (res.next())
        primaryKeyColumns[res.getRow() - 1] = res.getString(4);
    }
    finally
    {
      // Clean up
      res.close();
    }
  }

  /**
   * Basic checks for Updatable ResultSets
   * 
   * @throws SQLException
   */
  private void checkUpdatability() throws SQLException
  {
    // Check ResultSet Concurrency type
    switch (resultSetConcurrency)
    {
      case ResultSet.CONCUR_READ_ONLY :
        throw new SQLException("Cannot update ResultSet with "
            + "concurrency mode CONCUR_READ_ONLY");
      case ResultSet.CONCUR_UPDATABLE :
        break;
      default :
        throw new SQLException("Invalid ResultSet concurrency mode: "
            + resultSetConcurrency);
    }

    // Check that the query selects only one table
    String tableName = fields[0].getTableName();
    for (int i = 1; i < nbOfColumns; ++i)
      if (!tableName.equals(fields[i].getTableName()))
        throw new SQLException(UPDATEABLE_MESSAGE);

    // Check if need to get primary keys
    if (primaryKeyColumns == null)
      this.extractPrimaryKey();

    // Check that the query selects the full primary key
    for (int i = 0; i < primaryKeyColumns.length; ++i)
      try
      {
        findColumn(primaryKeyColumns[i]);
      }
      catch (SQLException e)
      {
        throw new SQLException(UPDATEABLE_MESSAGE);
      }
  }

  /**
   * Sanity checks for result parsing
   * 
   * @param columnIndex the column to check
   * @throws SQLException if an error occurs
   */
  private void checkRowAndColPosAndSetNullFlag(int columnIndex)
      throws SQLException
  {
    checkIfClosed();

    if (!inserting)
      checkRowPos();

    if (fields == null)
      throw new java.sql.SQLException("Query generated no fields for ResultSet");

    if (columnIndex < 1 || columnIndex > nbOfColumns)
      throw new java.sql.SQLException("Column Index out of range ( "
          + columnIndex + " > " + nbOfColumns + ").");

    try
    {
      Object obj;
      if (inserting || updating)
        obj = tempRow[columnIndex - 1];
      else
        obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

      if (obj == null)
        wasNullFlag = true;
      else
        wasNullFlag = false;
    }
    catch (NullPointerException e)
    {
      wasNullFlag = true;
    }
  }

  /**
   * Checks that the cursor is on row in the ResultSet
   * 
   * @throws SQLException
   */
  private void checkRowPos() throws SQLException
  {
    if (currentRow < 0)
      throw new SQLException("Before start of result set");

    if (currentRow == nbOfRows)
      throw new SQLException("After end of result set");
  }

  /**
   * Checks that the update flag is set when updating a row. The first time an
   * update is done on a row this method will prepare the ResultSet for update
   * 
   * @throws SQLException
   */
  private void checkUpdateFlagAndPrepareUpdateIfNeeded() throws SQLException
  {
    if (updating)
      return;

    this.checkRowPos();

    if (updateStatement == null)
      this.buildUpdateStatement();

    tempRow = (Object[]) ((Object[]) data.get(currentRow)).clone();

    for (int i = 0; i < nbOfColumns; ++i)
      updateStatement.setObject(i + 1, tempRow[i]);

    updating = true;
  }

  /**
   * Check if the ResultSet if closed and throws a SQLException if so.
   * 
   * @throws SQLException if the ResultSet is closed
   */
  private void checkIfClosed() throws SQLException
  {
    if (isClosed)
      throw new SQLException("Trying to access a closed ResultSet");
  }

  // -------------------------- JDBC 3.0
  // ----------------------------------------

  /**
   * Retrieves the value of the designated column in the current row of this
   * <code>ResultSet</code> object as a <code>java.net.URL</code> object in
   * the Java programming language.
   * 
   * @param columnIndex the index of the column 1 is the first, 2 is the
   *          second,...
   * @return the column value as a <code>java.net.URL</code> object; if the
   *         value is SQL <code>NULL</code>, the value returned is
   *         <code>null</code> in the Java programming language
   * @exception SQLException if a database access error occurs, or if a URL is
   *              malformed
   * @since JDK 1.4
   */
  public java.net.URL getURL(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return null;

    if (inserting || updating)
      return (URL) tempRow[columnIndex - 1];
    else
      return (URL) (((Object[]) data.get(currentRow))[columnIndex - 1]);
  }

  /**
   * Retrieves the value of the designated column in the current row of this
   * <code>ResultSet</code> object as a <code>java.net.URL</code> object in
   * the Java programming language.
   * 
   * @param columnName the SQL name of the column
   * @return the column value as a <code>java.net.URL</code> object; if the
   *         value is SQL <code>NULL</code>, the value returned is
   *         <code>null</code> in the Java programming language
   * @exception SQLException if a database access error occurs or if a URL is
   *              malformed
   * @since JDK 1.4
   */
  public java.net.URL getURL(String columnName) throws SQLException
  {
    return getURL(findColumn(columnName));
  }

  /**
   * Updates the designated column with a <code>java.sql.Ref</code> value. The
   * updater methods are used to update column values in the current row or the
   * insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateRef(int columnIndex, java.sql.Ref x) throws SQLException
  {
    throw new NotImplementedException("updateRef");
  }

  /**
   * Updates the designated column with a <code>java.sql.Ref</code> value. The
   * updater methods are used to update column values in the current row or the
   * insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateRef(String columnName, java.sql.Ref x) throws SQLException
  {
    updateRef(findColumn(columnName), x);
  }

  /**
   * Updates the designated column with a <code>java.sql.Blob</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateBlob(int columnIndex, java.sql.Blob x) throws SQLException
  {
    throw new NotImplementedException("updateBlob");
  }

  /**
   * Updates the designated column with a <code>java.sql.Blob</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateBlob(String columnName, java.sql.Blob x)
      throws SQLException
  {
    updateBlob(findColumn(columnName), x);
  }

  /**
   * Updates the designated column with a <code>java.sql.Clob</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateClob(int columnIndex, java.sql.Clob x) throws SQLException
  {
    throw new NotImplementedException("updateClob");
  }

  /**
   * Updates the designated column with a <code>java.sql.Clob</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateClob(String columnName, java.sql.Clob x)
      throws SQLException
  {
    updateClob(findColumn(columnName), x);
  }

  /**
   * Updates the designated column with a <code>java.sql.Array</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnIndex the first column is 1, the second is 2, ...
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateArray(int columnIndex, java.sql.Array x)
      throws SQLException
  {
    throw new NotImplementedException("updateArray");
  }

  /**
   * Updates the designated column with a <code>java.sql.Array</code> value.
   * The updater methods are used to update column values in the current row or
   * the insert row. The updater methods do not update the underlying database;
   * instead the <code>updateRow</code> or <code>insertRow</code> methods
   * are called to update the database.
   * 
   * @param columnName the name of the column
   * @param x the new column value
   * @exception SQLException if a database access error occurs
   * @since JDK 1.4
   */
  public void updateArray(String columnName, java.sql.Array x)
      throws SQLException
  {
    updateArray(findColumn(columnName), x);
  }

  /**
   * Get the value of a column in the current row as a Java byte.
   * 
   * @param columnIndex the first column is 1, the second is 2,...
   * @return the column value; 0 if SQL NULL
   * @exception SQLException if a database access error occurs
   */
  public byte getByte(int columnIndex) throws SQLException
  {
    checkRowAndColPosAndSetNullFlag(columnIndex);

    if (wasNullFlag)
      return 0;

    Object obj;
    if (inserting || updating)
      obj = tempRow[columnIndex - 1];
    else
      obj = ((Object[]) data.get(currentRow))[columnIndex - 1];

    if (obj instanceof Number)
    {
      return ((Number) obj).byteValue();
    }

    // the object is not of type number we parse the string representation
    try
    {
      String string = obj.toString();
      string = string.trim();
      return Byte.parseByte(string);
    }
    catch (NumberFormatException e)
    {
      throw new SQLException("the value " + obj.toString()
          + " is not a valid byte");
    }
  }

  /**
   * @see java.lang.Object#toString()
   */
  public String toString()
  {
    return nbOfRows + " rows - " + nbOfColumns + " columns - current row:"
        + currentRow + " - hasMoreData:" + hasMoreData + " - isClosed:"
        + isClosed;
  }

@Override
public boolean isWrapperFor(Class<?> iface) throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public <T> T unwrap(Class<T> iface) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public int getHoldability() throws SQLException {
	// TODO Auto-generated method stub
	return 0;
}

@Override
public Reader getNCharacterStream(int arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public Reader getNCharacterStream(String arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public NClob getNClob(int arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public NClob getNClob(String arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public String getNString(int arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public String getNString(String arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public RowId getRowId(int arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public RowId getRowId(String arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public SQLXML getSQLXML(int arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public SQLXML getSQLXML(String arg0) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public boolean isClosed() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public void updateAsciiStream(int arg0, InputStream arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateAsciiStream(String arg0, InputStream arg1)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateAsciiStream(int arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateAsciiStream(String arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBinaryStream(int arg0, InputStream arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBinaryStream(String arg0, InputStream arg1)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBinaryStream(int arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBinaryStream(String arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBlob(int arg0, InputStream arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBlob(String arg0, InputStream arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBlob(int arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateBlob(String arg0, InputStream arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateCharacterStream(int arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateCharacterStream(String arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateCharacterStream(int arg0, Reader arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateCharacterStream(String arg0, Reader arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateClob(int arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateClob(String arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateClob(int arg0, Reader arg1, long arg2) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateClob(String arg0, Reader arg1, long arg2) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNCharacterStream(int arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNCharacterStream(String arg0, Reader arg1)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNCharacterStream(int arg0, Reader arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNCharacterStream(String arg0, Reader arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(int arg0, NClob arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(String arg0, NClob arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(int arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(String arg0, Reader arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(int arg0, Reader arg1, long arg2) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNClob(String arg0, Reader arg1, long arg2)
		throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNString(int arg0, String arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateNString(String arg0, String arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateRowId(int arg0, RowId arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateRowId(String arg0, RowId arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateSQLXML(int arg0, SQLXML arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public void updateSQLXML(String arg0, SQLXML arg1) throws SQLException {
	// TODO Auto-generated method stub
	
}
}