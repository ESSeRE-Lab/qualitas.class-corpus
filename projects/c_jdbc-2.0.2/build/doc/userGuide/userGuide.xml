<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>


<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN" "http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">

<!--
<!DOCTYPE article SYSTEM "../../../xml/docbook/dtd/simple/1.0/sdocbook.dtd">
-->

<article class="whitepaper">
  <articleinfo>
    <authorgroup>
      <author>
        <firstname>Emmanuel</firstname>
        <surname>Cecchet</surname>
      </author>
      <author>
        <firstname>Julie</firstname>
        <surname>Marguerite</surname>
      </author>
      <author>
        <firstname>Mathieu</firstname>
        <surname>Peltier</surname>
      </author>
      <author>
        <firstname>Nicolas</firstname>
        <surname>Modrzyk</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>	  
      <holder>French National Institute For Research In Computer Science And 
        Control (INRIA)</holder>
      <holder>Emic Networks</holder>
    </copyright>
    <releaseinfo>Version 2.0.2</releaseinfo>
    <title>C-JDBC User's Guide</title>
    <legalnotice>
      <para>Java, and all Java-based trademarks are trademarks or registered 
        trademarks of Sun Microsystems, Inc. in the United States and other 
        countries.</para>
    </legalnotice>
  </articleinfo>
  <!-- =============================================================== -->
  <!-- Section: Getting Started -->
  <!-- =============================================================== -->
  <section id="getting_started">
    <title>Getting Started</title>
    <!-- ========== What is C-JDBC? ========== -->
    <section id="what_is_cjdbc">
      <title>What is C-JDBC?</title>
      <para>C-JDBC is a database cluster middleware that allows any <trademark 
        class="trade">Java</trademark> application (standalone application, 
        servlet or <trademark class="trade">EJB</trademark> container, ...) to 
        transparently access a cluster of databases through <trademark 
        class="trade">JDBC</trademark>. You do not have to modify client 
        applications, application servers or database server software. You just 
        have to ensure that all database accesses are performed through 
        C-JDBC.</para>
      <para>C-JDBC is a <emphasis>free</emphasis>, <emphasis>open 
        source</emphasis> project of the <ulink 
        url="http://www.objectweb.org/">ObjectWeb Consortium</ulink>. It is 
        licensed under the <ulink 
        url="http://www.gnu.org/copyleft/lesser.html">GNU Lesser General Public 
        License</ulink> (LGPL).</para>
    </section>
    <!-- ========== What do I need to use C-JDBC? ========== -->
    <section id="what_do_i_need_to_use_cjdbc">
      <title>What do I need to use C-JDBC?</title>
      <para>In order to use C-JDBC, you will need:</para>
      <itemizedlist>
        <listitem>
          <para>a client application that accesses a database through 
            JDBC,</para>
        </listitem>
        <listitem>
          <para>a <trademark class="trade">JDK</trademark> 1.3 (or greater) 
            compliant <trademark class="trade">Java Virtual Machine</trademark> 
            (JVM)<footnote><para>C-JDBC may work with older JVM version, but 
            hasn't been tested.</para></footnote>,</para>
        </listitem>
        <listitem>
          <para>a database with a JDBC driver (type 1, 2, 3 or 4) or an ODBC 
            driver used with the JDBC-ODBC bridge.</para>
        </listitem>
        <listitem>
          <para>a network supporting TCP/IP communications between your cluster 
            nodes.</para>
        </listitem>
      </itemizedlist>
      <note>
        <para>If your client application uses ODBC, it is possible to use an 
          ODBC-JDBC bridge such as the <ulink 
          url="http://www.unixodbc.org/">unixODBC</ulink> provided by 
          Easysoft.</para>
      </note>
    </section>
    <!-- ========== Why should I use C-JDBC? ========== -->
    <section id="why_should_i_use_cjdbc">
      <title>Why should I use C-JDBC?</title>
      <para>You have a Java application or a Java-based application server that 
        accesses one or several databases. The database tier becomes the 
        bottleneck of your application or it is a single point of failure or 
        both. C-JDBC can help you resolve these problems by providing:</para>
      <itemizedlist>
        <listitem>
          <para>performance scalability by adding database nodes and balacing 
            the load among these nodes.</para>
        </listitem>
        <listitem>
          <para>high availability of the database tier, i.e. C-JDBC tolerates 
            database crashes and offers transparent failover using database 
            replication techniques.</para>
        </listitem>
        <listitem>
          <para>improved performance with fine grain query caching and 
            transparent connection pooling.</para>
        </listitem>
        <listitem>
          <para>SQL traffic logging for performance monitoring and 
            analysis.</para>
        </listitem>
        <listitem>
          <para>support for clusters of heterogenous database engines.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== How does it work? ========== -->
    <section id="how_does_it_works">
      <title>How does it work?</title>
      <para>C-JDBC provides a flexible architecture that allows you to achieve 
        scalability, high availability and failover with your database tier. 
        C-JDBC implements the concept of RAIDb: <emphasis>Redundant Array of 
        Inexpensive Databases</emphasis> (see <xref linkend="raidb_basics"/>). 
        The database is distributed and replicated among several nodes and 
        C-JDBC load balances the queries between these nodes.</para>
      <para>C-JDBC provides a generic JDBC driver to be used by the clients 
        (see <xref linkend="c_jdbc_driver"/>). This driver forwards the SQL 
        requests to the C-JDBC controller (see <xref 
        linkend="c_jdbc_controller"/>) that balances them on a cluster of 
        databases (reads are load balanced and writes are broadcasted). C-JDBC 
        can be used with any RDBMS (Relational DataBase Management System) 
        providing a JDBC driver, that is to say almost all existing open source 
        and commercial databases. <xref linkend="fig_c-jdbc_principle"/> gives 
        an overview of the C-JDBC principle.</para>
      <figure id="fig_c-jdbc_principle">
        <title>C-JDBC principle</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/c-jdbc_principle.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/c-jdbc_principle.gif" align="center" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>C-JDBC allows to build any cluster configuration including mixing 
        database engines from different vendors. The main features provided by 
        C-JDBC are performance scalability, fault tolerance and high 
        availability. Additional features such as monitoring, logging, SQL 
        requests caching are provided as well.</para>
      <para>The architecture is widely open to allow anyone to plug custom 
        requests schedulers, load balancers, connection managers, caching 
        policies, ...</para>
    </section>
    <!-- ========== What does it cost? ========== -->
    <section id="what_does_it_cost">
      <title>What does it cost?</title>
      <para>From a software point of view, C-JDBC is an open-source software 
        licensed under LGPL which means that it is free of charge for any usage 
        (personal or commercial). If you are using commercial RDBMS (such as 
        Oracle, DB2, ...), you will have to buy extra licenses for the nodes 
        where you install replicas of the database. But you can possibly use 
        open-source databases to host replicas of your main database.</para>
      <para>You need to buy extra machines if you want more performance and 
        more fault tolerance. C-JDBC has been designed to work with standard 
        off-the-shelf workstations because it primarily targets low cost 
        open-source solutions but it can work as well with large SMP machines. 
        A standard Ethernet network is sufficient to achieve good 
        performance.</para>
    </section>
    <!-- ========== What kind of modifications are needed? ========== -->
    <section id="what_modifications_are_needed">
      <title>What kind of modifications are needed?</title>
      <para>You <emphasis>do not have to change anything</emphasis> to your 
        application or your database.</para>
      <para>You only have to update the JDBC driver configuration used by your 
        application (usually it is just a configuration file update) and to 
        setup a C-JDBC configuration file (see <xref 
        linkend="configuration"/>).</para>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Getting the Software -->
  <!-- =============================================================== -->
  <section id="getting_the_software">
    <title>Getting the Sofware</title>
    <para>The binary distribution of C-JDBC can be downloaded from <ulink 
      url="http://c-jdbc.objectweb.org/">C-JDBC's Web site</ulink>. It mainly 
      contains the JAR files for the C-JDBC driver and controller and also the 
      documentation and other tools such as the C-JDBC administration 
      console.</para>
    <note>
      <para>A source distribution of C-JDBC is also available. The whole code 
        base can also be downloaded through an anonymous CVS 
        server<footnote><para>CVS stands for <emphasis>Concurrent Versions 
        System</emphasis> and is a popular version control 
        system.</para></footnote>. For more information, please refer to C-JDBC 
        Developper's Guide. Most users will only need the binary 
        distribution.</para>
    </note>
    <para>The following formats are available (where 
      <literal>x.y</literal> is the C-JDBC release number):</para>
    <itemizedlist>
      <listitem>
        <para><filename 
          class="libraryfile">c-jdbc-x.y-bin-installer.jar</filename>: Java 
          graphical installer (powered by <ulink 
          url="http://www.izforge.com/izpack/">IzPack</ulink>).</para>
      </listitem>
      <listitem>
        <para><filename class="libraryfile">c-jdbc-x.y-bin.tar.gz</filename>: 
          binary distribution for the Unix platforms users.</para>
      </listitem>
      <listitem>
        <para><filename class="libraryfile">c-jdbc-x.y-bin.zip</filename>: 
          binary distribution for the Windows platforms users.</para>
      </listitem>
      <listitem>
        <para><literal>rpm</literal> packages are also available from <ulink 
          url="http://www.jpackage.org/">JPackage</ulink>.</para>
      </listitem>
    </itemizedlist>
    <para>We strongly advice to use the Java installer package since it 
      automatically configures the scripts to suit your system 
      configuration.</para>
    <note>
      <para>All distributions contain the user documentation.</para>
    </note>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Installation -->
  <!-- =============================================================== -->
  <section id="installation">
    <title>Installation</title>
    <!-- ========== C-JDBC Controller ========== -->
    <section id="cjdbc_controller">
      <title>C-JDBC Controller</title>
      <section id="using_java_graphical_installer">
        <title>Using the Java graphical installer</title>
        <para>The easiest way to install C-JDBC is to use the Java graphical 
          installer. A Java Virtual Machine is of course needed in this 
          case.</para>
        <itemizedlist>
          <listitem>
            <para>Unix users can simply launch the installation program by 
              typing:</para>
            <programlisting> 
              bash> java -jar c-jdbc-x.y.bin-installer.jar 
            </programlisting>
          </listitem>
          <listitem>
            <para>Windows users can use the same command or just double-clik on 
              the JAR installation file if your JRE has been properly 
              installed.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="using_binary_distribution">
        <title>Using the binary distribution</title>
        <para>If you want to use the other distribution formats (for example if 
          you have not installed a JVM or if you can not launch a graphical 
          application), you have to uncompress the downloaded file in the 
          directory of your choice, and then set the 
          <literal>CJDBC_HOME</literal> environment variable.</para>
        <note>
          <para>If you are using the Java installer, you do not need to set any 
            environment variable since the installer customizes the scripts 
            with the installation path.</para>
        </note>
        <para>To set the <literal>CJDBC_HOME</literal> environment variable, 
          you can proceed as follows:</para>
        <itemizedlist>
          <listitem>
            <para>Unix users can proceed as follows:</para>
            <programlisting> 
bash> mkdir -p /usr/local/c-jdbc
bash> cd /usr/local/c-jdbc
bash> tar xfz /path-to-c-jdbc-bin-dist/c-jdbc-x.y-bin.tar.gz
bash> export CJDBC_HOME=/usr/local/c-jdbc
            </programlisting>
            <note>
              <para>In this example, we assume you install C-JDBC in the 
                <filename class="directory">/usr/local/c-jdbc</filename> 
                directory.</para>
            </note>
            <para>You can modify your shell configuration file 
              (<filename>.bashrc</filename>, <filename>.cshrc</filename>, ...) 
              to set the environment variable permanently.</para>
          </listitem>
          <listitem>
            <para>Windows users have to use an utility such as <ulink 
              url="http://www.winzip.com/">WinZip</ulink> to extract the files 
              from the archive. Then, to set the <literal>CJDB_HOME</literal> 
              variable, do the following according to your Windows 
              version:</para>
            <itemizedlist>
              <listitem>
                <para><emphasis>Windows 95 or 98</emphasis>: you must insert 
                  the following line in the <filename>AUTOEXEC.BAT</filename> 
                  file:</para>
                <programlisting>set CJDBC_HOME="C:\Program Files\C-JDBC"</programlisting>
              </listitem>
              <listitem>
                <para><emphasis>Windows Me</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Programs</quote>, 
                  <quote>Accessories</quote>, <quote>System Tools</quote> and 
                  <quote>System Information</quote>. A window titled 
                  <quote>Microsoft Help and Support</quote> should appear. 
                  Select the <quote>Tools</quote> menu, and choose the 
                  <quote>System Configuration Utility</quote>. Go to the 
                  <quote>Environment</quote> and click on the 
                  <quote>New</quote> button. Enter 
                  <literal>CJDBC_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\C-JDBC"</filename> in 
                  <quote>Variable Value</quote>. Once you have changed and 
                  saved the value, you will be prompted for reboot.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows NT</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Settings</quote>, 
                  <quote>Control Panel</quote> and select 
                  <quote>System</quote>. Select the <quote>Environment</quote> 
                  tab and click on the <quote>New</quote> button. Enter 
                  <literal>CJDBC_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\C-JDBC"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows 2000</emphasis>: go to the <quote>Start 
                  Menu</quote>, then choose <quote>Settings</quote>, 
                  <quote>Control Panel</quote> and select 
                  <quote>System</quote>. Select the <quote>Advanced</quote> tab 
                  and click on the <quote>New</quote> button. Enter 
                  <literal>CJDBC_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\C-JDBC"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
              <listitem>
                <para><emphasis>Windows XP</emphasis>: go to the <quote>Start 
                  Menu</quote>, then double click on <quote>System</quote>. In 
                  the <quote>System Control Panel</quote> select the 
                  <quote>Advanced</quote> tab and push the <literal>Environment 
                  Variables</literal> button. Click on the <quote>New</quote> 
                  button for <quote>System Variables</quote>. Enter 
                  <literal>CJDBC_HOME</literal> in the <quote>Variable 
                  Name</quote> field and <filename 
                  class="directory">"C:\Program Files\C-JDBC"</filename> in 
                  <quote>Variable Value</quote>.</para>
              </listitem>
            </itemizedlist>
            <note>
              <para>In this example, we assume you install C-JDBC in the 
                <filename class="directory">C:\Program Files\C-JDBC</filename> 
                directory.</para>
            </note>
            <note>
              <para>Do not forget the quotes in the CJDBC_HOME environment 
                variable definition else the starting scripts will fail with 
                paths including spaces.</para>
            </note>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <!-- ========== C-JDBC driver ========== -->
    <section id="cjdbc_driver">
      <title>C-JDBC Driver</title>
      <para>Once you have installed the C-JDBC controller, you will find the 
        driver JAR file in the <filename class="directory">drivers/</filename> 
        directory of the controller installation location.</para>
      <para>To install the C-JDBC driver, you just have to add the <filename 
        class="libraryfile">c-jdbc-driver.jar</filename> file to the client 
        application classpath. This driver replaces the database native driver 
        in the client application. The database native driver will be used by 
        the C-JDBC controller to access your database. Therefore, the C-JDBC 
        driver and controller can be seen as a proxy between your application 
        and your database native driver.</para>
    </section>
    <!-- ========== C-JDBC examples: RAIDb-1 out of the box ========== -->
    <section id="raidb1_out_of_the_box">
      <!-- TODO: Remove this section and make a tutorial out of it -->
      <title>C-JDBC out of the box</title>
      <para>Since version 1.0b13, you have access to a RAIDb-1 configuration of 
        HyperSonic SQL databases, just by launching the 
        <command>demo-raidb1.sh</command> or <command>demo-raidb1.bat</command> 
        file from the <filename class="directory">demo</filename> directory in 
        your C-JDBC installation.</para>
      <para>This is especially useful if you are new to clustering, or new to 
        C-JDBC. The setup used is as follows: </para>
      <itemizedlist>
        <listitem>
          <para>2 HyperSonic SQL databases are started on two different ports 
            (9001 and 9002)</para>
        </listitem>
        <listitem>
          <para>An extra HyperSonic SQL database is started on port 9003 to be 
            used as the recovery log database</para>
        </listitem>
        <listitem>
          <para>The C-JDBC controller is configured to load automatically a 
            virtual database containing those two HyperSonic SQL backends. The 
            controller startup configuration file is found in 
            <filename>CJDBC_HOME/config/controller/controller-raidb1.xml</filename> 
            and the virtual database configuration file is 
            <filename>CJDBC_HOME/config/virtualdatabase/hsqldb-raidb1.xml</filename>.</para>
        </listitem>
        <listitem>
          <para>Once the RAIDb-1 configuration is loaded, you can connect to 
            C-JDBC using Squirrel, a graphical SQL console bundled with C-JDBC. 
            You can start Squirrel by using <command>squirrel.sh</command> 
            or <command>squirrel.bat</command>.</para>
        </listitem>
      </itemizedlist>
      <para>Squirrel shows the C-JDBC driver and HSQL database driver, and 
        links to databases. You can click on them to view the different data. 
        The login to use for C-JDBC is <literal>user</literal> with an empty 
        password. The login for both HSQL databases is <literal>test</literal> 
        with an empty password.</para>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: C-JDBC Driver -->
  <!-- =============================================================== -->
  <section id="c_jdbc_driver">
    <title>C-JDBC Driver</title>
    <!-- ========== Overview ========== -->
    <section id="driver_overview">
      <title>Overview</title>
      <para>The C-JDBC driver is a generic JDBC driver that is designed to 
        replace any database specific JDBC driver that could be used by a 
        client. The client only has to know on which node the C-JDBC controller 
        is running and the name of the database to access. The C-JDBC driver 
        implements most of the JDBC 2.0 interface and some functionalities from 
        JDBC 3.0 such as the support for autogenerated keys.</para>
      <para>Users reported successful usage of C-JDBC with the following RDBMS: 
        <trademark class="registered">Oracle</trademark>, PostgreSQL, MySQL, 
        Apache Derby, <trademark class="registered">IBM DB2</trademark>, 
        <trademark class="registered">Sybase</trademark>, SAP DB (MySQL MaxDB), 
        HyperSonic SQL, Firebird, MS SQL Server and InstantDB.</para>
    </section>
    <!-- ========== Loading the Driver ========== -->
    <section id="loading_the_driver">
      <title>Loading the Driver</title>
      <para>The C-JDBC driver can be loaded as any standard JDBC driver from 
        the client program using:</para>
      <programlisting> 
        Class.forName("org.objectweb.cjdbc.driver.Driver"); 
      </programlisting>
      <note>
        <para>The <filename class="libraryfile">c-jdbc-driver.jar</filename> 
          file must be in the client classpath else the driver will fail to 
          load.</para>
      </note>
    </section>
    <!-- ========== C-JDBC JDBC URL ========== -->
    <section id="cjdbc_jdbc_url">
      <title>C-JDBC JDBC URL</title>
      <para>The JDBC URL expected for the use with C-JDBC is the following: 
        <literal>jdbc:cjdbc://host1:port1,host2:port2/database</literal>.</para>
      <para><literal>host</literal> is the machine name (or IP address) where 
        the C-JDBC controller is running, <literal>port</literal> is the port 
        the controller is listening for client connections.</para>
      <para>At least one host must be specified but a list of comma separated 
        hosts can be specified. If several hosts are given, one is picked up 
        randomly from the list. If the currently selected controller fails, 
        another one is automatically picked up from the list.</para>
      <para>The port is optional is the URL and the default port number is 
        25322 (C-JDBC on the phone!) if it is omitted. Those two examples are 
        equivalent:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:cjdbc://localhost/tpcw"); 
        DriverManager.getConnection("jdbc:cjdbc://localhost:25322/tpcw"); 
        </programlisting>
      <para>Examples using two controllers for fault tolerance:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:cjdbc://c1.objectweb.org,c2.objectweb.org/tpcw"); 
        DriverManager.getConnection("jdbc:cjdbc://localhost,remote.objectweb.org:2048/tpcw"); 
        DriverManager.getConnection("jdbc:cjdbc://smpnode.com:25322,smpnode.com:1098/tpcw"); 
        </programlisting>
        
    <section id="url_options">
      <title>URL options</title>
      <para>The C-JDBC driver accepts additional options to override the 
        default behavior of the driver. The options are appended at the end of 
        the C-JDBC URL after a question mark followed by a list of ampersands 
        separated options. Here is an example:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:cjdbc://host/db?user=me&amp;password=secret")</programlisting>
      <para>Another option is to use semicolons to delimit the start of options 
        and options themselves. Example:</para>
      <programlisting> 
        DriverManager.getConnection("jdbc:cjdbc://host/db;user=me;password=secret")</programlisting>
      <para>The recognized options are:</para>
      <itemizedlist>
        <listitem>
          <para><literal>booleanTrue</literal>: String value to use in 
            PreparedStatement.setBoolean(true), default is '1'.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>booleanFalse</literal>: String value to use in 
            PreparedStatement.setBoolean(false), default is '0'.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>connectionPooling</literal>: By default the C-JDBC 
            driver does transparent connection pooling on your behalf meaning 
            that when connection.close() is called, the connection is not 
            physically closed but rather put in a pool for reuse within the 
            next 5 seconds. Set this to false if you do not want the driver to 
            perform transparent connection pooling.</para>
        </listitem>
      </itemizedlist>      
      <itemizedlist>
        <listitem>
          <para><literal>debugLevel</literal>: Debug level that can be set to 
            'debug', 'info' or 'off' to display driver related information on 
            the standard output. Default is off.</para>
        </listitem>
      </itemizedlist>
	  <itemizedlist>
		<listitem>
			<para><literal>driverProcessed</literal>: can be set to 'true or
				'false', see Proxying mode below.</para>
		</listitem>
	  </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeBackslash</literal>: Set this to false if you 
            don't want to escape backslashes when performing escape processing 
            of PreparedStatements, default is true.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeSingleQuote</literal>: Set this to false if you 
            don't want to escape single quotes (') when performing escape 
            processing of PreparedStatements, default is true</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>escapeCharacter</literal>: Character to prepend and 
            append to the String values when performing escape processing of 
            PreparedStatements, default is a single quote.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>user</literal>: user login</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>password</literal>: user password</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para> <literal>preferredController</literal>: defines the strategy 
            to use to choose a preferred controller to connect to.</para>
          <para> 
            <literal>jdbc:cjdbc://node1,node2,node3/myDB?preferredController=ordered 
            </literal>: Always connect to node1, and if not available then try 
            to node2 and finally if none are available try node3.</para>
          <para> 
            <literal>jdbc:cjdbc://node1,node2,node3/myDB?preferredController=random</literal>: 
            Pickup a controller node randomly (default strategy)</para>
          <para> 
            <literal>jdbc:cjdbc://node1,node2:25343,node3/myDB?preferredController=node2:25343,node3 
            </literal>: Round-robin between node2 and node3, fallback to node1 
            if none of node2 and node3 is available.</para>
          <para> 
            <literal>jdbc:cjdbc://node1,node2,node3/myDB?preferredController=roundRobin</literal>: 
            Round robin starting with first node in URL.</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para><literal>retryIntervalInMs</literal>: once a controller has 
            died, the driver will try to reconnect to this controller every 
            retryIntervalInMs to see if the backend is back online. The default 
            is 5000 (5 seconds). </para>
        </listitem>
      </itemizedlist>
    </section>
    </section>
    <!-- ========== Proxying mode ========== -->
    <section id="proxying_mode">
      <title>Proxying mode</title>
      <para>By default, the C-JDBC driver interprets the PreparedStatement 
        locally and forwards a pre-processed statement. The C-JDBC controller 
        executes directly these statements on the backends as statements 
        without recreating a whole PreparedStatement and re-calling all 
        setXXX() methods on the PreparedStatement. The default setting is the 
        one that consumes the less resources and carries the minimum 
        information over the network.</para>
      <para>However, it might happen that this behavior is not desired or that 
        the C-JDBC driver interpretation is unsuitable for some data types or 
        database specific syntax. Therefore, it is possible to make the driver 
        act as a real proxy that will forward all setXXX() calls to the 
        database native driver. This will usually result in slightly lower 
        performance but better portability.</para>
      <para>The proxying mode can be enabled for a connection by setting a 
        specific variable named <literal>driverProcessed</literal> to false 
        (default value if omitted is true). To enable PreparedStatement 
        proxying in C-JDBC use a connection URL like this:</para>
			<programlisting> 
				DriverManager.getConnection("jdbc:cjdbc://host/db?driverProcessed=false")
		  </programlisting>
       <para>Note: since any optional blob encoding is performed by
       the driver, blob encoding is disabled by
       <literal>driverProcessed=false</literal>. If you ever encoded blobs,
       you CANNOT switch to <literal>driverProcessed=false</literal> anymore.
       </para>
		</section>
    <!-- ========== Getting a connection using a data source ========== -->
    <section id="getting_a_connection_using_data_source">
      <title>Getting a connection using a data source</title>
      <para>Another way to use the C-JDBC driver is to use its 
        <literal>DataSource</literal> implementation. Data sources have been 
        introduced in JDBC 2.0 Standard Extension API and are also a part of 
        JDBC 3.0. They use the Java Naming and Directory Interface (JNDI) to 
        break the application dependence on the JDBC driver configuration 
        (i.e., driver class name, machine name, port number, etc.). With a data 
        source, the only thing an application has to know is the name assigned 
        to the <literal>DataSource</literal> object in the 
        <literal>jdbc</literal> naming subcontext of the JNDI namespace.</para>
      <para>The example below registers a data source object with a JNDI naming 
        service. It is typically used by an application server.</para>
      <programlisting>
      import org.objectweb.cjdbc.driver.DataSource;
      import javax.naming.Context;
      import javax.naming.InitialContext;
      import javax.naming.NamingException;
      ...
      private final static String NAME = "jdbc/c-jdbc";
      private final static String URL = "jdbc:cjdbc://localhost:25322/mysql";
      
      // Initializing data source
      DataSource ds = new DataSource();
      ds.setUrl(URL);

      // Get initial context
      Context ctx;
      try {
        ctx = new InitialContext();
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
		
      // Bind data source to a JNDI name
      try {
        ctx.bind(NAME, ds);
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
      </programlisting>
      <para>The <literal>org.objectweb.cjdbc.driver.DataSource</literal> class 
        implements the <literal>javax.sql.DataSource</literal> JDBC 3.0 
        interface. The <literal>setUrl</literal> line initializes the data 
        source properties (the URL in this case). The data source object is 
        bound to a logical JNDI name by calling <literal>ctx.bind()</literal>. 
        In the example above, the JNDI name specifies a "jdbc" subcontext and a 
        "c-jdbc" logical name within this subcontext. </para>
      <para>Once a data source object is registered to JNDI, it can be used by 
        an application. The example below gets the data source using the JNDI 
        naming service. Such a piece of code is typically a part of an 
        application that uses JDBC. </para>
      <programlisting>
      import javax.naming.Context;
      import javax.naming.InitialContext;
      import javax.naming.NamingException;
      import java.sql.Connection;
      import javax.sql.DataSource;
      ...
      private final static String NAME = "jdbc/c-jdbc";

      // Lookup for the data source object
      try {
        Context ctx = new InitialContext();
        Object obj = ctx.lookup(NAME);
        if (null == obj) {
          ... // Something wrong: NAME not found
        }
        ctx.close( );
      } catch (javax.naming.NamingException _e) {
        ... // Naming exception
      }
      
      // Get a new JDBC connection
      try {
        DataSource ds = (DataSource) obj;
        Connection conn = ds.getConnection("user", "c-jdbc");
        ... // Use of the connection retrieved
        ...
      } catch (SQLException _e) {
        ... // SQL exception
      }
      </programlisting>
      <para>The <literal>ctx.lookup()</literal> line in the example uses the 
        retrieved initial JNDI naming context to do a lookup using the data 
        source logical name. The method returns a reference to a Java object 
        which is then narrowed to a <literal>javax.sql.DataSource</literal> 
        object. Such an object can be then used to open a new JDBC connection 
        by invoking one of its <literal>getConnection()</literal> methods. The 
        application code is completely independent of the driver details, such 
        as the <literal>Driver</literal> class name, URL, etc. (the user name 
        and password used by the connection can be also set by the application 
        server - look at the C-JDBC javadoc documentation for more details). 
        The only information a JDBC application has to know is the logical name 
        of the data source object to use. </para>
      <note>
        <para>The URL used for the C-JDBC data source is the same as for the 
          <literal>Driver</literal> decribed in the previous section.</para>
      </note>
    </section>
    <!-- ========== Stored procedures ========== -->
    <section id="stored_procedures">
      <title>Stored procedures</title>
      <para>Stored procedures are supported by C-JDBC since version 1.0b6. Note 
        that C-JDBC only support calls in the form <command>{call 
        &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, ...]}</command> but 
        does not support <command>{? = call 
        &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;, 
        ...]}</command>.</para>
      <para>A call to a stored procedure is systematically broadcasted to all 
        backends since there is no way to know if the stored procedure will 
        update the database or not. Therefore, the query cache (see <xref 
        linkend="dtd_requestcache"></xref>), is completely flushed on every 
        stored procedure call. To prevent cache flushing, the user can force 
        the connection to read-only before calling the stored procedure. But 
        never set a connection to read-only when calling a stored procedure 
        that updates the database. If C-JDBC detects a read-only connection, it 
        will not flush the cache. However, the call will still be broadcasted 
        to all nodes resulting in duplicated jobs on each backend. Here is an 
        example on how to prevent cache flushing when calling a stored 
        procedure that does only read-only:</para>
      <programlisting> 
        ... 
        CallableStatement cs = connection.prepareCall("{call myproc(?)}"); 
        cs.setString(1,"parameter1");
        // Force no cache flush  
        connection.setReadOny(true); 
        // Call the stored procedure without flushing the cache ... 
        ResultSet rs = cs.executeQuery(); 
      </programlisting>
      <para>In the case of horizontal scalability, only read-only stored procedures are not
        broadbasted. All other stored procedures returning an int or a ResultSet are
        executed by all backends at all controllers.</para>
      <note>
		<para>It is not allowed to set a connection to read-only in the middle 
			of a transaction. If you need to set a connection to read-only, you 
			must do so before starting the transaction.</para>
      </note>
    </section>
    <!-- ========== Blobs ========== -->
    <section id="using_blobs">
      <title>Blobs: Binary Large Objects</title>
      <para>Binary large objects can now be stored using the C-JDBC driver 
        since 1.0b10. Data is encoded into hexadecimal to be portable accross 
        database engines.</para>
      <para>FIXME: this whole section is outdated and should be
      re-written.  Blob encoding is now configured in controller's
      DTD and set to "none" by default. It requires
      <literal>driverProcessed=true</literal>, which is the
      default.</para>

      <note>
        <itemizedlist>
          <listitem>
            <para>The column type used to store large objects with 
              <literal>MySQL</literal> is <literal>text</literal>.</para>
          </listitem>
          <listitem>
            <para>The column type used to store large objects with 
              <literal>PostgreSQL</literal> is <literal>bytea</literal>.</para>
          </listitem>
        </itemizedlist>
      </note>
      <para>You should not have to change your code for storing blobs into your 
        database, but previous blobs have to be converted to their hexadecimal 
        form. You can use <ulink 
        url="http://octopus.objectweb.org">Octopus</ulink> to perform this 
        transformation.</para>
      <para>Please refer to the following lines of code for storing and 
        retrieving of large objects:</para>
      <programlisting>
        // In the code below:
        // The signature of the readBinary method is:
        // byte[] readBinary(File file) throws IOException
        // it just read a file, and convert its content into an array of bytes
        
        // Store file in database 
        File fis = new File(storeFile); 
        query = "insert into ... values(...,?)"; 
        ps1 = con.prepareStatement(query); 
        if (callBlobMethods) 
        {
          org.objectweb.cjdbc.driver.Blob bob = 
            new org.objectweb.cjdbc.driver.Blob(readBinary(fis)); 
          ps1.setBlob(1, bob); 
        } 
        else 
        { 
          ps1.setBytes(1, readBinary(fis)); 
        } 
        ps1.executeUpdate();
        // Read File from database 
        query = "select * from ... where id=..."; 
        ps1 = con.prepareStatement(query); 
        ResultSet rs = ps1.executeQuery(); 
        rs.first(); 
        byte[] lisette; 
        if (callBlobMethods) 
        { 
          Blob blisette = rs.getBlob("blobcolumnname"); 
          lisette = blisette.getBytes((long) 1, (int) blisette.length());
        }
        else 
        {
          lisette = rs.getBytes("blobcolumnname"); 
        } 
      </programlisting>
    </section>
    <!-- ========== Clobs ========== -->
    <section id="using_clobs">
      <title>Clobs: Character Large Objects</title>
      <para> CLOB is a built-in type that stores a Character Large Object as a 
        column value in a row of a database table. By default drivers implement 
        Clob using an SQL locator (CLOB), which means that a Clob object 
        contains a logical pointer to the SQL CLOB data rather than the data 
        itself. A Clob object is valid for the duration of the transaction in 
        which it was created. </para>
      <para> Clobs in C-JDBC are handled like strings. You can refer to the 
        section of code below to make good usage of clobs. This code is part of 
        the C-JDBC test suite. </para>
      <programlisting> 
        String clob = "I am a clob"; 
        ps = con.prepareStatement("insert into ... values(...,?)"); 
        ps.setString(1, clob); 
        ps.executeUpdate(); 
        
        // Test retrieval 
        String ret; 
        ps = con.prepareStatement("Select * from ... where id=..."); 
        rs = ps.executeQuery(); 
        rs.first(); 
        clob = rs.getClob("name"); 
        ret = clob.getSubString((long) 0, (int) clob.length()); 
      </programlisting>
    </section>
    <!-- ========== ResultSet streaming ========== -->
    <section id="resultset_streaming">
      <title>ResultSet streaming</title>
      <para>In its default mode, when a query is executed on a backend, C-JDBC 
        makes a copy of the backend's native ResultSet into a C-JDBC 
        serializable ResultSet. If the result contains many rows or very large 
        objects, the controller might run out of memory when trying to copy the 
        whole ResultSet.</para>
      <para>Since C-JDBC 1.0rc6, it is possible to fetch ResultSets by blocks 
        using the Statement.setFetchSize(int rows) method. In this case, the 
        ResultSet will be copied by block of rows and returned when needed by 
        the client. Note that the current implemtation only allows to fetch 
        forward streamable ResultSet, which basically means that you are only 
        allowed to call ResultSet.next() on a streamable ResultSet.</para>
      <para>C-JDBC will try to call setFetchSize() on the backend's driver to 
        let the backend driver also perform the necessary optimizations. 
        However, some driver requires a prior call to setCursorName() in which 
        case you will also have to call setCursorName() on C-JDBC to pass it to 
        the backend's driver.</para>
      <para>A typical usage of the ResultSet streaming feature is as 
        follows:</para>
      <programlisting>
...        
Connection con = getCJDBCConnection();
con.setAutocommit(false);
Statement s = con.createStatement();
s.setCursorName("cursor name");
s.setFetchSize(10);
rs = s.executeQuery(sql);
while (rs.next())
{ // Every 10 calls, C-JDBC will transfer a new block of rows
  XXX o = rs.getXXX("some column name");
}
...
con.commit();
      </programlisting>
      <note>
        <para>Streamable ResultSets are not cacheable. The result cache 
          automatically detects this kind of ResultSet and does not keep them 
          in the cache. However, as database specific ResultSets are copied 
          into C-JDBC ResultSets, the memory footprint of the fetched blocks 
          will be twice the one obtained without C-JDBC. If you have memory 
          restrictions, you can reduce your fetch size by half to reduce the 
          memory footprint of streamed ResultSets.</para>
        <para>Streamable ResultSets do not work properly in autocommit mode as 
            the connection used for retrieving the ResultSet is handed back to 
            the pool. The workaround is to always encapsulate the query in a 
            transaction. Note that databases such as PostgreSQL do not support 
            streamable ResultSets in autocommit mode as well.</para>
      </note>
    </section>
    <!-- ========== Current Limitations ========== -->
    <section id="current_driver_limitations">
      <title>Current Limitations</title>
      <para>The C-JDBC driver currently does not support the following 
        features:</para>
      <itemizedlist>
        <listitem>
          <para>java.sql.Array and java.sql.Ref types,</para>
        </listitem>
        <listitem>
          <para>Custom type mapping using java.sql.Connection.setTypeMap(java.util.Map map),</para>
        </listitem>
        <listitem>
          <para><literal>XAConnections</literal> (look at the <ulink url="http://xapool.experlog.com">XAPool project</ulink> for XA support with C-JDBC),</para>
        </listitem>
        <listitem>
          <para>CallableStatements with OUT parameters,</para>
        </listitem>
        <listitem>
          <para>Streamable ResultSets do not work in autocommit mode.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  
  <section id="configuring-cjdbc_with_3rd_party_software">
    <title>Configuring C-JDBC with 3rd party software</title>  
    <!-- ========== Forenotes ========== -->	
	<section id="forenotes">
		<title>Forenotes on configuring C-JDBC with your application</title>
    <para>If the application you are using C-JDBC with requires a mapper, the best thing to do
      is to configure the mapping to be that of C-JDBC's underlying databases. For example, if
      you were using JBoss with PostgreSQL , then using C-JDBC on top of the PostgreSQL
      backends with JBoss would imply to still use the mapping for PostgreSQL while plugging
      the application server to C-JDBC (using C-JDBC's driver and C-JDBC's url). </para>
	</section>
	
    <!-- ========== Configuring with Tomcat ========== -->
    <section id="configuring_cjdbc_with_tomcat">
      <title>Configuring C-JDBC with Jakarta Tomcat</title>
      <para>Copy the <filename>c-jdbc-driver.jar</filename> file to the 
        <filename class="directory">lib</filename> directory of your web 
        application (for example: <filename 
        class="directory">$TOMCAT_HOME/webapps/mywebapp/WEB-INF/lib</filename>).</para>
      <para>There are many ways to obtain connections from a Tomcat 
        application. Just ensure that you are using 
        <literal>org.objectweb.cjdbc.driver.Driver</literal> as the driver 
        class name and that the JDBC URL is a C-JDBC URL (see <xref 
        linkend="cjdbc_jdbc_url"/>).</para>
    </section>
    <!-- ========== Configuring C-JDBC with JOnAS ========== -->
    <section id="configuring_cjdbc_with_jonas">
      <title>Configuring C-JDBC with JOnAS</title>
      <para>The <filename>c-jdbc-driver.jar</filename> file must be found in 
        the JOnAS CLASSPATH.</para>
      <para>Here is an example of a <filename>cjdbc.properties</filename> file 
        to store in JONAS 3.x <filename class="directory">conf</filename> 
        directory (use the <filename class="directory">config</filename> 
        directory for JOnAS 2.x):</para>
      <programlisting> 
        ###################### C-JDBC DataSource configuration example # 
        datasource.name      jdbc_1 
        datasource.url       jdbc:cjdbc://someMachine/someDatabase 
        datasource.classname org.objectweb.cjdbc.driver.Driver 
        datasource.username  your-username 
        datasource.password  your-password 
      </programlisting>
    </section>
    <!-- ========== Configuring C-JDBC with JBoss ========== -->
    <section id="configuring_cjdbc_with_jboss">
      <title>Configuring C-JDBC with JBoss</title>
      <para>Copy the <filename>c-jdbc-driver.jar</filename> file to <filename 
        class="directory">$JBOSS_DIST/server/default/lib</filename> for JBoss 
        3.x or to <filename 
        class="directory">$JBOSS_DIST/jboss/lib/ext</filename> for JBoss 
        2.x.</para>
      <para>Here is an example of a datasource configuration file to be used 
        with JBoss:</para>
      <programlisting> 
        &lt;?xml version="1.0" encoding="UTF-8"?> 
        &lt;!-- ===================================================================== --> 
        &lt;!--                                                                       --> 
        &lt;!-- JBoss Server Configuration                                            -->
        &lt;!--                                                                       --> 
        &lt;!-- ===================================================================== --> 

        &lt;!-- ===================================================================== --> 
        &lt;!-- Datasource config for C-JDBC                                          -->
        &lt;!-- ===================================================================== --> 
        &lt;datasources> 
          &lt;local-tx-datasource> 
            &lt;jndi-name>cjdbc-DS&lt;/jndi-name> 
            &lt;connection-url>jdbc:cjdbc://localhost:25322/lscluster&lt;/connection-url> 
            &lt;driver-class>org.objectweb.cjdbc.driver.Driver&lt;/driver-class> 
            &lt;user-name>user&lt;/user-name> 
            &lt;password>tagada&lt;/password> 
          &lt;/local-tx-datasource> 
        &lt;/datasources> 
      </programlisting>
    </section>
    <!-- ========== Configuring C-JDBC with BEA Weblogic Server 7.x/8.x ========== -->
    <section id="configuring_cjdbc_with_weblogic">
      <title>Configuring C-JDBC with BEA Weblogic Server 7.x/8.x</title>
      <para>Place the <filename>c-jdbc-driver.jar</filename> file in the 
        classpath of the Weblogic Server.</para>
      <para>Here is an example of a connection pool configuration for use with 
        Weblogic:</para>
      <programlisting>
    &lt;JDBCConnectionPool 
        DriverName="org.objectweb.cjdbc.driver.Driver"
        InitialCapacity="1"  MaxCapacity="15" 
        Name="cjdbcPool" Properties="user=username;password=password" 
        ShrinkingEnabled="true" SupportsLocalTransaction="true" 
        Targets="wlservername" URL="jdbc:cjdbc://192.168.0.1/vdb" 
        XAPreparedStatementCacheSize="0"/>
      </programlisting>

      <para>Next, create the required <literal>TXDataSources</literal>:</para>

      <programlisting>
        &lt;JDBCTxDataSource EnableTwoPhaseCommit="true" 
          JNDIName="cjdbc-DS" Name="C-JDBC TX Data Source" 
          PoolName="cjdbcPool" RowPrefetchEnabled="true" Targets="wlservername"/>
      </programlisting>
    </section>
    <!-- ========== Configuring C-JDBC with Hibernate ========== -->
    <section id="configuring_cjdbc_with_hibernate">
      <title>Configuring C-JDBC with Hibernate</title>
      <para>C-JDBC just has to be defined as any JDBC driver in Hibernate, 
        leaving the syntax set to the proper database. Here is a configuration 
        example to use Hibernate with a C-JDBC cluster made of Sybase 
        backends:</para>
      <programlisting>
## C-JDBC
hibernate.dialect                 net.sf.hibernate.dialect.SybaseDialect
hibernate.connection.driver_class org.objectweb.cjdbc.driver.Driver
hibernate.connection.username     user
hibernate.connection.password     pass
hibernate.connection.url          jdbc:cjdbc://localhost:25322/test        
      </programlisting>
    </section>
    
    <section id="using_sequence_with_hibernate">
      <title>Using sequences with Hibernate, C-JDBC and PostgreSQL</title>
      <para>Our Hibernate dialect is as follows:</para>
      <programlisting> 
        import net.sf.hibernate.dialect.PostgreSQLDialect; 
        public class CJDBCPostgreSQLDialect extends PostgreSQLDialect 
        { 
          public String getSequenceNextValString(String sequenceName) 
          { 
            return "{call nextval('"+sequenceName+"')}"; 
          } 
        } 
      </programlisting>
      <para> We simply extend the default PostgreSQL Dialect and override the 
        getSequenceNextValString() method and tell it to use "{call ..." so 
        that all the sequences in the cluster get incremented. </para>
      <para> We then changed our Hibernate conf file to user to our custom 
        dialect instead of net.sf.hibernate.dialect.PostgreSQLDialect. </para>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: C-JDBC Controller -->
  <!-- =============================================================== -->
  <section id="c_jdbc_controller">
    <title>C-JDBC controller</title>
    <!-- ========== Design Overview ========== -->
    <section id="design_overview">
      <title>Design Overview</title>
      <para>The C-JDBC controller is made of several components as shown in 
        <xref linkend="fig_controller_overview"/>. The controller hosts 
        <emphasis>virtual databases</emphasis>. A <emphasis>virtual 
        database</emphasis> gives the illusion of a single database to the 
        user. It exports the same database name and login/password as those 
        used in the client application. Therefore the client application can 
        run unmodified with C-JDBC.</para>
      <para>When the client application connects to the database using an URL 
        like <literal>jdbc:cjdbc://host:25322/myDB</literal>, the C-JDBC driver 
        tries to connect to a C-JDBC controller running on port 
        <literal>25322</literal> on node <literal>host</literal>. Once the 
        connection is established the login and password are sent with the 
        <literal>myDB</literal> database name to be checked by the 
        controller.</para>
        
      <para>A virtual database contains the following components:</para>
      <itemizedlist>
        <listitem>
          <para><emphasis>authentication manager</emphasis>: it matches the 
            virtual database login/password (provided by the application to the 
            C-JDBC driver) with the real login/password to use on each backend. 
            The authentication manager is only involved at connection 
            establishment time.</para>
        </listitem>
        <listitem>
          <para><emphasis>backup manager</emphasis>: manages a list of generic or
            database specific Backupers that are in charge of performing database dump and
            restore operation. Backupers should also take careof transferring dumps from
            one controller to another.</para>
        </listitem>
        <listitem>
          <para><emphasis>request manager</emphasis>: it handles the requests 
            coming from a connection with a C-JDBC driver. It is composed of 
            several components:</para>
          <itemizedlist>
            <listitem>
              <para><emphasis>scheduler</emphasis>: it is responsible for 
                scheduling the requests. Each RAIDb level has its own 
                scheduler.</para>
            </listitem>
            <listitem>
              <para><emphasis>request caches</emphasis>: these are optional 
                components that can cache query parsing, the result set and 
                result metadata of queries.</para>
            </listitem>
            <listitem>
              <para><emphasis>load balancer</emphasis>: it balances the load on 
                the underlying backends according to the chosen RAIDb level 
                configuration.</para>
            </listitem>
            <listitem>
              <para><emphasis>recovery log</emphasis>: it handles checkpoints 
                and allows backends to dynamically recover from a failure or to 
                be dynamically added to a running cluster.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><emphasis>database backend</emphasis>: it represents the real 
            database backend running the RDBMS engine. A <emphasis>connection 
            manager</emphasis> mainly provides connection pooling on top of the 
            database JDBC native driver.</para>
        </listitem>
      </itemizedlist>
      <figure id="fig_controller_overview">
        <title>C-JDBC controller design overview</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/c-jdbc_controller.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata align="center" fileref="images/c-jdbc_controller.gif" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Each virtual database and its components are configured using an 
        XML configuration file that is sent from the administration console to 
        the C-JDBC controller.
      </para>
      <note><para>A <ulink url="http://c-jdbc.objectweb.org/current/doc/RR-C-JDBC.pdf">
        research report details RAIDb and C-JDBC implementation</ulink>. Other
        documents and presentations about C-JDBC can be found in the 
        <ulink url="http://c-jdbc.objectweb.org/doc">documentation section of 
          the web site</ulink>.
        </para></note>
    </section>
    <!-- ========== Starting the Controller ========== -->
    <section id="starting_controller">
      <title>Starting the Controller</title>
      <para>The <filename class="directory">bin</filename> directory of the 
        C-JDBC distribution contains the scripts to start the controller. Unix 
        users must start the controller with <command>controller.sh</command> 
        whereas Windows users will use <command>controller.bat</command>. 
        </para>
      <para>Since C-JDBC Controller version 1.0b11, the controller start is 
        tuned via a configuration file, called 
        <filename>controller.xml</filename>, included under the <filename 
        class="directory">config/controller</filename> directory of your C-JDBC 
        installation. A simple configuration file looks like this:</para>
      <para>A standard C-JDBC Controller configuration file looks like this:</para>
      <programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
&lt;!DOCTYPE C-JDBC-CONTROLLER PUBLIC "-//ObjectWeb//DTD C-JDBC-CONTROLLER 2.0.2//EN"  "http://c-jdbc.objectweb.org/dtds/c-jdbc-controller-2.0.2.dtd">
&lt;C-JDBC-CONTROLLER>
	&lt;Controller port="25322">
    &lt;Report hideSensitiveData="true" generateOnFatal="true"/>
    &lt;JmxSettings>
      &lt;RmiJmxAdaptor/>
    &lt;/JmxSettings>
  &lt;/Controller>
&lt;/C-JDBC-CONTROLLER>
      </programlisting>
      <para>You can specify at startup a different file than 
        <filename>config/controller/controller.xml</filename>. This is useful if you have 
        to startup many identical controllers from the network. You can then 
        use the command <command>controller.sh -f filename</command> on Unix 
        machines or <command>controller.bat -f filename</command> on 
        windows.</para>
        <para>For more information you can refer to the 
          controller-configuration.xml example in the example directory of 
          c-jdbc.</para>
      <!-- TODO: Command line options of the controller. -->
     <para>Next section describes how to write a controller configuration file.
     </para>
    </section>

    <!-- ========== Configuring the controller ========== -->
    <section id="writing_the_controller_config_file">
    <title>Writing the controller configuration file</title>
    <para>The controller is entirely configurable via an xml file, by default 
      it is <filename>controller.xml</filename> located in the <filename 
      class="directory">config/controller</filename> of the C-JDBC installation. This 
      section details how to write such a file. </para>
    
    <section id="dtd_controller_parameters">
    <title>Controller Parameters</title>
    <para>The root element of the controller configuration is defined as follows
    </para>
    <programlisting>
&lt;!ELEMENT Controller (Internationalization?, Report?, JmxSettings?, 
                                    VirtualDatabase*, SecuritySettings?)&gt;
&lt;!ATTLIST Controller
  port             CDATA "25322"
  ipAddress        CDATA "127.0.0.1"
  backlogSize      CDATA "10"
>
    </programlisting>
    <para>All sub-elements of Controller are defined in the next sections. Here
      is a brief overview of each of them:</para>
    <itemizedlist>
      <listitem>
      	<para><literal>Internationalization</literal>: defines the language
      	  setting for C-JDBC console and error messages.</para>
      </listitem>
      <listitem>
        <para><literal>Report</literal>: if this option is enabled, C-JDBC can
          automatically generate a report on fatal errors or shutdown. If you
          experience any problem with C-JDBC, you can directly send the report
          on the mailing list to get a quick diagnostic of what happened.</para>
      </listitem>
      <listitem>
        <para><literal>JmxSettings</literal>: JMX is the technology used for 
          management and monitoring in C-JDBC. These functionalities can be 
          accessed through HTTP with an internet browser or through the RMI 
          connector used by the C-JDBC console.</para>
      </listitem>
      <listitem>
        <para><literal>VirtualDatabase</literal>: Defines a virtual database to 
          load automatically at controller startup given a reference to its 
          configuration file.</para>
      </listitem>
      <listitem>
        <para><literal>SecuritySettings</literal>: Allows to filter accesses to 
          a controller based on access lists.</para>
      </listitem>
    </itemizedlist>
    
    <para>The attributes of a Controller element are defined as follows:</para>
    <itemizedlist>
      <listitem>
        <para><literal>port</literal>: the port number on which clients (C-JDBC 
          drivers) will connect. The default port number is 
          <emphasis>25322</emphasis>.</para>
        <note>
          <para>A port number below 1024 will require running the controller 
            with privileged rights (root user under Unix).</para>
        </note>
      </listitem>
      <listitem>
        <para><literal>ipAddress</literal>: This can be defined to bind a 
          specific IP address in case of a host with multiple IP addresses. 
          This can be ignored if there is only one IP address available and 
          will be replaced by <literal>127.0.0.1</literal>.</para>
      </listitem>
      <listitem>
        <para><literal>backlogSize</literal>: the server socket backlog size 
          (number of connections that can wait in the accept queue before the 
          system returns "connection refused" to the client). Default is 10. 
          Tune this value according to your operating system, but the default 
          value should be fine for most settings.</para>
      </listitem>
    </itemizedlist>
    <para>If your machine has multiple network adapters, you can for the
        C-JDBC Controller to bind a specific IP address like this:</para>
    <programlisting>
&lt;?xml version="1.0" encoding="ISO-8859-1" ?>
&lt;!DOCTYPE C-JDBC-CONTROLLER PUBLIC "-//ObjectWeb//DTD C-JDBC-CONTROLLER 2.0.2//EN"  "http://c-jdbc.objectweb.org/dtds/c-jdbc-controller-2.0.2.dtd">
&lt;C-JDBC-CONTROLLER>
	&lt;Controller port="25322" ipAddress="192.168.0.1">
		&lt;JmxSettings enabled="false"/>
	&lt;/Controller>
&lt;/C-JDBC-CONTROLLER>
    </programlisting>
    </section>
    
    <!-- ========== Internationalization ========== -->
    <section id="dtd_controller_internationalization">
    <title>Internationalization</title>
    <para>You can use this element to override the default locale retrieved by 
      java. English is the only language looked at at the moment.</para>
    <programlisting>
    &lt;!ELEMENT Internationalization EMPTY>
    &lt;!ATTLIST Internationalization language (en|fr|it|jp) "en"&gt;
    </programlisting>
    </section>
    
    <!-- ========== Report ========== -->
    <section id="dtd_controller_report">
    <title>Report</title>
    <para>A report can be define in case you want to get a trace of what 
      happened during the execution of the controller. If this element is 
      included in the <filename>controller.xml</filename> report is enabled and 
      will output a report, under certain conditions, in a file named 
      <filename>c-jdbc.report</filename>.</para>
    <programlisting>
&lt;!ELEMENT Report EMPTY>
&lt;!ATTLIST Report
     hideSensitiveData  (true|false) "true"
     generateOnShutdown (true|false) "true"
     generateOnFatal    (true|false) "true"
     enableFileLogging  (true|false) "true"
     reportLocation     CDATA        #IMPLIED
>
    </programlisting>
    <itemizedlist>
      <listitem>
        <para><literal>hideSensitiveData</literal>: will replace passwords with 
          '*****'.</para>
      </listitem>
      <listitem>
        <para><literal>generateOnShutdown</literal>: tells the controller to 
          generate a report when it has received a shutdown command.</para>
      </listitem>
      <listitem>
        <para><literal>generateOnFatal</literal>: tells the controller to 
          generate a report when it cannot recover from an error. </para>
      </listitem>
      <listitem>
        <para><literal>enableFileLogging</literal>: logs all the console output 
          into a file and include this file into the report.</para>
      </listitem>
      <listitem>
        <para><literal>reportLocation</literal>: specify the path where to 
          create the report, default is
	  <filename class="directory"><literal>CJDBC_HOME</literal>/log</filename> directory.</para>
      </listitem>
    </itemizedlist>
    </section>
    
    <!-- ========== Configuring JMX ========== -->
    <section id="dtd_controller_jmx">
    <title>JMX</title>
    <para>JMX is used to remotely administrate the controller. You can use the 
      bundled C-JDBC console or use your own code to access JMX MBeans via the 
      protocol adaptor. C-JDBC proposes both the RMI and HTTP adaptors of the 
      <ulink url="http://mx4j.sourceforge.net/">MX4J</ulink> JMX server. You 
      can override the default port numbers for each adaptor if they conflict 
      with another application that is already using them (i.e. another C-JDBC 
      controller on the same machine).</para>
    <programlisting>
    &lt;!ELEMENT JmxSettings (HttpJmxAdaptor?, RmiJmxAdaptor?)&gt;
    &lt;!ELEMENT HttpJmxAdaptor EMPTY>
    &lt;!ATTLIST HttpJmxAdaptor
      port CDATA "8090"
    &gt;

     &lt;!ELEMENT RmiJmxAdaptor (SSL?)&gt;
     &lt;!ATTLIST RmiJmxAdaptor
       port         CDATA        "1090"
       username     CDATA        #IMPLIED
       password     CDATA        #IMPLIED
     &gt;


     &lt;!ELEMENT SSL EMPTY&gt;
     &lt;!ATTLIST SSL
       keyStore			CDATA        #REQUIRED
       keyStorePassword		CDATA        #REQUIRED
       keyStoreKeyPassword	CDATA        #IMPLIED
       isClientAuthNeeded	(true|false) "false"
       trustStore		CDATA        #IMPLIED
       trustStorePassword	CDATA        #IMPLIED
     &gt;
     </programlisting>
     

     <para>Configure ssl for encryption and/or authentication.</para>
      <itemizedlist>
        <listitem>
          <para><literal>keyStore</literal>: The file where the keys are stored
          </para>
        </listitem>
        <listitem>
          <para><literal>keyStorePassword</literal>: the password to the keyStore
          </para>
        </listitem>
        <listitem>
          <para><literal>keyStoreKeyPassword</literal>: the password to the key, if none is specified the same password as for the store is used
          </para>
        </listitem>
        <listitem>
          <para><literal>isClientAuthNeeded</literal>: if set to false ssl is used for encryption, the server is only accepting trusted clients (the client certificate has to be in the trusted store)
          </para>
        </listitem>
        <listitem>
          <para><literal>trustStore</literal>: the file where the trusted certificates are stored, if none is specified the same store as for the key is used
          </para>
        </listitem>
        <listitem>
          <para><literal>trustStorePassword</literal>: the password to the trustStore, if none is specified the same password as for the keyStore is used</para>
        </listitem>
      </itemizedlist>


      <para>You have to enable the RMI adaptor if you want to use the C-JDBC 
        console to administrate the controller remotely. To enable the RMI JMX 
        adaptor, use this setting:</para>
     <programlisting>
     &lt;JmxSettings&gt;
     	 &lt;RmiJmxAdaptor/&gt;
		 &lt;/JmxSettings&gt;
     </programlisting>
     </section>
     
     <section id="dtd_controller_database">
     <title>Virtual Database</title>
      <para>This element specifies virtual databases to load at controller 
        startup.</para>
      <programlisting>
&lt;!ELEMENT VirtualDatabase EMPTY&gt;
&lt;!ATTLIST VirtualDatabase 
    configFile          CDATA #REQUIRED
    virtualDatabaseName CDATA #REQUIRED
    autoEnableBackends  (true | false | force) "true"
    checkpointName      CDATA ""
&gt;
      </programlisting>
      <itemizedlist>
        <listitem>
          <para><literal>configFile</literal>: The path to the virtual database 
            configuration file. See <xref linkend="configuration"></xref> to 
            learn how to write a virtual database configuration file.</para>
        </listitem>
        <listitem>
          <para><literal>virtualDatabaseName</literal>: The name of the virtual 
            database since the configuration file can contain multiple virtual 
            database definitions.</para>
        </listitem>
        <listitem>
          <para><literal>autoEnableBackends</literal>: set to true by default 
            to reenable backends from their last known state as stored during 
            last shutdown. If backends where not properly shutdown, nothing 
            will happen. You can specify false to let the backends in disabled 
            state at startup. The force option should only be used if you know 
            exactly what you are doing and override backend status by providing 
            a new checkpoint. <emphasis>Warning!</emphasis> Use this setting 
            carefully as it might break your database consistency if you do not 
            provide a valid checkpoint.Force is considered the same as true if 
            no recovery log has been defined.</para>
        </listitem>
        <listitem>
          <para><literal>checkpointName</literal>: the checkpoint name to use with 
            the recovery log to enable backend from a known coherent state. If 
            the checkpoint is omitted, the last known checkpoint is used.</para>
        </listitem>
      </itemizedlist>
            
      <para>Example:</para>
      <programlisting>
&lt;VirtualDatabase configFile="/databases/MySQLDb.xml" virtualDatabaseName="rubis" autoEnableBackends="true"/&gt;
      </programlisting>
      <para>This will enable a virtual database named <literal>rubis</literal> 
        taken from a configuration file named 
        <filename>/databases/MySQLDb.xml</filename> and will enable all 
        backends of the database from the last known checkpoint.</para>
      </section>
      
      <section id="dtd_controller_security">
      <title>Security</title>
      <para>Security settings define the policy to adopt for some 
        functionalities that may compromise the security of the controller. 
        These settings depends on your environment and can be relaxed if you 
        are running in a secure network. The less security settings you have, 
        the faster the controller will run. A SecuritySettings element is 
        defined as follows:</para>
      <programlisting>
      &lt;!ELEMENT SecuritySettings (Jar?, Shutdown?, Accept?, Block?)&gt;
      &lt;!ATTLIST SecuritySettings
        defaultConnect (true|false) "true"
      &gt;
      </programlisting>
      <para><literal>defaultConnect</literal>: is used to allow (true) or 
        refuse (false) connections to the controller. This default setting can 
        be then be tuned with access lists defined in <literal>Accept</literal> 
        and <literal>Block</literal> elements (see below).</para>
        
      <para>Additional database drivers can be uploaded dynamically to the 
        controller. As the controller has no way to check if this is a real 
        JDBC driver or some malicious code hidden a JDBC driver interface, you 
        have to be very careful if you enable this option and anybody can 
        connect from anywhere to your controller.</para>
      <programlisting>
&lt;!ELEMENT Jar EMPTY&gt;
&lt;!ATTLIST Jar
	allowAdditionalDriver (true|false) "true"
&gt;
      </programlisting>

      <para>The Shutdown element defines how the controller can be
      terminated - in order to shutdown the controller properly, we
      have to use the console. Specify if the controller should
      consider shutdown command received by one or the other, and if
      this command can only be received from localhost or not. A
      default configuration would be: </para>
      <programlisting>
&lt;Shutdown&gt;
  &lt;Client allow="true" onlyLocalhost="true"/&gt;
  &lt;Console allow="true" onlyLocalhost="true"/&gt;
&lt;/Shutdown&gt;
      </programlisting>
      <para>This prevents unwanted and unauthorized shutdown calls from remote 
        hosts. Only somebody logged locally on the machine can request a 
        shutdown of the controller. Here is the full description for details: 
        </para>
      <programlisting>
&lt;!ELEMENT Shutdown (Client?,Console?)&gt;

&lt;!ELEMENT Client EMPTY&gt;
&lt;!ATTLIST Client
    allow         (true|false) "true"
    onlyLocalhost (true|false) "true"
&gt;
&lt;!ELEMENT Console EMPTY&gt;
&lt;!ATTLIST Console
    allow (true|false) "true"
    onlyLocalhost (true|false) "true"
&gt;
      </programlisting>

      <para>You can control who can connect to the controller by setting access 
        lists based on IP addresses to accept or block. 
        <literal>defaultConnect</literal> is set in 
        <literal>SecuritySettings</literal> defined above. Default is to accept 
        all connections if no security manager is enabled.</para>
      <programlisting>
&lt;!ELEMENT Accept (Hostname|IpAddress|IpRange)*&gt;
&lt;!ELEMENT Block (Hostname|IpAddress|IpRange)*&gt;

&lt;!ELEMENT Hostname EMPTY&gt;
&lt;!ATTLIST Hostname 
     value CDATA #REQUIRED
&gt;
      </programlisting>

      <para>IpAddress value is an IPv4 address (ex:192.168.1.12):</para>
      <programlisting>
&lt;!ELEMENT IpAddress EMPTY&gt;
&lt;!ATTLIST IpAddress  
     value CDATA #REQUIRED
&gt;
      </programlisting>

      <para>IpRange value is based on IPv4 addresses and has the following 
        form: 192.168.1.*.</para>
      <programlisting>
&lt;!ELEMENT IpRange EMPTY&gt;
&lt;!ATTLIST IpRange  
     value CDATA #REQUIRED
&gt;
      </programlisting>
      
      <para>Here is a full security configuration example:</para>
      <programlisting>
&lt;SecuritySettings defaultConnect="false"&gt;
  &lt;Jar allowAdditionalDriver="true"/&gt;
  &lt;Shutdown&gt;
    &lt;Client allow="true" onlyLocalhost="true"/&gt;
    &lt;Console allow="false"/&gt;
  &lt;/Shutdown&gt;
  &lt;Accept&gt;
    &lt;IpRange value="192.168.*.*"/&gt;
  &lt;/Accept&gt;
&lt;/SecuritySettings&gt;
      </programlisting>
      <para>This setting accepts driver connections only from machines having 
        an IP address starting with 192.168, allows loading of additional 
        drivers via the console, refuses shutdown from the console, but allows 
        it from the local machine.</para>
     </section>
   </section> <!-- End of writing controller configuration section -->
    
    <!-- ========== Configuring the Log ========== -->
    <section id="configuring_the_log">
      <title>Configuring the Log</title>
      <para>C-JDBC uses the <ulink 
        url="http://jakarta.apache.org/log4j/">Log4j</ulink> logging framework. 
        The <filename>log4j.properties</filename> configuration file is located 
        in the <filename class="directory">/c-jdbc/config</filename> directory 
        of your installation. Here is a brief description of the loggers 
        available in the configuration file:</para>
      <itemizedlist>
        <listitem>
          <para><literal>log4j.logger.org.objectweb.cjdbc.core.controller</literal>: 
            Controller related activities mainly for bootstrap and virtual 
            database adding/removal operations.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.xml.Handler</literal>: 
            XML configuration file parsing and handling.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabase</literal>: 
            Virtual database related operations. A specific 
            <literal>log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabase.virtualDatabaseName</literal> 
            logger is automatically created for each virtual database. This 
            allows to tune different logging levels for each virtual 
            database.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabase.request</literal>: 
            Log the incoming requests and transactions in files that can be 
            replayed by the Request Player tool provided with C-JDBC.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.distributedvirtualdatabase.request</literal>
            : Log distributed request execution when using horizontal scalability (a.k.a.
            controller replication).</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.backup</literal>
            : Log backup manager and backuper related activities from dump/restore
            operations.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabaseServerThread</literal>: 
            The server thread accepts client connections and manages the worker 
            threads.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabaseWorkerThread</literal>: 
            Each worker thread handle a session with a client C-JDBC 
            driver.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.RequestManager</literal>: 
            Log the request flows between the different Request Manager 
            components (scheduler, cache, load balancer, recovery log).</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.scheduler</literal>: 
            Log the request ordering and synchronization performed by the 
            scheduler.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.cache</literal>: 
            SQL Query cache related activities.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.loadbalancer</literal>: 
            Log how requests are balanced on the backends.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.connection</literal>: 
            Connection pooling related information.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.recoverylog</literal>: 
            C-JDBC Recovery Log information.</para>
        </listitem>
        <listitem>
          <para>
            <literal>log4j.logger.org.objectweb.cjdbc.controller.console.jmx</literal>: 
            JMX management system logging.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.objectweb.tribe.channels</literal>: 
            Tribe low level group communication channel.</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.objectweb.tribe.gms</literal>: Tribe 
            Group Membership Service (GMS).</para>
        </listitem>
        <listitem>
          <para><literal>log4j.logger.org.objectweb.tribe.discovery</literal>: 
            Tribe Discovery Service (used by GMS).</para>
        </listitem>
        <listitem>
          <para>
            <literal>og4j.logger.org.objectweb.tribe.blocks.multicastadapter</literal>: 
            Tribe Multicast Dispatcher building block for application level 
            message handling.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Recovery Log ========== -->
    <section id="recovery_log">
      <title>Recovery Log</title>
      <para>When you want to add a database to your cluster, you do not want to stop the system,
        replicate the current database state to the new database (that may take a long while)
        and then restart the system. The Recovery Log helps you in the process of dynamically
        adding a new backend (or recovering a previously failed backend) without stopping
        the system.</para>
      <para>The Recovery Log records the write operations and transactions that are
        performed by the C-JDBC controller between checkpoints. A checkpoint is just a
        logical index in the log that reflect the recovery log state at a given time. As of
        C-JDBC 2.0, checkpoints are automatically managed by the controller and are
        generated when needed on behalf of the administrator when a backend is disabled or
        enter a backup phase. When re-enabling the backend, the Recovery Log replays all
        write queries and transactions that the backend missed during the time it was offline
        and it comes back to the enabled state once it is synchronized with the other
        nodes.</para>
      <note>
        <para>Since version 2.0, the backup infrastructure has completely changed and is
          based on Backupers. We provide a generic Backuper based on <ulink
            url="http://octopus.enhydra.org/">Enhydra Octopus</ulink> to copy,
          backup and restore content of backends through JDBC. Even if Octopus is supposed to
          handle most common databases, it might fail for some specific databases or data
          types. In that case, we strongly recommend to use or implement a database specific
          Backuper.</para>
      </note>
      <section>
        <title>A practical example</title>
        <para>Your Web site is running with a single database and you want to use C-JDBC with
          three nodes using full replication (RAIDb-1). You have two new backends ready to be
          installed. You can start the C-JDBC console and connect to the controller. Start
          the administration module by connecting to the virtual database. Type:
          <command>backup
          &lt;backend name&gt; &lt;dump name&gt; &lt;backuper name&gt; &lt;path to
          backup directory&gt;</command>. If you want to use Octopus you will use a command
          line like <command>backup node1 dump1 Octopus /var/backups</command>. During
          the backup, the update requests are logged in the recovery log, so no update is lost.
          If the backend was in the enabled state when backup was initiated, it will
          automatically replay the recovery log to resynchronize itself and return to the
          enabled state.</para>
        <para>To restore the dump on another backend, just type <command>restore
          &lt;newbackend&gt;
          &lt;dumpname&gt;</command> and the appropriate backuper (Octopus in our
          previous example) will be used to restore the dump. After restoring the dump, you
          can enable the backend at any time so that the recovery log replays all the missing
          requests since the dump was taken.</para>
        <para>Here is the set of commands to use in the C-JDBC console if node1 
          is your existing backend and you want to dynamically add node2 and 
          node3:</para>
        <programlisting>
backup node1 initial_dump Octopus /var/backups
restore node2 initial_dump
restore node3 initial_dump
enable node2
enable node3
        </programlisting>
        <note>
          <para>Note that these steps can be automated by scriptin the console.</para>          
        </note>
        <para>If a node crashes, use the administration console to restore the dump on the
          node using the restore command. Once the dump is restored, re-enable the backend
          from the stored checkpoint and the Recovery Log will automatically replay all the
          write queries to rebuild a consistent database state on the node.</para>
        <para>To prevent the recovery log from being too large, you can periodically perform
          backup operations. This will also lower the recovery time since the part of the log
          to replay will be smaller. You can delete older dumps and logs if you do not need them
          anymore.</para>
      </section>
      <section id="understanding_checkpoints">
        <title>Understanding checkpoints</title>
        <para>A checkpoint is a reference used by the recovery log to replay missing
          requests. If a backend is disabled from the console for maintenance, the
          controller will automatically create a checkpoint (prior to v2.0, the checkpoint
          name had to be provided manually through the console). Once the backend is enabled
          again, the controller retrieves its last known checkpoint from the recovery log
          and replays all the requests that the disabled backend missed since it was
          disabled. A checkpoint is nothing more than a reference in time. </para>
      </section>
      <section>
        <title>A fault tolerant Recovery Log</title>
        <para>As the C-JDBC recovery log can be stored in a database providing 
          a JDBC driver, it is possible to make the recovery log fault tolerant 
          by redirecting it to a C-JDBC controller (even self) that will 
          distribute and replicate the log content on several backends.</para>
        <para>The JDBC Recovery Log configuration is detailed in <xref 
          linkend="dtd_recoverylog"/>.</para>
      </section>
    </section>
    
    <!-- ========== Controller replication ========== -->
		<section id="controller_replication">
			<title>Controller replication</title>
      <para>To prevent the C-JDBC controller from being a single point of 
        failure, C-JDBC provides controller replication also called horizontal 
        scalability. A virtual database can be replicated in several 
        controllers that can be added dynamically at runtime. Controllers use 
        the JGroups group communication middleware to synchronize updates in a 
        distributed way. The JGroups stack configuration is found in 
        <filename>config/jgroups.xml</filename> and should not be altered 
        unless you specifically know what you are doing. Keep in mind that 
        total order reliable multicast is needed to ensure proper 
        synchonization of the controllers. More information about JGroups can 
        be found on <ulink url="http://www.jgroups.org">the JGroups web 
        site</ulink>. Note that JGroups requires proper network settings, here 
        are a few guidelines:</para>
      <itemizedlist>
        <listitem>
          <para>a default route must be defined (check with /sbin/route under Linux) for the
            network adapter which is bound by JGroups (usually eth0). If such route does not
            exist, either the group communication initialization will block or
            controllers will not be able to see each other even on the local host. If you don't
            have any default entry in your routing table you can use a command like
            '/sbin/route add default eth0' to define this default route. </para>
        </listitem>
        <listitem>
          <para> issues have been reported with DHCP that can either block (under Windows) or
            just fail to properly set a default route and leads to the issue reported above. We
            strongly discourage the use of DHCP, you should use fixed IP addresses instead.
            </para>
        </listitem>
        <listitem>
          <para> name resolution should be properly set so that the IP address/machine name
            matching works both ways. Often improper /etc/hosts or DNS configuration leads
            to group communication initialization problems. In particular, under Linux,
            the IP address associated to the name returned by the 'hostname' command must not
            resolve to 127.0.0.1 else controllers will not see each other.</para>
        </listitem>
      </itemizedlist>
			<para>In order for a virtual database to be replicated, you must define a 
				<literal>Distribution</literal> element in the virtual database 
				configuration file (see <xref linkend="distribution"/>). There are 
				several constraints for different controllers to replicate a virtual 
				database:</para>
			<itemizedlist>
        <listitem>
          <para>give the list of all controllers that you plan to use for 
            replication of your virtual database in the C-JDBC driver URL. Even 
            if all controllers are not online at all times, the driver will 
            automatically detect the alive controllers: 
            jdbc:cjdbc://node1,node2,node3,node4/myDB</para>
        </listitem>
				<listitem>
					<para>the virtual database must have the same name and use the same 
						groupName (in the Distribution element).</para>
				</listitem>
				<listitem>
					<para>each controller must have its own set of backends and no 
						backends should be shared between controllers (C-JDBC checks the 
						database URLs, having different backend names is not 
						sufficient).</para>
				</listitem>
        <listitem>
          <para>each controller must have its own recovery log, recovery logs 
            cannot be shared. It is possible for a controller not to have a 
            recovery log but this controller will have no recovery 
            capabilities.</para>
        </listitem>
				<listitem>
					<para>the authentication managers must support the same logins.</para>
				</listitem>
				<listitem>
					<para>schedulers and load balancers must implement the same RAIDb 
						configuration.</para>
				</listitem>
				<listitem>
					<para>database schemas (if defined) must be compatible according to 
						the RAIDb level you are using.</para>
				</listitem>
			</itemizedlist>
      <note>
        <para>As backends cannot be shared between controllers, it is not 
          possible to use a SingleDB load balancer with controller replication. 
          If each controller only has a single database backend attached to it, 
          then you must use a RAIDb-1 configuration since in fact you have 2 
          replicated backends in the cluster.</para>
      </note>
			<para>Several configuration file examples are available in the <filename 
				class="directory">doc/examples/HorizontalScalability</filename> 
				directory of your C-JDBC distribution.</para>
      <note>
        <para>You can find more information in the document titled "C-JDBC 
          Horizontal Scalability - A controller replication user guide" 
          available from the C-JDBC web site.</para>
      </note>
		</section>

    <!-- ========== Current Limitations ========== -->
	<section id="current_controller_limitations">
		<title>Current Limitations</title>
		<para>The C-JDBC controller in its 2.0.2 release has the following 
			limitations:</para>
		<itemizedlist>
      <listitem>
        <para>GRANT/REVOKE commands will be sent to the database engines but 
          this will not add or remove users from the virtual database 
          authentication manager.</para>
      </listitem>
			<listitem>
				<para>network partition/reconciliation is not supported,</para>
			</listitem>
			<listitem>
				<para>distributed joins are not supported which means that you 
					must ensure that every query can be executed by at least a 
					single backend,</para>
			</listitem>
			<listitem>
				<para><literal>RAIDb-1ec</literal> and 
					<literal>RAIDb-2ec</literal> levels are not 
					supported,</para>
			</listitem>
		</itemizedlist>
	</section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Administration Console -->
  <!-- =============================================================== -->
  <section id="administration_console">
    <title>Administration console</title>
    <para>The C-JDBC administration console is now based on JMX technologies. The text mode
      console is a JMX client based on the standard RMI connector for JMX but you can also use a
      generic a JMX administration console through HTTP from any web browser to see all the
      MBeans registered in the cjdbc domain. The graphical console is not fully supported and
      only the text console is actively maintained.</para>
	  
	  <para>
		You can start the graphic interface using the console.sh/.bat script.
		If your environment does not support graphic interface, it will automatically revert
		to the text console.
	  </para>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/gui-screenshot.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/gui-screenshot.gif" align="center" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
    <note>
      <para>
        <emphasis>This section is under huge rewriting and will be put up to 
          date soon. Please, do come back and check this soon. 
          </emphasis>
      </para>
    </note>

    <!-- ========== Jmx Notifications ========== -->	
	<section id="jmx_notifications">
		<title>Jmx Notifications List</title>
    <para>Here is a list of the JMX remote notifications generated by C-JDBC.</para>
    <!-- TODO: explain how to listen to these notifications with an sample program
      -->
    <itemizedlist>
      <listitem>
        <para><literal>cjdbc.controller.virtualdatabases.removed</literal> a 
          virtual database has been removed.</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.controller.virtualdatabase.added</literal> a 
          virtual database has been added to the controller</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.dump.list</literal> the 
          list of dump files has been updated</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.added</literal> a backend 
          has been added to the virtual database</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.distributed.controller.added</literal> a 
          controller has joined the group</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.disabled</literal> a 
          backend has been disabled</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.enabled</literal> a 
          backend has been enabled</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.recovering</literal> a 
          backend is recovering a dump file</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.recovery.failed</literal> 
          Recovery of a dump file failed</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.replaying.failed</literal> 
          Recovery log replay failed</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.backingup</literal> a 
          backend is backing up</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.enable.write</literal> a 
          backend is now write enabled</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.removed</literal> a 
          backend has been removed from the virtual database</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.disabling</literal> a 
          backend is now in state disabling (finishing pending transactions and 
          pending requests)</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.unknown</literal> The 
          backend state has been completely lost. Recovery needed</para>
      </listitem>
      <listitem>
        <para><literal>cjdbc.virtualdatabase.backend.replaying</literal> a 
          backend is replaying requests from the recovery log</para>
      </listitem>
    </itemizedlist>
	</section>
	
    <!-- ========== Starting the console ========== -->
    <section id="starting_console">
      <title>Starting the Administration Console</title>
      <para>The <filename class="directory">bin</filename> directory of the 
        C-JDBC distribution contains the scripts to start the console. Unix 
        users must start the console with <command>console.sh -t</command> whereas 
        Windows users have to start <command>console.bat -t</command>.</para>
      <para>The console script accepts several options:</para>
      <itemizedlist>
        <listitem>
          <para><option>-d</option> or <option>--debug</option>: show
          stack trace when error occurs.</para>
        </listitem>
        <listitem>
          <para><option>-f</option> or <option>--file</option>: Use a
          given file as the source of commands instead of reading
          commands interactively.</para>
        </listitem>
        <listitem>
          <para><option>-h</option> or <option>--help</option>:
          displays usage information.</para>
        </listitem>
        <listitem>
          <para><option>-i</option> or <option>--ip</option>: IP
          address of the host name where the JMX Server hosting the
          controller is running (the default is '0.0.0.0').</para>
        </listitem>
        <listitem>
          <para><option>-p</option> or <option>--port</option>:
        JMX/RMI port number of (the default is 1090).</para>
        </listitem>
        <listitem>
          <para><option>-s</option> or <option>--secret</option>:
        Password for JMX connection.</para>
        </listitem>
        <listitem>
          <para><option>-u</option> or <option>--username</option>:
          username for JMX connection.</para>
        </listitem>
        <listitem>
          <para><option>-v</option> or <option>--version</option>:
          displays version information.</para>
        </listitem>
        <listitem>
          <para><option>-t</option> or <option>--text</option>:
          force the console to start in text mode. By default, it will try to start in graphic mode
		  </para>
        </listitem>
      </itemizedlist>

      <para>For example, <command>console.sh -t -i 192.168.0.1 -p
        1234</command> will connect the console to the controller
        using the RMI JMX adaptor listening on port 1234 on
        <literal>192.168.0.1</literal>.</para>

      <para>The console has an online help that is accessible by
        typing <command>help</command> at any time.</para>
    </section>
    <!-- ========== Console Quickstart ========== -->
    <section id="console_quickstart">
      <title>Console Quickstart</title>
      <para>Here is a quick description of the steps needed to make a 
        controller ready to serve requests:</para>
      <orderedlist>
        <listitem>
          <para>Start the controller using <command>controller.sh</command> or 
            <command>controller.bat</command> (see <xref 
            linkend="starting_controller"/>).</para>
        </listitem>
        <listitem>
          <para>Start the console using <command>console.sh -t</command> or 
            <command>console.bat -t</command> (see <xref 
            linkend="starting_console"/>).</para>
        </listitem>
        <listitem>
          <para>Load a configuration file using <command>load 
            &lt;complete-path>/config.xml</command>. The controller 
            configuration files are described in <xref 
            linkend="configuration"/>.</para>
        </listitem>
        <listitem>
          <para>Connect to the virtual database with the administrator login 
            using the <command>admin</command> command (see example 
            below).</para>
        </listitem>
        <listitem>
          <para>Enable all backends using the <command>enableAll</command> 
            command.</para>
        </listitem>
        <listitem>
          <para>Come back to the main menu using the <command>quit</command> 
            command.</para>
        </listitem>
        <listitem>
          <para>Check the configuration using the <command>getInfo</command> 
            command.</para>
        </listitem>
      </orderedlist>
      <para>Here is an example of a controller configuration and startup:</para>
      <programlisting>
<![CDATA[ 
[emmanuel@gre-home bin]$ console.sh -t
Launching the C-JDBC controller console
Initializing Controller module...
Initializing VirtualDatabase Administration module...
Initializing Monitoring module...
Initializing SQL Console module...
C-JDBC driver (v. 2.0) successfully loaded.
  
gre-home:1090 >help
Commands available for the Controller module are:
admin <virtualdatabase name>
   Administrate a virtual database
connect controller <controller hostname> <jmx port>
   Connect to a C-JDBC controller
drop virtualdatabase <virtualdatabase name>
   Drop a virtual database from the controller
help
   Print this help message
history [<commandIndex>]
   Display history of commands for this module
load virtualdatabase config <virtualdatabase xml file>
   Send a virtual database XML configuration file to the controller and load it
monitor <virtualdatabase name>
   Monitor a virtual database
quit
   Quit this console
reload logging configuration
   Refresh the trace system by reloading the logging configuration file
save configuration
   Save the current configuration of the virtual databases as an XML file
show controller config
   Show Controller configuration
show logging config
   Show logging configuration and the most recent traces
show virtualdatabases
   Show the names of the virtual databases for this controller
shutdown [mode]
   Shutdown the controller and all its virtual databases. Mode parameter must be:
        1 -- wait for all client connections to be closed, does not work with a connection pool
        2 -- mode safe, default value, waits for all current transactions to complete
        3 -- mode force, immediate shutdown without consistency: recovery will be needed on restart
sql client <c-jdbc url>
   Open a SQL client console for the virtual database specified by the C-JDBC URL
upload driver <driver file>
   Upload a driver to the controller

gre-home:1090 > <userinput>show virtualdatabases</userinput>
myDB
gre-home:1090 > <userinput>admin myDB</userinput>
Virtual database Administrator Login > <userinput>admin</userinput>
Virtual database Administrator Password > <userinput>*****</userinput>
Ready to administrate virtual database myDB
myDB(admin) > help
Commands available for the VirtualDatabase Administration module are:
backup <backend name> <dump name> <backuper name> <path> [<tables>]
   Backup a backend into a dump file and associate a checkpoint with this dump
delete dump <dump name>
   Delete a dump
disable <backend name | *>
   Disable the specified backend and automatically set a checkpoint
        * means that all backends of this virtual database must be disabled
enable <backend name | *>
   Enable the specified backend
        * means that all backends of this virtual database must be enabled
expert <on|off>
   Switch to expert mode (commands for advanced users are available)
help
   Print this help message
history [<commandIndex>]
   Display history of commands for this module
quit
   Quit this console
restore <backend name> <dump name> [<tables>]
   Starts the recovery process of the given backend for a given dump name
show backend <backend name | *>
   Show information on backend of this virtual database
        * means to show information for all the backends of this virtual database
show backends
   Show the names of the backends of this virtual database on the current controller
show backupers
   Show the backupers available for backup
show controllers
   Show the names of the controllers hosting this virtual database
show dumps
   Show all dumps available for database recovery
show virtualdatabase config
   Show the XML configuration of the virtual database
transfer dump <dump name> <controller name> [nocopy]
   Make a dump available for restore on another controller.
Optional 'nocopy' (default: false) flag specifies not to copy the dump.

myDB(admin) > <userinput>show backend *</userinput>
+--------------------------+-----------------------------------+
| Backend Name             | localhost                         |
| Driver                   | org.hsqldb.jdbcDriver             |
| URL                      | jdbc:hsqldb:hsql://localhost:9001 |
| Active transactions      | 0                                 |
| Pending Requests         | 0                                 |
| Read Enabled             | true                              |
| Write Enabled            | true                              |
| Is Initialized           | true                              |
| Static Schema            | false                             |
| Connection Managers      | 1                                 |
| Total Active Connections | 5                                 |
| Total Requests           | 0                                 |
| Total Transactions       | 0                                 |
| Last known checkpoint    | <unknown>                         |
+--------------------------+-----------------------------------+
| Backend Name             | localhost2                        |
| Driver                   | org.hsqldb.jdbcDriver             |
| URL                      | jdbc:hsqldb:hsql://localhost:9002 |
| Active transactions      | 0                                 |
| Pending Requests         | 0                                 |
| Read Enabled             | true                              |
| Write Enabled            | true                              |
| Is Initialized           | true                              |
| Static Schema            | false                             |
| Connection Managers      | 1                                 |
| Total Active Connections | 5                                 |
| Total Requests           | 0                                 |
| Total Transactions       | 0                                 |
| Last known checkpoint    | <unknown>                         |
+--------------------------+-----------------------------------+
]]>
      </programlisting>
    </section>
    <!-- ========== Console Main Menu ========== -->
    <section id="console_main_menu">
      <title>Console Main Menu</title>
      <para>The graphical version of the console provides a shell-like history 
        (more precisely a tcsh-like behavior). You can recall a previous 
        command by using the arrow keys (up and down) to browse the history. If 
        you prefix a command by <literal>!</literal>, the console will browse 
        the history and complete the command with the latest command in the 
        history starting with the command prefix (completion occurs when you 
        press the tab key). In the graphical version, you can also access all 
        the commands of the different module using the right button of the 
        mouse. </para>
      <note>
        <para>All the commands issued can also be recalled using the history 
          menu in the contextual menu that appears on a right-button 
          click.</para>
      </note>
      <para>Commands available from the console main menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>admin &lt;virtualdatabase name&gt;</command>: Administrate a virtual database</para>
        </listitem>
        <listitem>
          <para><command>connect controller &lt;controller hostname&gt; &lt;jmx port&gt;</command>: connect to a C-JDBC controller</para>
        </listitem>
        <listitem>
          <para><command>drop virtualdatabase &lt;virtualdatabase name&gt;</command>: Drop a virtual database from the controller</para>
        </listitem>
        <listitem>
          <para><command>help</command>:  Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>:  Display history of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>load virtualdatabase config &lt;virtualdatabase xml file&gt;</command>: Send a virtual database XML 
          configuration file to the controller and load it</para>
        </listitem>
        <listitem>
          <para><command>monitor &lt;virtualdatabase name&gt;</command>: Monitor a virtual database</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>reload logging configuration</command>: Refresh the trace system by reloading the logging configuration file</para>
        </listitem>
        <listitem>
          <para><command>save configuration</command>: Save the current configuration of the virtual databases as an XML file</para>
        </listitem>
        <listitem>
          <para><command>show controller config</command>: Show Controller configuration</para>
        </listitem>
        <listitem>
          <para><command>show logging config</command>: Show logging configuration and the most recent traces</para>
        </listitem>
        <listitem>
          <para><command>show virtualdatabases</command>: Show the names of the virtual databases for this controller</para>
        </listitem>
        <listitem>
          <para><command>shutdown [<literal>mode</literal>]</command>: shutdown 
            the controller and all its virtual databases.</para>
          <para>Three shutdown modes are provided. If not specified, the 
            default mode is the shutdown mode immediate.</para>
          <itemizedlist>
            <listitem>
              <para>Shutdown mode wait (mode <literal>1</literal>): wait for 
                all client connections to be closed, does not work if the 
                client uses a connection pool with persistent 
                connections.</para>
            </listitem>
            <listitem>
              <para>Shutdown mode safe (mode <literal>2</literal>): default 
                value, waits for all current transactions to complete before 
                shutting down. transaction and shutdown.</para>
            </listitem>
            <listitem>
              <para>Shutdown mode force (mode <literal>3</literal>): does not 
                wait for transactions completion and kill all connections. 
                Backends are disabled without consistency and a full recovery 
                will be needed on restart.</para>
            </listitem>
          </itemizedlist>
          <para>E.g: <command>shudown 2</command>.</para>
        </listitem>
        <listitem>
          <para><command>sql client &lt;c-jdbc url&gt;</command>: Open a SQL client console for the virtual database specified by the 
          C-JDBC URL</para>
        </listitem>
        <listitem>
          <para><command>upload driver &lt;driver file&gt;</command>: Upload a driver to the controller</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Administrator Menu ========== -->
    <section id="administrator_menu">
      <title>Administrator Menu</title>
      <para>Once the configuration file has been loaded on the controller, all 
        backends are in the disabled state. You must enable them all or one by 
        one to allow them to execute requests. C-JDBC does not check that 
        database contents are synchronized and you must ensure that all 
        backends are in a coherent state prior to starting the controller. To 
        ensure that backends remain synchronized on startup, you must use 
        checkpoints (see <xref linkend="understanding_checkpoints"/>).</para>
        <para>If you properly shutdown the controller using the wait or safe 
          mode, database backend states are properly recorded and their state 
          is automatically restored when they are enabled.</para>
      <section id="administrator_standard_commands">
      <title>Administrator Standard Commands</title>
      <para>Standard commands available from the console administrator menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>backup &lt;backend name&gt; &lt;dump name&gt; &lt;backuper
            name&gt; &lt;path&gt; [&lt;tables&gt;]</command>: Backup a backend into a
            dump file and associate a checkpoint with this dump. Note that the console will
            ask for a login and password to connect to the backend to backup. This is specific
            to the Backuper that you are using but this should usually be a valid
            login/password on the database engine that you are backuping. The login must be
            granted access on all tables from the controller node.</para>
        </listitem>
        <listitem>
          <para><command>delete dump &lt;dump name&gt;</command>: Delete a dump</para>
        </listitem>
        <listitem>
          <para><command>disable &lt;backend name | *&gt;
            &lt;checkpoint&gt;</command>: Disable the specified backend and store the
            given checkpoint (* means that all backends of this virtual database must be
            disabled)</para>
        </listitem>
        <listitem>
          <para><command>enable &lt;backend name | *&gt;</command>: Enable the
            specified backend from its last known checkpoint (* means that all backends of
            this virtual database must be enabled)</para>
        </listitem>
        <listitem>
          <para><command>expert &lt;on|off&gt;</command>: Switch to expert mode
            (commands for advanced users are available)</para>
        </listitem>
        <listitem>
          <para><command>help</command>: Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>: Display history
            of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>restore &lt;backend name&gt; &lt;dump name&gt;
            [&lt;tables&gt;]</command>: Starts the recovery process of the given backend
            using the given dump name. Note that the console will ask for a login and password
            to connect to the backend to restore This is specific to the Backuper that you are
            using but this should usually be a valid login/password (real login in the C-JDBC
            terminology) on the database engine that you are restoring. Note that this login
            must be granted the right to create new databases and tables.</para>
        </listitem>
        <listitem>
          <para><command>show backend &lt;backend name | *&gt;</command>: Show
            information on backend of this virtual database (* means to show information for
            all the backends of this virtual database) </para>
        </listitem>
        <listitem>
          <para><command>show backends</command>: Show the names of the backends of this
            virtual database on the current controller </para>
        </listitem>
        <listitem>
          <para><command>show backupers</command>: Show the backupers available for
            backup</para>
        </listitem>
        <listitem>
          <para><command>show controllers</command>: Show the names of the controllers
            hosting this virtual database</para>
        </listitem>
        <listitem>
          <para><command>show dumps</command>: Show all dumps available for database
            recovery</para>
        </listitem>
        <listitem>
          <para><command>show virtualdatabase config</command>: Show the XML
            configuration of the virtual database</para>
        </listitem>
        <listitem>
          <para><command>transfer dump &lt;dump name&gt; &lt;controller
            name&gt;</command>: Transfer a dump from the current controller to another
            controller. An example is <command>transfer dump dump1
            controller2.emic.com:1090</command></para>
        </listitem>      
      </itemizedlist>
      </section>
      <section id="administrator_expert_commands">
      <title>Administrator Expert Commands</title>
      <para>Expert commands are not available by default. use the command expert on to make them available.</para>
      <itemizedlist>
        <listitem>
          <para><command>clone backend config &lt;backend from&gt; &lt;backend to&gt;
            &lt;url&gt; [driverPath=&lt;value&gt;] [driver=&lt;value&gt;]
            [connectionTestStatement=&lt;value&gt;]</command>: Clone the
            configuration of a backend in the current virtual database (this virtually
            allows to add a new backend)</para>
        </listitem>
        <listitem>
          <para><command>disable read &lt;backend name&gt;</command>: Disable read
            requests on a backend</para>
        </listitem>
        <listitem>
          <para><command>enable read &lt;backend name&gt;</command>: Enable read
            requests on a backend</para>
        </listitem>
        <listitem>
          <para><command>force checkpoint &lt;backend name&gt; &lt;checkpoint
            name&gt;</command>: Force the last know checkpoint of a disabled
            backend</para>
        </listitem>
        <listitem>
          <para><command>force disable &lt;backend name | *&gt;</command>: Force the
            disabling of a backend without storing any checkpoints. The backend will not be
            in a consistent state after this operation! (* means that all backends of this
            virtual database must be disabled by force)</para>
        </listitem>
        <listitem>
          <para><command>force enable &lt;backend name | *&gt;</command>: Force the
            enabling of a backend without checking for checkpoints. This command can break
            the cluster consistency, only use it if you know what you are doing! (* means that
            all backends of this virtual database must be enabled by force)</para>
        </listitem>
        <listitem>
          <para><command>force path &lt;dump name&gt; &lt;new path&gt;</command>:
            Update the path of the dump</para>
        </listitem>
        <listitem>
          <para><command>get backend schema &lt;backend name&gt; &lt;file
            name&gt;</command>: Display backend schema or save it to a file</para>
        </listitem>
        <listitem>
          <para><command>purge log &lt;checkpoint name&gt;</command>: Purge the
            recovery log upto specified checkpoint. All the entries of the recovery log
            prior to that checkpoint will be deleted.</para>
        </listitem>
        <listitem>
          <para><command>restore log &lt;dump name&gt; &lt;controller
            name&gt;</command>: Copy the local recovery log from the specified checkpoint
            onto the specified remote controller. All previous recovery log content on the
            remote controller will be erased.</para>
        </listitem>
        <listitem>
          <para><command>show checkpoints</command>: Show all checkpoints available in
            the recovery log.</para>
        </listitem>
        <listitem>
          <para><command>transfer backend &lt;backend name&gt; &lt;controller jmx
            address&gt;</command>: Transfer a backend from a controller to an other
            controller</para>
        </listitem>
      </itemizedlist> 
      </section>	  
    </section>
	  
	  <!-- Automated Backup with Jmx -->
      <section id="automated_backup_with_jmx">
        <title>Automated Backup With Jmx</title>
        <para>Marc Wick has given an example of a cron file to do a daily backup using the jmx connector in C-JDBC.
	The complete sources can be found in the example file:DBBackup.java in the jmx directory 
	of the examples.
	</para>
        <programlisting>
    JMXServiceURL address = new JMXServiceURL("rmi", host, 0, "/jndi/jrmp");

    Map environment = new HashMap();
    environment.put(Context.INITIAL_CONTEXT_FACTORY,
        "com.sun.jndi.rmi.registry.RegistryContextFactory");
    environment.put(Context.PROVIDER_URL, "rmi://" + host + ":" + port);
    environment.put(JMXConnector.CREDENTIALS, PasswordAuthenticator
        .createCredentials("jmxuser", "jmxpassword"));

    JMXConnector connector = JMXConnectorFactory.connect(address, environment);
    ObjectName db = JmxConstants.getVirtualDbObjectName("databaseName");

    ...
    
    MBeanServerConnection delegateConnection = connector
        .getMBeanServerConnection(subj);

    // we create a proxy to the virtual database
    VirtualDatabaseMBean proxy = (VirtualDatabaseMBean) MBeanServerInvocationHandler
        .newProxyInstance(delegateConnection, db, VirtualDatabaseMBean.class,
            false);

    SimpleDateFormat fmt = new SimpleDateFormat("yyyy_MM_dd");
    String checkpointName = fmt.format(new Date());

    // we disable the backend and set a checkpoint
    proxy.disableBackendForCheckpoint("node1", checkpointName);

    // we call the database specific backup tool for the backup
    runDatabaseBackupTool();

    // we enable the backend again
    proxy.enableBackend("node1");
	</programlisting>
	<para>The runDatabaseBackupTool() method is completely open and can call 
	any external program (like pg_dump, mysql_dump...)
	</para>
	<note>
	<para>This method does not use octopus and as a consequence, the generated 
	backup cannot be restored on a a different database vendor than the one 
	it was issued from.
	As a great benefit though, the backup process will gain in speed, and 
	the metadata will be completely conformed to that database vendor.
	</para>
	</note>
      </section>
	  
    <section id="recovering_from_a_failed_controller_in_distributed_mode">
      <title>Recoverying from a failed controller in distributed mode</title>
      <para> In a distributed controller configuration, when a controller goes down, here is
        the list of action to take to recover the failed controller: </para>
      <itemizedlist>
        <listitem><para>If the controller does not have any dump available, connect to a
          controller that has database dumps and use the <command>transfer dump</command>
          command to copy the dump to the recovering controller.</para>
        </listitem>
        <listitem><para>During its failure, the recovery log of the controller missed
          queries that were executed by the cluster and it is therefore necessary to
          re-synchronize its recovery log. This can be achieve using the <command>recover
          log</command> from the same controller you used to transfer the dump.</para></listitem>
        <listitem><para>Once the previous operations are completed, you can safely
          restore the dump on the backends attached to the controller. Then, enabling the
          backends will resynchronize them with the other nodes of the cluster.</para>
          </listitem>
      </itemizedlist>
    </section>
	  
    </section>
    <!-- ========== Virtual Database Console Menu ========== -->
    <section id="virtual_database_console_menu">
      <title>Virtual Database Console Menu</title>
      <para>C-JDBC is now bundled with a graphical SQL console called Squirrel 
        that you can launch fron the <filename class="directory">bin</filename> 
        directory of the C-JDBC installation, using either 
        <filename>squirrel.sh</filename> or 
        <filename>squirrel.bat</filename>.You can also directly issue SQL 
        statements from the virtual database console menu. The other commands 
        available from the virtual database console menu are:</para>
      <itemizedlist>
        <listitem>
          <para><command>begin</command>:  Start a transaction</para>
        </listitem>
        <listitem>
          <para><command>commit</command>: Commit a transaction</para>
        </listitem>
        <listitem>
          <para><command>fetchsize &lt;x&gt;</command>: Set the ResultSet fetch size to x rows per block</para>
        </listitem>
        <listitem>
          <para><command>help</command>: Print this help message</para>
        </listitem>
        <listitem>
          <para><command>history [&lt;commandIndex&gt;]</command>:  Display history of commands for this module</para>
        </listitem>
        <listitem>
          <para><command>load &lt;file name&gt;</command>:  Execute all SQL statements contained in file</para>
        </listitem>
        <listitem>
          <para><command>maxrows &lt;x&gt;</command>:  Limits the maximum number of rows to get from the database to x</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: Quit this console</para>
        </listitem>
        <listitem>
          <para><command>rollback [&lt;savepoint name&gt;]</command>:  Rollback a transaction (to an optional savepoint)</para>
        </listitem>
        <listitem>
          <para><command>savepoint &lt;savepoint name&gt;</command>:  Create a savepoint for the current transaction</para>
        </listitem>
        <listitem>
          <para><command>setisolation &lt;x&gt;</command>: Set the connection transaction isolation level to x</para>
          <itemizedlist>
            <listitem><para>0 - TRANSACTION_NONE</para>
            </listitem>
            <listitem><para>1 - TRANSACTION_READ_UNCOMMITTED</para>
            </listitem>
            <listitem><para>2 - TRANSACTION_READ_COMMITTED</para>
            </listitem>
            <listitem><para>4 - TRANSACTION_REPEATABLE_READ</para>
            </listitem>
            <listitem><para>8 - TRANSACTION_SERIALIZABLE</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><command>show tables</command>:  Display all the tables of this virtual database</para>
        </listitem>
        <listitem>
          <para><command>timeout &lt;x&gt;</command>: Set the query timeout to x seconds (default is 60 seconds)</para>
        </listitem>
        <listitem>
          <para><command>{call proc_name(?,?,...)}</command>: Call a stored procedure</para>
        </listitem>
       </itemizedlist>
      <para>Here is an example of a session with the virtual database 
        console:</para>
      <programlisting>
localhost:1090 > <command>sql client jdbc:cjdbc://localhost/myDB</command>
 > Login     : <command>user</command>
 > Password  : <command>******</command>
Connected to jdbc:cjdbc://localhost/myDB
jdbc:cjdbc://localhost/myDB (user) > <command>begin</command>
Transaction started
jdbc:cjdbc://localhost/myDB (user) > <command>select * from regions</command>
... result to be displayed here ...
jdbc:cjdbc://localhost/myDB (user) > <command>commit</command>
jdbc:cjdbc://localhost/myDB (user) > <command>quit</command>
      </programlisting>
    </section>
    <!-- ========== Monitoring Console Menu ========== -->
    <section id="monitoring_console_menu">
      <title>Monitoring Console Menu</title>
      <para>Once you have typed <command>monitor</command> in the main console 
        you have now access to the monitor console. You can use 
        <command>settarget <option>database</option></command> to monitor all 
        the resources of a specific virtual database. The available commands in 
        the monitor console are: </para>
      <itemizedlist>
        <listitem>
          <para><command>settarget <option>databasename</option></command>: 
            monitor a specific database. If no target is specified, monitors 
            the controller.</para>
        </listitem>
        <listitem>
          <para><command>help</command>: print this help message.</para>
        </listitem>
        <listitem>
          <para><command>quit</command>: return to the main menu.</para>
        </listitem>
        <listitem>
          <para><command>showstats</command>: display sql statistics in a new 
            frame.</para>
        </listitem>
        <listitem>
          <para><command>showclients</command>: display client information in a 
            new frame.</para>
        </listitem>
        <listitem>
          <para><command>showcache</command>: display cache content in a new 
            frame.</para>
        </listitem>
        <listitem>
          <para><command>showcachestats</command>: display cache stats content 
            in a new frame.</para>
        </listitem>
        <listitem>
          <para><command>showbackends</command>: display backends data in a new 
            frame.</para>
        </listitem>
        <listitem>
          <para><command>showcontroller</command>: show the overall controller 
            load.</para>
        </listitem>
        <listitem>
          <para><command>showdatabases</command>: show the status of the 
            different datases.</para>
        </listitem>
        <listitem>
          <para><command>showscheduler</command>: show the status of the 
            scheduler.</para>
        </listitem>
        <listitem>
          <para><command>closegraph <option>index</option></command>: close the 
            graph at the specified index.</para>
        </listitem>
        <listitem>
          <para><command>trace 
            <option>controller|databases|cache|scheduler|backends</option></command>: 
            Start tracing a graph with live info from the specified 
            target.</para>
        </listitem>
        <listitem>
          <para><command>stoptrace</command>: stop all graph updaters.</para>
        </listitem>
      </itemizedlist>
    </section>
  
  <!-- =============================================================== -->
  <!-- Section: RAIDb Basics -->
  <!-- =============================================================== -->
  <section id="raidb_basics">
    <title>RAIDb Basics</title>
    <!-- ========== RAIDb Definition ========== -->
    <section id="raidb_definitions">
      <title>RAIDb Definition</title>
      <para>RAIDb stands for <emphasis>Redundant Array of Inexpensive 
        Databases</emphasis>. This acronym has been used in reference to the 
        RAID (<emphasis>Redundant Array of Inexpensive Disks</emphasis>) 
        concept that achieves scalability and high availability of disk 
        subsystems at a low cost. RAIDb aims at providing better performance 
        and fault tolerance than a single database by combining multiple 
        inexpensive database instances into an array of databases.</para>
      <para>One of the goals of RAIDb is to hide the distribution complexity 
        and to provide the database clients with the view of a single database. 
        As for RAID, a controller sits in front of the underlying resources. 
        The clients send their requests to the RAIDb controller that balances 
        them among the set of RDBMS backends.</para>
    </section>
    <!-- ========== RAIDb-0 ========== -->
    <section id="raidb0">
      <title>RAIDb-0</title>
      <para>RAIDb-0 consists in <emphasis>partitioning</emphasis> the database 
        tables among the database backend nodes. A table itself cannot be 
        partitionned but the different tables can be distributed on different 
        backend nodes. RAIDb-0 requires at least two database backends, 
        provides moderate performance scalability but does not offer fault 
        tolerance. <xref linkend="fig_raidb-0_example"/> shows an example of a 
        RAIDb-0 configuration.</para>
      <figure id="fig_raidb-0_example">
        <title>RAIDb-0 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== RAIDb-1 ========== -->
    <section id="raidb1">
      <title>RAIDb-1</title>
      <para>RAIDb-1 offers a <emphasis>full mirroring</emphasis> or 
        <emphasis>full replication</emphasis> of the database on the backends. 
        It offers the best fault tolerance scheme since the system is still 
        available with only one backend. On the minus side, there is no speedup 
        on writes (<literal>UPDATE</literal>, <literal>INSERT</literal>, 
        <literal>DELETE</literal> requests) since they have to be broadcasted 
        to all nodes. <xref linkend="fig_raidb-1_example"/> shows an example of 
        a RAIDb-1 configuration.</para>
      <figure id="fig_raidb-1_example">
        <title>RAIDb-1 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== RAIDb-2 ========== -->
    <section id="raidb2">
      <title>RAIDb-2</title>
      <para>RAIDb-2 is a tradeoff between RAIDb-0 and RAIDb-1. It provides 
        partial replication to tune the degree of replication of each database 
        table to obtain the best read/write throughput. RAIDb-2 requires that 
        each database table is available on at least two nodes. <xref 
        linkend="fig_raidb-2_example"/> shows an example of a RAIDb-2 
        configuration.</para>
      <figure id="fig_raidb-2_example">
        <title>RAIDb-2 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-2.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-2.gif" align="center" format="GIF" 
              scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <!-- ========== Nested RAIDb levels ========== -->
    <section id="nested_raidb_levels">
      <title>Nested RAIDb Levels</title>
      <para>It is possible to compose several RAIDb levels to build large scale 
        configurations or meet specific needs. The next example is a RAIDb-1-0 
        configuration where a top level RAIDb-1 controller dispatches the 
        requests to three full databases implemented with a RAIDb-0 controller. 
        <xref linkend="fig_raidb-1-0_example"/> shows an example of a RAIDb-1-0 
        configuration.</para>
      <figure id="fig_raidb-1-0_example">
        <title>RAIDb-1-0 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1-0.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-1-0.gif" align="center" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>This last example (<xref linkend="fig_raidb-0-1_example"/>) shows a 
        RAIDb-0-1 composition. The top level is a RAIDb-0 controller and fault 
        tolerance is achieved on each partition using a RAIDb-1 
        controller.</para>
      <figure id="fig_raidb-0-1_example">
        <title>RAIDb-0-1 example</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RAIDb-0-1.eps" align="center" 
              format="EPS"/>
          </imageobject>
          <imageobject>
            <imagedata align="center" fileref="images/RAIDb-0-1.gif" 
              format="GIF" scalefit="1"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Virtual database configuration -->
  <!-- =============================================================== -->
  <section id="configuration">
    <title>Virtual database configuration</title>
    <!-- ========== Writing a configuration file ========== -->
    <section id="writing_a_virtual_database_configuration_file">
      <title>Writing a Virtual Database Configuration File</title>
      <para>The C-JDBC controller configuration file must conform to the C-JDBC 
        DTD that can be found in the <filename class="directory">xml</filename> 
        directory of the C-JDBC distribution. The DTD is extensively documented 
        and the most up-to-date information will be found in the 
        <filename>xml/c-jdbc-x.y.dtd</filename> file. Several configuration 
        file examples are available in the <filename 
        class="directory">doc/examples</filename> directory.</para>
      <para>Here is an example of how a minimal C-JDBC configuration file 
        should look like:</para>
      <programlisting>
&lt;?xml version="1.0" encoding="UTF8"?>

&lt;!DOCTYPE C-JDBC PUBLIC "-//ObjectWeb//DTD C-JDBC 1.0//EN"
                        "http://www.objectweb.org/c-jdbc/dtds/c-jdbc-2.0.2.dtd">

&lt;C-JDBC> &lt;VirtualDatabase name="vdbName">
&lt;AuthenticationManager> ...  &lt;/AuthenticationManager>

    &lt;DatabaseBackend name="node1" driver="com.myDriver.class"
                     url="jdbc:protocol://host/myDB" connectionTestStatement="select 1">
       ...
    &lt;/DatabaseBackend>

    &lt;RequestManager>
      &lt;RequestScheduler>
         ...
      &lt;/RequestScheduler>

      &lt;LoadBalancer>
         ...
      &lt;/LoadBalancer>
    &lt;/RequestManager>
  &lt;/VirtualDatabase>
&lt;/C-JDBC>
      </programlisting>
      <para>The next sections describes the different elements composing an XML 
        configuration file.</para>
    </section>
    <!-- ========== Virtual Database ========== -->
    <section id="dtd_virtualdatabase">
      <title>Virtual Database</title>
      <para>A virtual database element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT VirtualDatabase (Distribution?, Monitoring?, Backup?,AuthenticationManager, DatabaseBackend+, RequestManager)>     
&lt;!ATTLIST VirtualDatabase 
       name               CDATA #REQUIRED
       maxNbOfConnections CDATA #IMPLIED
       poolThreads        (true | false) "true"
       minNbOfThreads     CDATA #IMPLIED
       maxNbOfThreads     CDATA #IMPLIED
       maxThreadIdleTime  CDATA #IMPLIED
       sqlDumpLength      CDATA "40"
>
      </programlisting>

      <para>A virtual database is the database exposed to the user. It 
        contains:</para>
      <itemizedlist>
        <listitem>
          <para>a set of real database backends,</para>
        </listitem>
        <listitem>
          <para>an authentication manager that matches the virtual database and 
            real backends login/password,</para>
        </listitem>
        <listitem>
          <para>a request manager that defines the behavior of the controller 
            for this virtual database,</para>
        </listitem>
      </itemizedlist>
      <para>Here is a brief description of each virtual database 
        attribute:</para>
      <itemizedlist>
        <listitem>
          <para><literal>name</literal>: name of the virtual database to be 
            used in the JDBC URL 
            (<literal>jdbc:cjdbc://host/<option>VirtualDatabaseName</option></literal>).</para>
        </listitem>
        <listitem>
          <para><literal>maxNbOfConnections</literal>: maximum number of 
            concurrent connections accepted for this virtual database. The 
            controller stops accepting client connections when 
            <literal>maxNbOfConnections</literal> concurrent connections are 
            running. Default is 0 (no limit).</para>
        </listitem>
        <listitem>
          <para><literal>poolThreads</literal>: if <literal>false</literal>, 
            one thread is created for each connection and dies when the 
            connection closes. If set to <literal>true</literal>, threads are 
            created on-demand and kept in a pool to be reused to serve multiple 
            connections. Default is <literal>true</literal>.</para>
        </listitem>
        <listitem>
          <para><literal>minNbOfThreads</literal>: minimum number of threads to 
            keep in the pool (if <literal>poolThreads</literal> is set to 
            <literal>true</literal>). Default is 0.</para>
        </listitem>
        <listitem>
          <para><literal>maxNbOfThreads</literal>: maximum number of threads in 
            the pool (if <literal>poolThreads</literal> is set to 
            <literal>true</literal>). Default is 0 (no limit).</para>
        </listitem>
        <listitem>
          <para><literal>maxThreadIdleTime</literal>: maximum time in seconds a 
            thread can remain idle before being removed from the pool. Default 
            is 60 seconds (a thread that has not serve any request in the past 
            60 seconds will be killed).</para>
        </listitem>
        <listitem>
          <para><literal>sqlDumpLength</literal>: maximum number of characters of a SQL statement to display in
   traces and exception messages. 0 means no limit and the full statement is
   inserted in the message (be careful especially if you are using large 
   objects. Default is 40.</para>
        </listitem>
      </itemizedlist>
    
    <!-- ========== Distribution ========== -->
    <section id="distribution">
    	<title>Distribution</title>
      <para>A Distribution element defines the virtual database distribution 
        rules so that the virtual database can be shared by several C-JDBC 
        controllers (feature called horizontal scalability). A Distribution 
        element is defined as follows:</para>
		  <itemizedlist>
        <listitem>
          <para><literal>groupName</literal>: group name to be used by the JGroups communication layer. If no
     name is provided, the virtual database name is used instead.</para>
        </listitem>
		<listitem>
          <para><literal>macroClock</literal>: if a request contains a date macro that needs to be replaced,
     this attribute defines how the current time is determined. If macroClock
	 is set to none, then each controller uses its local timestamp for all of its
	 backends. If macroClock is set to local, then the macros are replaced using
	 the local time before being sent to remote controllers. Note that in all
	 cases, it is preferable to have controllers synchronized using NTP or an 
	 equivalent mechanism.</para>
        </listitem>
		<listitem>
          <para><literal>castTimeout</literal>: is the timeout to use when sending request to the group.</para>
        </listitem>
		
		</itemizedlist>
      <programlisting>
&lt;!ELEMENT Distribution>
&lt;!ATTLIST Distribution
    groupName  CDATA #IMPLIED
	macroClock (none | local) "local"
	castTimeout CDATA "0"
>
      </programlisting>
      <para><literal>groupName</literal> defines the group name to be used by 
        the JGroups communication layer. If no name is provided, the virtual 
        database name is used as the default group name.
      </para>
      <note>
        <para>The JGroups stack configuration is defined in 
          <filename>config/jgroups.xml</filename>. Refer to the JGroups
          documentation if you want to alter the JGroups configuration.
        </para>
      </note>
      <note>
        <para>When a controller fails, all backends attached to it are 
          automatically disabled. A full recovery process is then needed for 
          these nodes. To learn more about this issue, read the <ulink 
          url="http://c-jdbc.objectweb.org/current/doc/C-JDBC_horizontal_scalability.pdf"> 
          horizontal scalability design document</ulink>.</para>
      </note>
    </section>

    <!-- ========== SQL Monitoring ========== -->
    <section id="dtd_sql_monitoring">
    <title>Monitoring</title>
    
	<note>
		<para>CAREFUL! Monitoring can possibly lead to a memory leak and should only be used on a short period of time
		There is also a JMX method on the VirtualDatabaseMBean to set this on and off while online:	
		</para>
		<programlisting>
			void setMonitoringToActive(boolean active) throws VirtualDatabaseException;
		</programlisting>
	</note>
	
    <para>Monitoring provides a generic section for different monitoring 
      modules. At the moment, only <quote>SQLMonitoring</quote> is provided. 
      </para>
    
    <programlisting>
&lt;!ELEMENT Monitoring (SQLMonitoring*)>

&lt;!ELEMENT SQLMonitoring (SQLMonitoringRule*)>
&lt;!ATTLIST SQLMonitoring
    defaultMonitoring (on | off) "on"
>
    </programlisting>
    
    <para>SQL Monitoring provides statistics (count, error, cache hits, 
      timing) for SQL queries. It is possible to define rules to turn 
      monitoring on or off for specific query patterns.</para>
    <para><literal>defaultMonitoring</literal>: defines the default rule if a 
      request should be monitored (on) or not (off) if no specific rule matches 
      the request. </para>
    
    <programlisting>
&lt;!ELEMENT SQLMonitoringRule EMPTY>
&lt;!ATTLIST SQLMonitoringRule
    queryPattern    CDATA #REQUIRED
    caseSensitive   (true | false) "false"
    applyToSkeleton (true | false) "false"
    monitoring      (on | off) "on"
>
    </programlisting>
    <para>A SQLMonitoringRule Defines a specific monitoring rule for all 
      queries that match the given pattern.</para>
    <itemizedlist>
      <listitem>
        <para><literal>queryPattern</literal>: a regular expression understood 
          by the Jakarta Regexp API. For more information on Regexp format, go 
          to <ulink url="http://jakarta.apache.org/regexp">Jakarta Regexp web 
          site</ulink>.</para>
      </listitem>
      <listitem>
        <para><literal>caseSensitive</literal>: true if the pattern matching 
          must be case sensitive.</para>
      </listitem>
      <listitem>
        <para><literal>applytoSkeleton</literal>: true if the pattern must 
          apply to the query skeleton (found in PrepareStatement), false if the 
          instantiated query should be used. Example: - 
          <emphasis>skeleton</emphasis>: <literal>SELECT * FROM t WHERE 
          x=?</literal> - <emphasis>instantiated query</emphasis>: 
          <literal>SELECT * FROM t WHERE x=12</literal> </para>
      </listitem>
      <listitem>
        <para><literal>monitoring</literal>: on to activate the monitoring for 
          this rule, off to disable it.</para>
      </listitem>
    </itemizedlist>
   
    <para>Examples: </para>
    <itemizedlist>
      <listitem>
        <para><literal>&lt;SQLMonitoring queryPattern="^delete" 
          monitorRequest="off"/></literal> will turn monitoring off for all 
          delete queries. </para>
      </listitem>
      <listitem>
        <para><literal>&lt;SQLMonitoring queryPattern="select * from users *" 
          monitorRequest="on"/></literal> will turn monitoring on for all 
          select queries on the users table. </para>
        <note>
          <para><emphasis>!Warning!</emphasis> This is different from 
            <literal>&lt;SQLMonitoring queryPattern="select \* from users *" 
            monitorRequest="on"/></literal> which turns monitoring on for the 
            "select * from users ..." kind of queries. </para>
        </note>
      </listitem>
    </itemizedlist>
 
    </section>
    
    </section> <!-- End virtual Database -->
	
    <!-- ========== Backup Manager ========== -->
	<section id="dtd_backupmanager">
      <title>Backup Manager</title>
      <para>A Backup Manager defines a number of Backuper in charge of performing
        backup/restore operations on backends. This element is defined as follows:</para>
	  <programlisting>
&lt;!ELEMENT Backup (Backuper+)>

&lt;!ELEMENT Backuper EMPTY>
&lt;!ATTLIST Backuper
    backuperName CDATA #REQUIRED
    className    CDATA #REQUIRED
    options      CDATA #IMPLIED
>
      </programlisting>

    <para> A Backuper is defined by a logical backuperName used by the administration console
      when performing a backup operation. The className specifies the implementation of the
      Backuper. Backuper specific options can be provided as well (this can be the path to a
      properties files or a set of attributes). Check your Backuper documentation for its
      specific options. </para>
    <para>Here is an example to use the Octopus Backuper for a virtual database:</para>
    <programlisting>
&lt;Backup>
  &lt;Backuper backuperName="Octopus" className="org.objectweb.cjdbc.controller.backup.OctopusBackuper"/>
&lt;/Backup>      
    </programlisting>
    <note>
      <para>Octopus does not have access to the C-JDBC classloader for drivers and therefore
        it needs database drivers to be accessible from the controller classpath. A good
        solution is to unjar the drivers in the drivers/ directory of C-JDBC.</para>
      <para>Octopus dumps are by default stored in a compressed .zip format.</para>
    </note>
	</section>
    <!-- ========== Authentication Manager ========== -->
    <section id="dtd_authenticationmanager">
      <title>Authentication Manager</title>
      <para>An authentication manager element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT AuthenticationManager (Admin+, VirtualUsers)>

&lt;!ELEMENT Admin (User+)>

&lt;!ELEMENT User EMPTY>
&lt;!ATTLIST User
    username CDATA #REQUIRED
    password CDATA #REQUIRED
>

&lt;!ELEMENT VirtualUsers (VirtualLogin+)>

&lt;!ELEMENT VirtualLogin (TrustedLogin*)>
&lt;!ATTLIST VirtualLogin 
    vLogin    CDATA #REQUIRED
    vPassword CDATA #REQUIRED
>
&lt;!ELEMENT TrustedLogin EMPTY>
      </programlisting>

      <para>An authentication manager defines:</para>
      <orderedlist>
        <listitem>
          <para>an administrator login to be used by the console to access the 
            virtual database administration menu (see <xref 
            linkend="administrator_menu"/>) that allows enabling the 
            backends,</para>
        </listitem>
        <listitem>
          <para>"virtual logins" that are used by the client application and 
            that are mapped to "real logins" for each backend.</para>
        </listitem>
	<listitem>
          <para>"trusted logins" will be used in the future to allow reusing other form of authentication from
	  within C-JDBC.</para>
        </listitem>
      </orderedlist>
      <para>Here is an example of an authentication manager definition:</para>
      <programlisting>
    &lt;AuthenticationManager>
      &lt;Admin>
      	&lt;User username="admin" password="adminPwd"/>
      &lt;/Admin> 
      &lt;VirtualUsers>
        &lt;VirtualLogin vLogin="user1" vPassword="userPwd1"/>
        &lt;VirtualLogin vLogin="user2" vPassword=""/>
      &lt;/VirtualUsers>
    &lt;/AuthenticationManager>
      </programlisting>
      <para>In this example, the virtual database has one administrator. The admin can use
        the login/password "admin/adminPwd" to log in the console.</para>
      <para>Two virtual logins are defined: <literal>user1</literal> and 
        <literal>user2</literal> with <literal>userPwd1</literal> and no password, 
        respectively. These logins are those used by the client application and 
        given to the C-JDBC driver.</para>
      <para>The connection manager to use with each of the virtual has to be defined
        in the DatabaseBackend section. Each DatabaseBackend has to define a pool
        connection manager for each of the virtual user specified here.
      </para>
    </section>
    <!-- ========== Database Backend ========== -->
    <section id="dtd_databasebackend">
      <title>Database Backend</title>
      <para>Each database backend must be given a unique name (it is a logical 
        name but it is convenient to use the same name as the real machine 
        name). The database schema is automatically gathered from the backend 
        when it is added to the virtual database. However, you can specify a 
        static database schema (refer to <xref linkend="dtd_databaseschema"/>) 
        to be used instead. Finally, a specific connection manager (see <xref 
        linkend="dtd_connectionmanager"/>) defines the connection pooling 
        strategy for each virtual login on each backend.</para>
      <para>A database backend element is defined as follows:</para>
      <programlisting>
&lt;!ELEMENT DatabaseBackend (DatabaseSchema?, RewritingRule*, ConnectionManager+)>
&lt;!ATTLIST DatabaseBackend 
    name                    CDATA #REQUIRED
    driver                  CDATA #REQUIRED
    driverPath              CDATA #IMPLIED
    url                     CDATA #REQUIRED
    connectionTestStatement CDATA #REQUIRED  
>
      </programlisting>
      <para>Here is a brief description of database backend attributes:</para>
      <itemizedlist>
        <listitem>
          <para><literal>name</literal>: the unique logical name identifying 
            this backend.</para>
        </listitem>
        <listitem>
          <para><literal>driver</literal>: the database native JDBC driver 
            class name.</para>
        </listitem>
        <listitem>
          <para><literal>driverPath</literal>: name of the directory or jar 
            file containing the native driver files. If driverPath is omitted, 
            the driver must be in the <filename 
            class="directory">drivers/</filename> directory. If several driver 
            jar files are in the same directory, the first jar file containing 
            the class name specified in the <literal>driver</literal> attribute 
            is used. Note that drivers are loaded in separate classloaders 
            which allows you to use different versions of the same driver on 
            different backends just by specifying the right jar file.</para>
        </listitem>
        <listitem>
          <para><literal>url</literal>: the JDBC URL to connect to this 
            database backend.</para>
        </listitem>	
        <listitem>
          <para><literal>connectionTestStatement</literal>: SQL statement to 
            send on a connection to check if the connection is still valid. 
            This is used when C-JDBC suspects a connection to be broken after 
            the failure of a request. This statement should not update the 
            database because if the connection is still valid the database 
            state should remain the same. Here are the settings for the most 
            popular databases:</para>
          <itemizedlist>
            <listitem>
              <para>for MySQL use <command>select 1</command></para>
            </listitem>
            <listitem>
              <para>for PostgreSQL use <command>select now()</command>.</para>
            </listitem>
            <listitem>
              <para>for Apache Derby use <command>values 1</command>.</para>
            </listitem>
            <listitem>
              <para>for HSQL use <command>call now()</command>.</para>
            </listitem>
            <listitem>
              <para>for SAP DB (MySQL MaxDB) use <command>select count(*) from 
                versions</command>.</para>
            </listitem>
            <listitem>
              <para>for Oracle use <command>select * from dual</command>.</para>
            </listitem>
            <listitem>
              <para>for Firebird use <command>select * from 
                rdb$types</command>.</para>
            </listitem>
            <listitem>
              <para>for InstantDB use <command>set date format 
                "yyyy/mm/dd"</command>.</para>
            </listitem>
            <listitem>
              <para>for Interbase use <command>select * from 
                rdb$types</command>.</para>
            </listitem>
            <listitem>
              <para>for Microsoft SQL server 2000 <command>select 
                1</command>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <para>Here is a complete example of a database backend element including 
        its connection manager definition:</para>
      <programlisting>
&lt;DatabaseBackend name="node1" driver="org.gjt.mm.mysql.Driver"
      url="jdbc:mysql://node1.objectweb.org/rubis" connectionTestStatement="select 1">
  &lt;ConnectionManager vLogin="user1" rLogin="ruser1" rPassword="rpass1">
    &lt;SimpleConnectionManager/>
  &lt;/ConnectionManager>
  &lt;ConnectionManager vLogin="user2" rLogin="ruser1" rPassword="rpass1">
    &lt;VariablePoolConnectionManager initPoolSize="10" 
                                   minPoolSize="5"
                                   maxPoolSize="100"/>
  &lt;/ConnectionManager>
&lt;/DatabaseBackend>
      </programlisting>
    
    <!-- ========== Rewriting Rules Definition ========== -->
    <section id="dtd_rewriting_rules">
    <title>Rewriting requests on backends</title>
    <para>If your cluster is made of database engines from different vendors, 
      client requests might not be understood by all database backends. If your 
      application was written for PostgreSQL and you want to add MySQL 
      backends, some request might have to be adapted to execute correctly on 
      MySQL. You can specify rules to rewrite queries on the fly on a specific
      backend. A RewritingRule element defines how a query matching a given pattern 
      should be rewritten.</para>
    <programlisting>
&lt;!ELEMENT RewritingRule EMPTY>
&lt;!ATTLIST RewritingRule 
    queryPattern  CDATA #REQUIRED
    rewrite       CDATA #REQUIRED
    matchingType  (simple | pattern) "simple"
    caseSensitive (true | false) "false"
    stopOnMatch   (true | false) "false"
>
    </programlisting>
    <itemizedlist>
    	<listitem>
    		<para><literal>queryPattern</literal>: SQL query pattern 
      to match.</para>
    	</listitem>
    	<listitem>
    		<para><literal>rewrite</literal>: rewritten SQL query.</para>
    	</listitem>
    	<listitem>
        <para><literal>matchingType</literal>: <option>simple</option>: means 
          that the first occurrence of queryPattern in the request will be 
          replaced by the string specified in rewrite. 
          <option>pattern</option>: uses a pattern based match/replace. A 
          pattern uses <literal>?x</literal> where x is a logical number 
          assigned to the pattern. Example: <literal>select ?1 from ?2 where 
          x=?3</literal>.</para>
    	</listitem>
    	<listitem>
        <para><literal>caseSensitive</literal>: true if matching must be case 
          sensitive.</para>
    	</listitem>
    	<listitem>
    		<para><literal>stopOnMatch</literal>: rules are applied in the order they are 
      defined. If one rule matches and stopOnMatch is set to true, next rules 
      are ignored. If stopOnMatch is set to false, if another rule matches the 
      rewritten query, the query will be rewritten again.</para>
    	</listitem>
    </itemizedlist>

    <para>Examples: </para>
    <programlisting>
 &lt;RewritingRule queryPattern="from user" rewrite="from &quot;user;&quot;" 
    matchingType="simple"/></programlisting>
    <para>will rewrite the query <literal>select * from user where x=y</literal> as 
 <literal>select * from "user" where x=y</literal>.
    </para>
    <programlisting>
 &lt;RewritingRule queryPattern="select * from t where x=?1" 
    rewrite="select x from y where y=?1" matchingType="pattern"/></programlisting>
    <para>will rewrite the query <literal>select * from t where x=435</literal> to 
  <literal>select x from y where y=435</literal>
    </para>
   
   <programlisting>
 &lt;RewritingRule queryPattern="?1 LIMIT ?2,?3" rewrite="?1 LIMIT ?3,?2" 
    matchingType="pattern"/></programlisting>
    <para>will rewrite the query <literal>select * from t limit 
      10,20</literal> to <literal>select * from t limit 20,10</literal></para>
  
   </section>
    
    <!-- ========== Database Schema Definition ========== -->
    <section id="dtd_databaseschema">
      <title>Database Schema Definition</title>
      
      <para>DatabaseSchema groups static and dynamic definitions for 
        gathering, constructing and validating the in-memory schema used for 
        load balacing and caching.</para>
      <para>A Database schema is defined as follow</para>
         <programlisting>
&lt;!ELEMENT DatabaseSchema (DatabaseStaticSchema?)&gt;
&lt;!ATTLIST DatabaseSchema
 dynamicPrecision (static|table|column|procedures|all) "all"
 gatherSystemTables (true | false) "false"
 schemaName CDATA #IMPLIED
&gt;
       </programlisting>
       
      <itemizedlist>
        <listitem>
          <para><literal>dynamicSchemaPrecision</literal>: if set to 
            <option>static</option>, the controller will not check schemas and 
            stored procedures, it will entirely rely on the statically defined 
            schema. If set to something else than "static" it will get 
            information from the backend to check validity of static schema at 
            given level. <option>table</option> level will check for table 
            names only, <option>column</option> level will check for column 
            names, <option>procedures</option> will gather all executable 
            stored procedures. All, includes all information that can be 
            collected.</para>
        </listitem>
        <listitem>
          <para><literal>gatherSystemTables</literal>: true if system tables 
           and views should be retrieved, false otherwise  (default).</para>
        </listitem>
        <listitem>
          <para><literal>schemaName</literal>: if no schemaName is specified all 
           objects visible to the user are gathered, otherwise only the objects 
           belonging to the specified schema are used. </para>
        </listitem>
      </itemizedlist>
       <note>
        <para>Default option for constructing the schema is to collect all 
          information, even if a static schema is defined especially for 
          checking validity of input. This can be really slow if the database 
          has quite a number of stored procedures defined. </para>
       </note>
         
      <para>A static database schema can be defined to override the schema 
      automatically gathered by the controller. However, the schema must 
      remain compatible with the schema gathered from the backend.</para>
      <para>A database schema element is defined as follows:</para>    
      <programlisting>
&lt;!ELEMENT DatabaseStaticSchema (DatabaseProcedure*,DatabaseTable+)>

&lt;!ELEMENT DatabaseProcedure (DatabaseProcedureParameter*)>
&lt;!ATTLIST DatabaseProcedure 
     name       CDATA #REQUIRED
     returnType (resultUnknown | noResult | returnsResult) "resultUnknown"
>

&lt;!ELEMENT DatabaseTable (DatabaseColumn+)>
&lt;!ATTLIST DatabaseTable 
    tableName   CDATA #REQUIRED
    nbOfColumns CDATA #REQUIRED
>

&lt;!ELEMENT DatabaseColumn EMPTY>
&lt;!ATTLIST DatabaseColumn 
    columnName CDATA #REQUIRED
    isUnique   (true | false) "false"
>
      </programlisting>
      
      <para>The <literal>isUnique</literal> attribute should be set to 
        <literal>true</literal> if the column has a <literal>UNIQUE</literal> 
        constraint. This is the case for primary keys (composed primary keys 
        are not yet supported). This affects only cache behavior and select 
        statements parsing.</para>
      <para>Here is an example of a database schema definition:</para>
      <programlisting>
&lt;DatabaseStaticSchema>
   &lt;DatabaseTable tableName="users" nbOfColumns="10">
      &lt;DatabaseColumn columnName="id" isUnique="true"/>
      &lt;DatabaseColumn columnName="firstname" isUnique="false"/>
      &lt;DatabaseColumn columnName="lastname" isUnique="false"/>
      &lt;DatabaseColumn columnName="nickname" isUnique="false"/>
      &lt;DatabaseColumn columnName="password" isUnique="false"/>
      &lt;DatabaseColumn columnName="email" isUnique="false"/>
      &lt;DatabaseColumn columnName="rating" isUnique="false"/>
      &lt;DatabaseColumn columnName="balance" isUnique="false"/>
      &lt;DatabaseColumn columnName="creation_date" isUnique="false"/>
      &lt;DatabaseColumn columnName="region" isUnique="false"/>
   &lt;/DatabaseTable>

   &lt;DatabaseTable tableName="regions" nbOfColumns="2">
     &lt;DatabaseColumn columnName="id" isUnique="true"/>
     &lt;DatabaseColumn columnName="name" isUnique="false"/>
   &lt;/DatabaseTable>
&lt;/DatabaseStaticSchema>
      </programlisting>
    </section>
    <!-- ========== Connection Managers ========== -->
    <section id="dtd_connectionmanager">
      <title>Connection Manager</title>
      <para>One connection manager must be defined for each virtual login the 
        backend belongs to. The user/password combination defined in the 
        <literal>RealLogin</literal> element for this vLogin/Backend is used to 
        create the connection manager. An example of a connection manager 
        definition is available in <xref linkend="dtd_databasebackend"/>.</para>
      <para>C-JDBC offers several connection managers that are described 
        hereafter:</para>
      <itemizedlist>
        <listitem>
          <para><literal>SimpleConnectionManager</literal>: basic connection 
            manager that opens a new connection on each request and closes it 
            at the end. It is useful if the underlying driver already 
            implements connection pooling for example.</para>
        </listitem>
        <listitem>
          <para><literal>FailFastPoolConnectionManager</literal>: offers 
            connection pooling and fails fast when the pool is empty. 
            <literal>poolSize</literal> is the size of the pool.</para>
          <para>All connections are initialized at startup time and if the pool 
            size is too large it is adjusted to the largest number of 
            connections available. Once the pool is empty, 
            <literal>null</literal> is returned instead of a connection. 
            Therefore incoming requests will fail until at least one connection 
            is freed. No system overload should occur with this connection 
            manager, but if the pool size is too small, many requests will 
            fail.</para>
        </listitem>
        <listitem>
          <para><literal>RandomWaitPoolConnectionManager</literal>: provides 
            connection pooling and wait when the pool is empty until a 
            connection is freed. This connection manager accepts the following 
            attributes:</para>
          <itemizedlist>
            <listitem>
              <para><literal>poolSize</literal>: this is the size of the 
                pool.</para>
            </listitem>
            <listitem>
              <para><literal>timeout</literal>: this is the maximum time in 
                seconds to wait for a connection to be freed. Default is 0 and 
                means no timeout, that is to say that we wait until one 
                connection is freed.</para>
            </listitem>
          </itemizedlist>
          <para>All connections are initialized at startup time and if the pool 
            size is too large it is adjusted to the largest number of 
            connections available. Once the pool is empty, the requests wait 
            until a connection is freed or the specified timeout has elapsed. 
            The FIFO<footnote><para>First In First Out.</para></footnote> order 
            of connection request is not ensured by this connection manager 
            since it relies on the Java wait/notify mechanism.</para>
        </listitem>
        <listitem>
          <para><literal>VariablePoolConnectionManager</literal>: provides 
            connection pooling with a dynamically adjustable pool size. This 
            connection manager accepts the following attributes:</para>
          <itemizedlist>
            <listitem>
              <para><literal>initPoolSize</literal>: initial pool size to be 
                intialized at startup.</para>
            </listitem>
            <listitem>
              <para><literal>minPoolSize</literal>: minimum number of 
                connections to keep in the pool. Default is equal to 
                <literal>initPoolSize</literal>.</para>
            </listitem>
            <listitem>
              <para><literal>maxPoolSize</literal>: maximum number of 
                connections in this pool. Default is 0 and means no 
                limit.</para>
            </listitem>
            <listitem>
              <para><literal>idleTimeout</literal>: time in seconds a 
                connection can stay idle before being released (removed from 
                the pool). Default is 0 and means that once allocated, 
                connections are never released.</para>
            </listitem>
            <listitem>
              <para><literal>waitTimeout</literal>: this is the maximum time in 
                seconds to wait for a connection to be freed. Default is 0 and 
                means no timeout, that is to say that we wait until one 
                connection is freed.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
      <para>The connection manager element complete definition is as 
        follows:</para>
      <programlisting>
&lt;!ELEMENT ConnectionManager (SimpleConnectionManager |
                             FailFastPoolConnectionManager |
                             RandomWaitPoolConnectionManager |
                             VariablePoolConnectionManager)>
&lt;!ATTLIST ConnectionManager 
    Login CDATA #REQUIRED
>

&lt;!ELEMENT SimpleConnectionManager EMPTY>

&lt;!ELEMENT FailFastPoolConnectionManager EMPTY>
&lt;!ATTLIST FailFastPoolConnectionManager
    poolSize CDATA #REQUIRED
>

&lt;!ELEMENT RandomWaitPoolConnectionManager EMPTY>
&lt;!ATTLIST RandomWaitPoolConnectionManager
    poolSize CDATA #REQUIRED
    timeout  CDATA #IMPLIED
>

&lt;!ELEMENT VariablePoolConnectionManager EMPTY>
&lt;!ATTLIST VariablePoolConnectionManager
    initPoolSize CDATA #REQUIRED
    minPoolSize  CDATA #IMPLIED
    maxPoolSize  CDATA #IMPLIED
    idleTimeout  CDATA #IMPLIED
    waitTimeout  CDATA #IMPLIED
>
      </programlisting>
    </section>
    
    </section> <!-- End database backend -->
    
    <!-- ========== Request Manager ========== -->
    <section id="dtd_requestmanager">
      <title>Request Manager</title>
      <para>The request manager is composed of a scheduler (see <xref 
        linkend="dtd_requestscheduler"/>), an optional query cache (see <xref 
        linkend="dtd_requestcache"/>), a load balancer (see <xref 
        linkend="dtd_loadbalancer"/>) and an optional recovery log (see <xref 
        linkend="dtd_recoverylog"/>).</para>
      <para>If requests need to be parsed, it can be done sequentially when 
        needed (<literal>backgroundParsing</literal> is set to 
        <literal>false</literal> which is the default value) or forced to be 
        performed in background by a separate thread (it means a new thread is 
        created for each request that need to be parsed).</para>
      <para>Parsing is by default case insensitive 
        (<literal>caseSensitiveParsing</literal> is set to 
        <literal>false</literal>) which means that table and column names will 
        be matched to the database schema without checking the case. If you 
        want to enforce the parsing to be case sensitive and reject queries 
        that do not use the same case for table and column names as the ones 
        fetched from the database, set <literal>caseSensitiveParsing</literal> 
        to <literal>true</literal>.</para>
      <para>A timeout in seconds can be defined for begin/commit/rollback 
        operations. If no value is given, the default timeout is set to 60 
        seconds. Warning! A value of 0 means no timeout and waits forever until 
        completion.</para>
      <para>The request manager element definition is as follows:</para>
      <programlisting>
&lt;!ELEMENT RequestManager (RequestScheduler, RequestCache?, LoadBalancer, RecoveryLog?)>
&lt;!ATTLIST RequestManager
    backgroundParsing    (true | false) #IMPLIED
    caseSensitiveParsing (true | false) #IMPLIED
    beginTimeout      CDATA #IMPLIED
    commitTimeout     CDATA #IMPLIED
    rollbackTimeout   CDATA #IMPLIED
>
      </programlisting>
      
      <!-- ========== Macros Handler ========== -->
      <section id="dtd_macrohandler">
        <title>Macros Handler</title>
        <para> C-JDBC can interpret and replace on-the-fly macros with a value 
          computed by the controller (the RequestManager in fact). This 
          prevents different backends to generate different values when 
          interpreting the macros which could result in data inconsitencies. 
          The supported macros are the following: </para>
        <itemizedlist>
          <listitem>
            <para><literal>rand</literal>: RAND() can be replaced with an int, long, float or 
              double value.</para>
          </listitem>
	</itemizedlist>
	<para>all the date macros (now, currentDate, currentTime, timeOfDay 
              and currentTimestamp) can be replaced by one of the following: 
        </para>
	<itemizedlist>
          <listitem>    
            <para><literal>off</literal>: do not replace the macro</para>
            <para><literal>date</literal>: java.sql.Date.toString() build from current time at 
              controller (example: 2001-02-17)</para>
            <para><literal>time</literal>: java.sql.Time.toString() build from current time at 
              controller (example: 19:07:32).</para>
            <para><literal>timestamp</literal>: java.sql.Timestamp.toString() build from current 
              time at controller (example: 2001-02-17 19:07:32-05).</para>
          </listitem>
          <listitem>
            <para><literal>timeResolution</literal>:defines the timer precision to 
              use when rewriting a query that contains a date macro. Default is 
              0 millisecond which is the highest precision. A value of 1000 
              corresponds to a 1 second precision, 60000 to a 1 minute 
              precision and so on. </para>
          </listitem>
        </itemizedlist>
	
	<para>The MacroHandling element definition is as follows:</para>
        <programlisting> 
&lt;!ELEMENT MacroHandling EMPTY> 
&lt;!ATTLIST MacroHandling 
        rand (off | int | long | float | double) "float" 
        now  (off | date | time | timestamp) "timestamp" 
        currentDate (off | date | time | timestamp) "date" 
        currentTime (off | date | time | timestamp) "time" 
        timeOfDay (off | date | time | timestamp) "timestamp" 
        currentTimestamp (off | date | time | timestamp) "timestamp" 
        timeResolution CDATA "0" 
> 
         </programlisting>
	 
	 <note>
        <para>A default Macrohandling element is instanciated and used if nothing is
	specified in the configuration file.</para>
       </note>
      </section>
      
      <!-- ===== Request Schedulers ===== -->
      <section id="dtd_requestscheduler">
        <title>Request Scheduler</title>
        <para>The request scheduler is responsible for scheduling the requests 
          and ensuring a serializable execution order. Different schedulers are 
          provided for each RAIDb level (see <xref linkend="raidb_basics"/>). 
          Optimized schedulers are also provided for use with a single database 
          backend (SingleDB configuration).</para>
        <para>The request scheduler element definition is as follows:</para>
	<programlisting>
&lt;!ELEMENT RequestScheduler (SingleDBScheduler | RAIDb-0Scheduler |
                            RAIDb-1Scheduler | RAIDb-2Scheduler)>

&lt;!ELEMENT SingleDBScheduler EMPTY>
&lt;!ATTLIST SingleDBScheduler
    level (passThrough | pessimisticTransaction) #REQUIRED
>

&lt;!ELEMENT RAIDb-0Scheduler EMPTY>
&lt;!ATTLIST RAIDb-0Scheduler 
    level (passThrough | pessimisticTransaction) #REQUIRED
>

&lt;!ELEMENT RAIDb-1Scheduler EMPTY>
&lt;!ATTLIST RAIDb-1Scheduler
    level (passThrough | query | optimisticQuery | optimisticTransaction |
           pessimisticTransaction) #REQUIRED
>

&lt;!ELEMENT RAIDb-2Scheduler EMPTY>
&lt;!ATTLIST RAIDb-2Scheduler
    level (passThrough | query | pessimisticTransaction) #REQUIRED
>
	</programlisting>
        <para>Here is a brief definition of the meaning of each 
          scheduler:</para>
        <itemizedlist>
          <listitem>
            <para><literal>passThrough</literal>: queries are just assigned a 
              unique idnetifier and forwarded as is to the load balancer 
              letting each database perform the scheduling and the locking. 
              Therefore you will obtain the locking granularity provided by 
              the database which should be row-level locking. The load balancer
              will just ensure that the writes are sent in the same order to 
              all backends.</para>
            <para><literal>query</literal>: the query level scheduler is the 
              most basic scheduler that ignores transactions and schedule 
              requests as they come. Reads can execute concurrently but a write 
              blocks every other request execution until it completes. This 
              scheduling might lead to database deadlocks under moderate load. 
              Only use this scheduler if the requests are already scheduled 
              upfront by the application.</para>
          </listitem>
          <listitem>
            <para><literal>optimisticTransaction</literal>: this is an 
              optimistic transactional level scheduler that takes care of 
              scheduling transactions in an optimistic way (writes on different 
              tables can occur in parallel). An optimistic scheduler does not 
              provide deadlock detection to rollback transactions that are 
              deadlocking, but lets the database resolve the deadlocks and 
              rollback the appropriate transactions.</para>
          </listitem>
          <listitem>
            <para><literal>pessimisticTransaction</literal>: this is a 
              pessimistic transactional level scheduler that schedules 
              transactions in a safe way (without possible deadlocks) but 
              providing less parallelism for writes compared to optimistic 
              scheduling (this is only sensitive on write heavy workloads). 
              This is the safest scheduler and it is recommended for most 
              configurations.</para>
          </listitem>
        </itemizedlist>
      </section>
      <!-- ===== Request Caches ===== -->
      <section id="dtd_requestcache">
        <title>Request Cache</title>
        <para>A Request Cache can be composed of different caches that differ 
          in the type of data they cache:</para>
          <itemizedlist>
            <listitem>
              <para><literal>MetadataCache:</literal> this cache improves the 
                ResultSet creation time by keeping the various field 
                information with their metadata. It is strongly encouraged to 
                use this cache that reduces both cpu and memory usage.</para>
            </listitem>
            <listitem>
              <para><literal>ParsingCache:</literal> allows to parse a request 
                only once for all its executions. This reduces the cpu load on 
                the controller.</para>
            </listitem>
            <listitem>
              <para><literal>ResultCache:</literal> this cache keeps the 
                results associated to a given request. Cache entries can be 
                invalidated according to various policies. This cache reduces 
                the load on the database backends.</para>
            </listitem>
          </itemizedlist>
          <para>A RequestCache element is defined as follows:</para>
        <programlisting>
&lt;!ELEMENT RequestCache (MetadataCache?, ParsingCache?, ResultCache?)&gt;
        </programlisting>
        <section id="dtd_metadatacache">
          <title>Metadata Cache</title>
          <para>The MetadataCache caches ResultSet metadata and fields meta 
            information associated to a query execution so that each time a 
            query is executed, we don't have to gather all metadata from the 
            underlying driver and we can build C-JDBC ResultSet much more 
            efficiently both in terms of speed and memory usage. Note that if 
            you use PreparedStatements, the query skeleton is used for matching 
            the cache instead of the instanciated query.</para>
          <para> Example: <literal>SELECT * FROM t WHERE x=?</literal> hits on 
            the same cache entry for all queries of this form for any value of 
            x.</para>
          <para>A MetadataCache element is defined as follows:</para>
          <programlisting>
&lt;!ELEMENT MetadataCache EMPTY&gt;
&lt;!ATTLIST MetadataCache
    maxNbOfMetadata CDATA "10000"
    maxNbOfField    CDATA "0"
&gt;            
          </programlisting>
          <para><literal>maxNbOfMetadata:</literal> maximum number of metadata 
            entries to keep in the cache (default is 10000 and 0 means 
            unlimited)</para>
          <para><literal>maxNbOfField:</literal> maximum number of field 
            entries to keep in the cache (0 means unlimited and is the default 
            setting).</para>
        </section>
        <section id="dtd_parsingcache">
          <title>Parsing Cache</title>
          <para>Parsing requests is a resource consuming process. The 
            ParsingCache caches the result of the parsing processing so that a 
            request is only parsed once for all its executions. If you are 
            using PreparedStatements, the ParsingCache can store the query 
            skeleton meaning that the cached parsing will match any instances 
            of the skeleton. </para>
          <para> Example: <literal>SELECT * FROM t WHERE x=?</literal> will be 
            parsed only once for any value of x.</para>
          <para>A MetadataCache element is defined as follows:</para>
          <programlisting>
&lt;!ELEMENT ParsingCache EMPTY&gt;
&lt;!ATTLIST ParsingCache
    backgroundParsing (true | false) "false"
    maxNbOfEntries    CDATA "5000"       
&gt;            
          </programlisting>
          <para> Request parsing can be done sequentially when needed 
            (backgroundParsing set to false which is the default value) or 
            forced to be performed in background by a separate thread (it means 
            a new thread is created for each request that need to be 
            parsed).</para>
          <para> <literal>maxNbOfEntries:</literal> Defines the maximum number 
            of entries to keep in the cache. The cache uses a LRU (Least 
            Recently Used) replacing policy meaning that the oldest entries 
            from the cache are removed when it is full. Default is 0 and means 
            no limit on cache size. </para>
        </section>
        <section id="dtd_resultcache">
          <title>Result Cache</title>
          <para>The ResultCache caches results of queries. A query and its 
            ResultSet are stored in the cache so that if the sames query is 
            executed, the ResultSet stored in the cache is returned.</para>
          <para>ResultCacheRule elements define the cache coherency and 
            policy. Default cache behavior is eager consistency for all queries 
            (ResultSet returned by the cache are always coherent and 
            up-to-date). See below (ResultCacheRule element) to relax the cache 
            consistency to achieve better performance.
			 Note that ResultSet caching is disabled if no result cache element 
			 is found in the configuration file</para>
          <para>If two exact same requests are to be executed at the same 
            time, only one is executed and the second one waits until the 
            completion of the first one (this is the default 
            <literal>pendingTimeout</literal> value which is 0). To prevent the 
            second request from waiting forever, a 
            <literal>pendingTimeout</literal> value in seconds can be defined 
            for the waiting request. If the timeout expires, the request is 
            executed in parallel with the first one.</para>
          <para>A result cache element is described as follows:</para>
        <programlisting>
&lt;!ELEMENT ResultCache (DefaultResultCacheRule?, ResultCacheRule*)&gt;
&lt;!ATTLIST ResultCache 
    granularity   (database | table | column | columnUnique) "database"
    maxNbOfEntries CDATA "100000"
    pendingTimeout CDATA "0"
&gt;
        </programlisting>
        <para revisionflag="changed">The result cache 
          <literal>granularity</literal> defines how entries are removed from 
          the cache. <literal>database</literal> flush the whole cache on every 
          write access. This is the default cache setting. 
          <literal>table</literal> and <literal>column</literal> provide 
          table-based and column-based invalidations, respectively. 
          <literal>columnUnique</literal> can optimize requests that select a 
          unique primary key (useful with EJB entity beans). </para>
        <para>You can specify the maximum number of entries (default is 100000) 
            to limit the cache size. This is obviously not as efficient as 
            setting a cache size, but in the latter case we would have to spend 
            a lot of time computing size of result sets from queries (Java does 
            not provide a sizeof operator!). We offer size display in bytes 
            when viewing the cache from the console though.</para>
        <para revisionflag="added">Finer grain tuning of the cache is based on 
          rules matching query pattern. A queryPattern are regular expressions 
          to match according to Jakarta Regexp (see <ulink 
          url="http://jakarta.apache.org/regexp">their web site</ulink> for 
          more information). A default cache rule defines the policy if no 
          other rule matches:</para>
        <programlisting>
	&lt;!ELEMENT DefaultResultCacheRule (NoCaching | EagerCaching | RelaxedCaching)&gt;
	&lt;!ATTLIST DefaultResultCacheRule
	    timestampResolution CDATA "1000"
	&gt;
	
	&lt;!ELEMENT ResultCacheRule (NoCaching | EagerCaching | RelaxedCaching)&gt;
	&lt;!ATTLIST ResultCacheRule
	    queryPattern        CDATA #REQUIRED
	    caseSensitive       (true | false) "false"
	    applyToSkeleton     (true | false) "false"
	    timestampResolution CDATA "1000"
	&gt;
        </programlisting>
        <itemizedlist>
        	<listitem>
            <para><literal>queryPattern</literal>: the regular expression to 
              match.</para>
        	</listitem>
        	<listitem>
        		<para><literal>caseSensitive</literal>: true if the pattern matching must 
          be case sensitive</para>
        	</listitem>
        	<listitem>
            <para><literal>applytoSkeleton</literal>: true if the pattern must 
              apply to the query skeleton (found in PrepareStatement), false if 
              the instantiated query should be used. Example: skeleton is 
              <literal>SELECT * FROM t WHERE x=?</literal> and instantiated 
              query is <literal>SELECT * FROM t WHERE x=12</literal>.</para>
        	</listitem>
        	<listitem>
            <para><literal>timestampResolution</literal>: If a query contains a 
              NOW() macro, it is replaced with the current date on the 
              controller. timestampResolution indicates the resolution (in 
              milliseconds) to use when replacing NOW() with the current date. 
              If the resolution is below 1 second (value &lt;1000ms), the 
              request is never kept in the cache because there is almost no 
              chance that the same request will come with the same timestamp. 
              Note that this timestamp is for the cache only and you can use a 
              greater resolution for the load balancer (see below).</para>
        	</listitem>
        </itemizedlist>
        <note>
          <para>If timestampResolution is set to 60000, every execution of a 
            query like <literal>SELECT * FROM x WHERE date=NOW()</literal> will 
            be replaced with the same value for 1 minute (i.e. <literal>SELECT 
            * FROM x WHERE date="2012-11-15 08:03:00.000"</literal>) and 
            therefore the cache entry may be hit for 1 minute. </para>
        </note>
        <para>To define a default rule that disable caching use:</para>
	<programlisting>
&lt;DefaultResultCacheRule&gt;
  &lt;NoCaching/&gt;
&lt;/DefaultResultCacheRule&gt;
	</programlisting>
        <para>If no default rule is provided, the following default rule is 
          assumed:</para>
	
	<programlisting>
&lt;ResultCacheRule queryPattern="default" timestampResolution="1000"&gt;
  &lt;EagerCaching/&gt;
&lt;/ResultCacheRule&gt;
	</programlisting>

        <para>Each cache rule can have a different caching behavior. The 
          available behavior are the following:</para>
	<programlisting>
&lt;!ELEMENT NoCaching EMPTY&gt;
&lt;!ELEMENT EagerCaching EMPTY&gt;
&lt;!ELEMENT RelaxedCaching EMPTY&gt;
&lt;!ATTLIST RelaxedCaching 
     timeout        CDATA "60"
     keepIfNotDirty (true | false) "true"
&gt;
	</programlisting>
        <itemizedlist>
          <listitem>
            <para><literal>NoCaching</literal> means we do not put the match in the cache</para>
          </listitem>
          <listitem>
            <para><literal>EagerCaching</literal> means that all entries in the 
              cache are always coherent and any update query 
              (insert,delete,update,...) will automatically invalidate the 
              corresponding entry in the cache. This was the previous cache 
              behavior for all queries</para>
          </listitem>
          <listitem>
            <para><literal>RelaxedCaching</literal> means that a 
              <option>timeout</option> is set for this entry and the entry is 
              kept in the cache until the timeout expires. When the timeout 
              expires, if no write has modified the corresponding result and 
              <option>keepIfNotDirty</option> is set to true, the entry is kept 
              in the cache and the timeout is rearmed (reset) with its initial 
              value.</para>
          </listitem>
        </itemizedlist>
        <note>
          <para>RelaxedCaching may provide stale data. The timeout defines the 
            maximum staleness of a cache entry. It means that the cache may 
            return an entry that is out of date.</para>
        </note>
        <para>Here is a cache rule example:</para>
	<programlisting>
&lt;ResultCacheRule queryPattern="select ? from b where id=?" applyToSkeleton="true"&gt;
  &lt;RelaxedCaching timeOut="6000" keepIfNotDirty="true"/&gt;
&lt;/ResultCacheRule&gt;
	</programlisting>
	      </section>
      </section>
      <!-- ===== Load Balancers ===== -->
      <section id="dtd_loadbalancer">
        <title>Load Balancer</title>
        <para>The load balancer defines the way requests will be distributed 
          among the backends according to a RAIDb level (see <xref 
          linkend="raidb_basics"/>). The following load balancers are 
          available:</para>
        <itemizedlist>
          <listitem>
            <para><literal>SingleDB</literal>: load balancer for a single 
                database backend instance. This is only available if you use a 
                single controller.</para>
          </listitem>
          <listitem>
            <para><literal>ParallelDB</literal>: load balancer to use with a 
              parallel database such as Oracle Parallel Server or Middle-R. 
              Both read and write are load balanced on the backends, letting 
              the parallel database replicating writes.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-0</literal>: full database partitioning (no 
              table can be replicated) with an optional policy specifying where 
              new tables are created.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-1</literal>: full database mirroring (all 
              tables are replicated everywhere) with an optional policy 
              specifying how distributed queries (writes/commit/rollback) 
              completion is handled (when the first, a majority or all backends 
              complete).</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-1ec</literal>: full database mirroring (like 
              RAIDb-1) with error checking for byzantine failure 
              detection.</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-2</literal>: partial replication (each table 
              must be at least replicated once) with optional policies for new 
              table creation (like RAIDb-0) and distributed queries completion 
              (like RAIDb-1).</para>
          </listitem>
          <listitem>
            <para><literal>RAIDb-2ec</literal>: partial replication (like 
              RAIDb-2) with error checking for byzantine failure 
              detection.</para>
          </listitem>
        </itemizedlist>
        <para>The load balancer element definition is as follows:</para>
	<programlisting>
&lt;!ELEMENT LoadBalancer (SingleDB | ParallelDB | RAIDb-0 | RAIDb-1 | RAIDb-1ec | RAIDb-2 | RAIDb-2ec)>
	</programlisting>
        <!-- ===== SingleDB ===== -->
        <section id="dtd_loadbalancer_SingleDB">
          <title><literal>SingleDB</literal> load balancer</title>
          <para>The <literal>SingleDB</literal> load balancer does not need any 
            specific parameter. The definition of the 
            <literal>SingleDB</literal> element is as follows:</para>
          <programlisting> &lt;!ELEMENT SingleDB EMPTY> </programlisting>
        </section>
        <!-- ===== ParallelDB ===== -->
        <section id="dtd_loadbalancer_ParallelDB">
          <title><literal>ParallelDB</literal> load balancer</title>
          <para>The <literal>ParallelDB</literal> load balancer must be used 
            with a SingleDB request scheduler. This load balancer provides two 
            implementations: <literal>ParallelDB-RoundRobin</literal> and 
            <literal>ParallelDB-LeastPendingRequestsFirst</literal> providing 
            round robin and least pending request first load balancing 
            policies, respectively. ParallelDB load balancers are designed to 
            provide load balancing and failover on top of parallel databases 
            such as Oracle Parallel Server or Middle-R. It means that read and 
            write requuest are just sent to one alive backends, the parallel 
            database being responsible for maintaining the consistency between 
            the backends. The definition of the <literal>ParallelDB</literal> 
            element is as follows:</para>
          <programlisting>
&lt;!ELEMENT ParallelDB (ParallelDB-RoundRobin | ParallelDB-LeastPendingRequestsFirst)>

&lt;!ELEMENT ParallelDB-RoundRobin EMPTY>
&lt;!ELEMENT ParallelDB-LeastPendingRequestsFirst EMPTY>
          </programlisting>
          <para>No specific settings are required for these load balancers.
            They do not require request parsing which means that requests are
            just forwarded as is to the backends (rewriting rules are still
            applied but no automatic transformation is performed).</para>
        </section>
        <!-- == RAIDb-0 == -->
        <section id="dtd_loadbalancer_RAIDb0">
          <title><literal>RAIDb-0</literal> load balancer</title>
          <para>The <literal>RAIDb-0</literal> load balancer accepts a policy 
            to specify where new tables are created. The definition of the 
            <literal>RAIDb-0</literal> element is as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-0 (MacroHandling?,CreateTable*)>

&lt;!ELEMENT CreateTable (BackendName*)>
&lt;!ATTLIST CreateTable 
    tableName     CDATA #IMPLIED
    policy        (random | roundRobin | all) #REQUIRED
    numberOfNodes CDATA #REQUIRED
>
    
&lt;!-- BackendName simply identifies a backend by its logical name -->
&lt;!ELEMENT BackendName EMPTY>
&lt;!ATTLIST BackendName
    name CDATA #REQUIRED
>
</programlisting>
          <para>If <literal>MacroHandling</literal> is omitted, a default MacroHandling element 
	  is added.</para>
          <para><literal>CreateTable</literal> defines the policy to adopt when 
            creating a new table. This policy is based on the given list of 
            <literal>BackendName</literal> nodes (which might be a subset of 
            the complete set of backends). If the backend list is omitted, then 
            all enabled backends are taken at decision time. The attributes 
            have the following meaning:</para>
          <itemizedlist>
            <listitem>
              <para><literal>numberOfNodes</literal> represents the number of 
                backends to pickup from the <literal>BackendName</literal> list 
                to apply the policy (it must be set to 1 for 
                <literal>RAIDb-0</literal> load balancers and can never be 
                greater than the number of nodes declared in the 
                <literal>BackendName</literal> list).</para>
            </listitem>
            <listitem>
              <para><literal>policy</literal> works as follows:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>random</literal>: 
                    <literal>numberOfNodes</literal> backends are picked up 
                    randomly from the <literal>BackendName</literal> list and 
                    the table is created on these nodes.</para>
                </listitem>
                <listitem>
                  <para><literal>roundRobin</literal>: 
                    <literal>numberOfNodes</literal> backends are picked up 
                    from the <literal>BackendName</literal> list using a 
                    round-robin algorithm and the table is created on these 
                    nodes.</para>
                </listitem>
                <listitem>
                  <para><literal>all</literal>: the table is created on 
                    <emphasis>all</emphasis> nodes in the 
                    <literal>BackendName</literal> list 
                    (<literal>numberOfNodes</literal> is ignored).</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist>
          <para>Here is an example of a <literal>RAIDb-0</literal> controller 
            with three nodes where new tables are created randomly on the first 
            two nodes:</para>
	  <programlisting>
...
&lt;DatabaseBackend name="node1" ...
&lt;DatabaseBackend name="node2" ...
&lt;DatabaseBackend name="node3" ...
...

&lt;LoadBalancer>
  &lt;RAIDb-0>
    &lt;CreateTable policy="random" numberOfNodes="1">
      &lt;BackendName name="node1" />
      &lt;BackendName name="node2" />
    &lt;/CreateTable>
  &lt;/RAIDb-0>
&lt;/LoadBalancer>
	  </programlisting>
        </section>
        <!-- == RAIDb-1 == -->
        <section id="dtd_loadbalancer_RAIDb1">
          <title><literal>RAIDb-1:full mirroring </literal> load balancer</title>
          <para>A RAIDb-1 load balancer is defined as follows:</para>

	  <programlisting>
&lt;!ELEMENT RAIDb-1 (WaitForCompletion?, MacroHandling?, (RAIDb-1-RoundRobin | 
           RAIDb-1-WeightedRoundRobin | RAIDb-1-LeastPendingRequestsFirst))>

&lt;!ELEMENT RAIDb-1-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-1-WeightedRoundRobin (BackendWeight)>
&lt;!ELEMENT RAIDb-1-LeastPendingRequestsFirst EMPTY>

&lt;!ELEMENT WaitForCompletion EMPTY>
&lt;!ATTLIST WaitForCompletion
    policy (first | majority | all) "first"
>

&lt;!ELEMENT BackendWeight EMPTY>
&lt;!ATTLIST BackendWeight
    name   CDATA #REQUIRED
    weight CDATA #REQUIRED
>
	  </programlisting>
          <para>If <literal>WaitForCompletion</literal> is omitted, the 
            default behaviour is to return the result as soon as one backend 
            has completed.</para>
	  <para>If MacroHandling is omitted, a default MacroHandling element is added.</para>
          <para>The <literal>RAIDb-1</literal> load balancer accepts a policy 
            to specify distributed queries completion. Several load balancing 
            policies are proposed:</para>
          <itemizedlist>
            <listitem>
              <para><literal>RoundRobin</literal>: simple round-robin load 
                balancing. The first request is sent to the first node, the 
                second request to the second node, etc... Once a request has 
                been sent to the last backend, the next request is sent to the 
                first backend and so on.</para>
            </listitem>
            <listitem>
              <para><literal>WeightedRoundRobin</literal>: same as round-robin 
                but a weight is associated to each backend. A backend that has 
                a weight of 2 will get two times more requests than a backend 
                with a backend with a weight of 1.</para>
            </listitem>
            <listitem>
              <para><literal>LeastPendingRequestsFirst</literal>: the request 
                is sent to the backend that has the least pending requests to 
                execute (that can be considered as the shortest pending request 
                queue).</para>
            </listitem>
          </itemizedlist>
          <para>The definition of the <literal>RAIDb-1</literal> element is as 
            follows:</para>
          <para><literal>WaitForCompletion</literal> defines the policy to 
            adopt when waiting for the completion of a request. Policy works as 
            follows:</para>
          <itemizedlist>
            <listitem>
              <para><literal>first</literal>: returns the result as soon as one 
                node has completed.</para>
            </listitem>
            <listitem>
              <para><literal>majority</literal>: returns the result as soon as 
                a majority of nodes (n/2+1) has completed.</para>
            </listitem>
            <listitem>
              <para><literal>all</literal>: waits for all nodes to complete 
                before returning the result to the client.</para>
            </listitem>
          </itemizedlist>
        </section>
        <!-- == RAIDb-1ec == -->
        <section id="dtd_loadbalancer_RAIDb1ec">
          <title><literal>RAIDb-1ec</literal> load balancer</title>
          <para>The RAIDb-1 with error checking must provide an error checking 
            policy (defined below). The optional 
            <literal>WaitForCompletion</literal> policy only concern write 
            requests (<literal>INSERT</literal>, <literal>DELETE</literal>, 
            <literal>UPDATE</literal>, commit, ...).</para>
          <note>
            <para><literal>RAIDb-1ec</literal> is not operational in C-JDBC 
              v1.0alpha.</para>
          </note>
          <para>The definition of the <literal>RAIDb-1ec</literal> element is 
            as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-1ec (WaitForCompletion?, ErrorChecking, (RAIDb-1ec-RoundRobin | 
                     RAIDb-1ec-WeightedRoundRobin))>
&lt;!ATTLIST RAIDb-1ec
    nbOfConcurrentReads CDATA #REQUIRED
>

&lt;!ELEMENT RAIDb-1ec-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-1ec-WeightedRoundRobin (BackendWeight)>

&lt;!ELEMENT ErrorChecking EMPTY>
&lt;!ATTLIST ErrorChecking 
    policy        (random | roundRobin | all) #REQUIRED
    numberOfNodes CDATA #REQUIRED
>
	  </programlisting>
          <para>Error checking policy (for RAIDb-1ec and RAIDb2-ec). Error 
            checking is used to detect byzantine failures of nodes. It means 
            detecting when a node sends funny results in a non-deterministic 
            way. Error checking allows read queries to be sent to more than one 
            database, and the results are compared. A majority of nodes must 
            agree on the result that will be sent to the client. Error checking 
            policies are defined as follows:</para>
          <itemizedlist>
            <listitem>
              <para><literal>random</literal>: <literal>numberOfNodes</literal> 
                backends are picked up randomly; the read request is sent to 
                these backends and results are compared.</para>
            </listitem>
            <listitem>
              <para><literal>roundRobin</literal>: 
                <literal>numberOfNodes</literal> backends are picked up using a 
                round-robin algorithm ; the read request is send to these 
                backends and results are compared.</para>
            </listitem>
            <listitem>
              <para><literal>all</literal>: the request is sent to 
                <emphasis>all</emphasis> nodes 
                (<literal>numberOfNodes</literal> is ignored) and the results 
                compared.</para>
            </listitem>
          </itemizedlist>
          <para><literal>numberOfNodes</literal> must be greater or equal to 
            3.</para>
        </section>
        <!-- == RAIDb-2 == -->
        <section id="dtd_loadbalancer_RAIDb2">
          <title><literal>RAIDb-2 : distributed mirroring</literal> load balancer</title>
          <para>The definition of the <literal>RAIDb-2</literal> element is as 
            follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-2 (CreateTable*, WaitForCompletion?, MacroHandling?, (RAIDb-2-RoundRobin | 
 RAIDb-2-WeightedRoundRobin | RAIDb-2-LeastPendingRequestsFirst))>


&lt;!ELEMENT RAIDb-2-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-2-WeightedRoundRobin (BackendWeight)>
&lt;!ELEMENT RAIDb-2-LeastPendingRequestsFirst EMPTY>
	  </programlisting>
          
          <para>If MacroHandling is omitted, a default MacroHandling element is added.</para>
          <para>The <literal>RAIDb-2</literal> load balancer accepts a policy 
            to specify where new tables are created and how distributed queries 
            completion should be handled. Several load balancing policies are 
            proposed:</para>
          <itemizedlist>
            <listitem>
              <para><literal>RoundRobin</literal>: simple round-robin load 
                balancing. The first request is sent to the first node, the 
                second request to the second node, etc... Once a request has 
                been sent to the last backend, the next request is sent to the 
                first backend and so on.</para>
            </listitem>
            <listitem>
              <para><literal>WeightedRoundRobin</literal>: same as round-robin 
                but a weight is associated to each backend. A backend that has 
                a weight of 2 will get two times more requests than a backend 
                with a backend with a weight of 1.</para>
            </listitem>
            <listitem>
              <para><literal>LeastPendingRequestsFirst</literal>: the request 
                is sent to the backend that has the least pending requests to 
                execute (that can be considered as the shortest pending request 
                queue).</para>
            </listitem>
          </itemizedlist>
          <para>The <literal>CreateTable</literal> element definition is 
            defined in <xref linkend="dtd_loadbalancer_RAIDb0"/>.</para>
          <para>The <literal>WaitForCompletion</literal> element definition is 
            defined in <xref linkend="dtd_loadbalancer_RAIDb1"/>.</para>
        </section>

        <!-- == RAIDb-2ec == -->
        <section id="dtd_loadbalancer_RAIDb2ec">
          <title><literal>RAIDb-2ec</literal> load balancer</title>
          <para>The RAIDb-2 with error checking must provide an error checking 
            policy as in <literal>RAIDb-1ec</literal> (see <xref 
            linkend="dtd_loadbalancer_RAIDb1ec"/>). The other elements are 
            similar to those defined for <literal>RAIDb-2</literal> controller 
            (see <xref linkend="dtd_loadbalancer_RAIDb2"/>).</para>
          <note>
            <para><literal>RAIDb-2ec</literal> is not operational in C-JDBC 
              v1.0alpha.</para>
          </note>
          <para>The definition of the <literal>RAIDb-2ec</literal> element is 
            as follows:</para>
	  <programlisting>
&lt;!ELEMENT RAIDb-2ec (CreateTable*, WaitForCompletion?, ErrorChecking,
                     (RAIDb-2ec-RoundRobin | RAIDb-2ec-WeightedRoundRobin))>
&lt;!ATTLIST RAIDb-2ec 
    nbOfConcurrentReads CDATA #REQUIRED
>

&lt;!ELEMENT RAIDb-2ec-RoundRobin EMPTY>
&lt;!ELEMENT RAIDb-2ec-WeightedRoundRobin (BackendWeight)>
	  </programlisting>
        </section>
      </section>
      <!-- ===== Recovery Log ===== -->
      <section id="dtd_recoverylog">
        <title>Recovery Log</title>
        <para>The C-JDBC Recovery Log stores write queries and transactions 
          between logical checkpoints defined by the user. The log can be 
          only be stored in a database (or cluster of databases) using a 
          <literal>JDBCRecoveryLog</literal> element.</para>
        <para>The definition of a <literal>RecoveryLog</literal> element is as 
          follows:</para>
	<programlisting>
&lt;!ELEMENT RecoveryLog (JDBCRecoveryLog)>
	</programlisting>
        <section id="dtd_jdbcrecoverylog">
          <title>JDBCRecoverylog</title>
          <para>The JDBCRecoveryLog stores the recovery information in a database. To
            access this database, you must provide the driver class name to load (driver), an
            optional jar file or directory where to find the class to load (driverPath), the
            JDBC url to access the database as well as a valid login/password.</para>
          <para>A timeout in seconds can be defined for the sql requests. If no value is given,
            the default timeout is set to 60 seconds. Warning! 0 means no timeout and wait
            forever until completion.</para>
          <para> recoveryBatchSize is used to speedup the recovery process and allow
            several queries to be accumulated into a batch on the recovering backend.
            Increasing this value beyond a certain limit will not increase performance and
            will consume a significant amount of memory. Default is 10 and minimum is 1.
            </para>
          <para>The recovery information is stored in 3 tables defined in the
            RecoveryLogTable, CheckpointTable and BackendLogTable elements.</para>
          <para>The definition of a <literal>JDBCRecoveryLog</literal> element is as
            follows:</para>
          
          <programlisting>
&lt;!ELEMENT JDBCRecoveryLog (RecoveryLogTable, CheckpointTable, BackendTable)>

&lt;!ATTLIST JDBCRecoveryLog 
    driver            CDATA #REQUIRED
    driverPath        CDATA #IMPLIED
    url               CDATA #REQUIRED
    login             CDATA #REQUIRED
    password          CDATA #REQUIRED
    requestTimeout    CDATA "60"
    recoveryBatchSize CDATA "10"
>
&lt;!ELEMENT RecoveryLogTable EMPTY>
&lt;!ATTLIST RecoveryLogTable 
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "logtable"  
    idColumnType             CDATA "BIGINT NOT NULL UNIQUE"
    vloginColumnType         CDATA "VARCHAR(20) NOT NULL"
    sqlColumnName            CDATA "sql"
    sqlColumnType            CDATA "TEXT NOT NULL"
    transactionIdColumnType  CDATA "BIGINT NOT NULL"
    extraStatementDefinition CDATA ""
>

&lt;!ELEMENT CheckpointTable EMPTY>
&lt;!ATTLIST CheckpointTable 
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "checkpointtable"
    checkpointNameColumnType CDATA "VARCHAR(127) NOT NULL"
    requestIdColumnType      CDATA "BIGINT"
    extraStatementDefinition CDATA ",PRIMARY KEY (name)"
>

&lt;!ELEMENT BackendTable EMPTY>
&lt;!ATTLIST BackendTable 
    createTable                  CDATA "CREATE TABLE"
    tableName                    CDATA "backendtable"  
    databaseNameColumnType       CDATA "VARCHAR(50) NOT NULL"
    backendNameColumnType        CDATA "VARCHAR(50) NOT NULL"
    backendStateColumnType       CDATA "INTEGER"
    checkpointNameColumnType     CDATA "VARCHAR(127) NOT NULL"  
    extraStatementDefinition     CDATA ""
>

&lt;!ELEMENT DumpTable EMPTY>
&lt;!ATTLIST DumpTable
    createTable              CDATA "CREATE TABLE"
    tableName                CDATA "dumptable"
    dumpNameColumnType       CDATA "TEXT NOT NULL"
    dumpDateColumnType       CDATA "TEXT NOT NULL"
    dumpPathColumnType       CDATA "TEXT NOT NULL"
    dumpFormatColumnType     CDATA "TEXT NOT NULL"
    checkpointNameColumnType CDATA "TEXT NOT NULL"  
    backendNameColumnType    CDATA "TEXT NOT NULL"
    tablesColumnType         CDATA "TEXT NOT NULL"
    extraStatementDefinition CDATA ""
>
	  </programlisting>
          <para>The <literal>JDBCRecoveryLog</literal> element requires the following
            attributes:</para>
          <itemizedlist>
            <listitem>
              <para><option>driver</option>: the driver class name</para>
            </listitem>
            <listitem>
              <para><option>url</option>: the JDBC URL to access the database</para>
            </listitem>
            <listitem>
              <para><option>login</option>: the user login to connect to the
                database</para>
            </listitem>
            <listitem>
              <para><option>password</option>: the user password to connect to the
                database</para>
            </listitem>
            <listitem>
              <para><option>requestTimeout</option>: optional timeout request in
                second that will be used to replay the log queries. Default timeout is 60
                seconds and 0 means no timeout (wait forever until a request
                complete).</para>
            </listitem>
            <listitem>
              <para><option>recoveryBatchSize</option>: used to speedup the recovery
                process and allow several queries to be accumulated into a batch on the
                recovering backend. Increasing this value beyond a certain limit will not
                increase performance and will consume a significant amount of memory.
                Default is 10 and minimum is 1. </para>
            </listitem>
          </itemizedlist>
          <para>The <literal>RecoveryLogTable</literal> defines how the
            JDBCRecoveryLog log table is created. The log table name
            (<option>tableName</option>) must conform to the syntax of a database table
            name. The log table stores a unique request id (<option>id</option>), the
            virtual login (<option>vlogin</option>)to use to execute the sql statement
            (<option>sql</option>) in the given transaction
            (<option>transactionId</option>). The statement used by the
            JDBCRecoveryLog to create the log table uses the RecoveryLogTable attributes
            as follows:</para>
          
          <programlisting>
  CREATE TABLE <option>tableName</option> (
    id             <option>idColumnType</option>,
    vlogin         <option>vloginColumnType</option>,
    sql            <option>sqlColumnType</option>,
    transaction_id <option>transactionIdColumnType</option>
    <option>extraStatementDefinition</option>)
    	</programlisting>
          <para>If all default values are used, the log table is created using the following
            statement:</para>
          
          <programlisting>
  CREATE TABLE logTable (
    id             INTEGER NOT NULL UNIQUE, 
    vlogin         VARCHAR (20) NOT NULL, 
    sql            TEXT NOT NULL, 
    transaction_id INTEGER NOT NULL
    )
    	</programlisting>
          <para>The <literal>CheckpointTable</literal> stores the checkpoint name and
            the corresponding index in the recovery log table. The statement used by the
            JDBCRecoveryLog to create the checkpoint table uses the CheckpointTable
            attributes as follows:</para>
          
          <programlisting>
  CREATE TABLE <option>tableName</option> (
    name       <option>checkpointNameColumnType</option>,
    request_id <option>requestIdColumnType</option>
    <option>extraStatementDefinition</option>)
	  </programlisting>
          <para>If all default values are used, the log table is created using the following
            statement:</para>
          
          <programlisting>
  CREATE TABLE checkpointTable (
    name       VARCHAR (20) NOT NULL,
    request_id INTEGER,
    PRIMARY KEY(name))
    	</programlisting>
          
          <para> The <literal>BackendLogTable</literal> stores the states of the
            different backends of a virtual database. It stores the name of the backend, the
            database it belongs to and the last known checkpoint of a backend when the backend
            is disabled, and the state the backend was in when the database was last shutdown.
            If all default values are used, the log table is created using the following
            statement: </para>
          
          <programlisting>
  CREATE TABLE backendTable (
    databaseName VARCHAR(50) NOT NULL,
    backendName  VARCHAR(50) NOT NULL,
    backendState INTEGER,
    checkpointName VARCHAR(50) NOT NULL
    )
  </programlisting>
          
          <para>Here is an example on how to define a JDBCRecoveryLog to work with a HSQL
            database:</para>
          
          <programlisting>
&lt;RecoveryLog>
   &lt;JDBCRecoveryLog driver="org.hsqldb.jdbcDriver" url="jdbc:hsqldb:hsql://localhost" login="sa" password="">
      &lt;RecoveryLogTable 
         tableName="recovery"
         idColumnType="INTEGER NOT NULL" 
         sqlColumnType="VARCHAR NOT NULL" 
        extraStatementDefinition=",PRIMARY KEY (id)"/>
      &lt;CheckpointTable tableName="checkpoint"/>
	  &lt;BackendLogTable tableName="backendTable"/>
   &lt;/JDBCRecoveryLog>
&lt;/RecoveryLog>
          </programlisting>
          <para> The <literal>DumpTable</literal> stores the dump names and associated
            meta-data such as the corresponding checkpoint name. The statement used by the
            JDBCRecoveryLog to create the dump table uses the DumpTable attributes as
            follows:</para>
          
          <programlisting>
  createTable tableName (
    dump_name       dumpNameColumnType,
    dump_date       dumpDateColumnType,
    dump_path       dumpPathColumnType,
    dump_format     dumpTypeColumnType,
    checkpoint_name checkpointNameColumnType,
    backend_name    backendNameColumnType,
    tables          tablesColumnType
    extraStatementDefinition)
            </programlisting>
          <para> dump_name is the dump logical name, dump_date the date at which the backup
            was started, dump_path the path where the dump can be found, dump_format an
            implementation specific text form that specifies the method used for the dump,
            checkpoint_name is the name of the checkpoint associated to this dump, tables is
            the list of tables that are contained in this dump (* means all tables). If all
            default values are used, the log table is created using the following statement:</para>
          <programlisting>
  CREATE TABLE DumpTable (
    dump_name       TEXT NOT NULL,
    dump_date       DATE,
    dump_path       TEXT NOT NULL,
    dump_format     TEXT NOT NULL,
    checkpoint_name TEXT NOT NULL,
    backend_name    TEXT NOT NULL,
    tables          TEXT NOT NULL
    )            
          </programlisting>
          </section>
      </section>
    </section>
    <!-- ========== Configuration Examples ========== -->
    <section id="ssl_configuration">
       <title>SSL Configuration</title>
    	<para>
    	SSL may be used for encryption as well as authentication for all connections to cjdbc.
    	</para>
    	<para>
        SSL support for c-jdbc is based on the Java Secure Socket Extension (JSSE). JSSE has been integrated into the Java 2 SDK, Standard Edition, v 1.4. For java 1.3 it can be installed as an optional package. (available at http://java.sun.com/products/jsse/)
    	</para>
     	<section id="ssl_controller">
           <title>Controller</title>
     	   <para>
           On the controller side ssl can be configured for all jmx connections and the virtual database accessed via the cjdbc driver with the xml element SSL in the controller configuration :
     	   </para>
     	   <programlisting>
              &lt;!ELEMENT SSL EMPTY>
              &lt;!ATTLIST SSL
                  keyStore              CDATA        #IMPLIED
                  keyStorePassword      CDATA        #IMPLIED
                  keyStoreKeyPassword   CDATA        #IMPLIED
                  isClientAuthNeeded    (true|false) "false"
                  trustStore            CDATA        #IMPLIED
                  trustStorePassword    CDATA        #IMPLIED
              >
            </programlisting>
            <itemizedlist>
                <listitem>
                	<para>keyStore: The file where the keys are stored</para>
                </listitem>
                <listitem>
                	<para>keyStorePassword: the password to the keyStore</para>
                </listitem>
                <listitem>
                	<para>keyStoreKeyPassword: the password to the private key, if none is specified the same password as for the store is used</para>
                </listitem>
                <listitem>
                	<para>isClientAuthNeeded: if set to false ssl is used for encryption only, it true set to true then the server is only accepting trusted clients (the client certificate has to be in the trusted store)</para>
                </listitem>
                 <listitem>
                	<para>trustStore: the file where the trusted certificates are stored, if none is specified the same store as for the key is used</para>
                </listitem>
                 <listitem>
                	<para>trustStorePassword: the password to the trustStore, if none is specified the same password as for the keyStore is used</para>
                </listitem>
             </itemizedlist>
        </section>
    	<section id="ssl_console_clients">
            <title>Console / Jmx Clients</title>
     	    <para>
              The console and other jmx clients are configured with the use of java properties :
    	    </para>
            <itemizedlist>
                <listitem>
                	<para>javax.net.ssl.keyStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStorePassword</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStorePassword</para>
                </listitem>
             </itemizedlist>
     	    <para>
              Example :
              -Djavax.net.ssl.trustStore=client.keystore -Djavax.net.ssl.trustStorePassword=clientpassword
    	    </para>
        </section>
    	<section id="ssl_driver">
            <title>Driver</title>
     	    <para>
              SSL on the driver side is configured with java properties 
    	    </para>
            <itemizedlist>
                <listitem>
                	<para>cjdbc.ssl.enabled=true</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.keyStorePassword</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStore</para>
                </listitem>
                <listitem>
                	<para>javax.net.ssl.trustStorePassword</para>
                </listitem>
             </itemizedlist>
     	    <para>
              Example :
              -Djavax.net.ssl.trustStore=client.keystore -Djavax.net.ssl.trustStorePassword=clientpassword
    	    </para>
        </section>
    	<section id="ssl_certficates">
            <title>Certificates (public and private keys)</title>
     	    <para>
              You may create your certificates with the keytool (part of jsse)
    	    </para>
            <orderedlist>
                <listitem><para>
                	Create a self-signed server and a self-signed client key each in its own keystore</para>
                   <programlisting>
$&gt; keytool -genkey -v -keyalg RSA -keystore server.keystore -dname "CN=Server, OU=Bar, O=Foo, L=Some, ST=Where, C=UN"
$&gt; keytool -genkey -v -keyalg RSA -keystore client.keystore -dname "CN=Client, OU=Bar, O=Foo, L=Some, ST=Where, C=UN"
                   </programlisting>
                   
                </listitem>
                <listitem>
                  <para>
                	Export the server's and the client's public keys from their respective keystores</para>
                   <programlisting>
$&gt; keytool -export -rfc -keystore server.keystore -alias mykey -file server.public-key
$&gt; keytool -export -rfc -keystore client.keystore -alias mykey -file client.public-key
                   </programlisting>
                   
                </listitem>
                <listitem>
                  <para>
                	Import the client's public key to the server's keystore, and vice-versa:</para>
                   <programlisting>
$&gt; keytool -import -alias client -keystore server.keystore -file client.public-key
$&gt; keytool -import -alias server -keystore client.keystore -file server.public-key
                   </programlisting>
                   
                </listitem>
             </orderedlist>
         </section>
    </section>
    <!-- ========== Configuration Examples ========== -->
    <section id="configuration_examples">
      <title>Configuration Examples</title>
      <para>Configuration files examples are available in the C-JDBC 
        distribution in the <filename 
        class="directory">/c-jdbc/doc/examples</filename> directory.</para>
      <para>Here is a brief overview of each example content:</para>
      <itemizedlist>
        <listitem>
          <para><filename>Cache</filename>: gives various configuration examples on
            how to use the cache.</para>
        </listitem>
        <listitem>
          <para><filename>Derby</filename> : contains examples for the Apache Derby
            database including the ones used in the ApacheCon demos.</para>
        </listitem>
        <listitem>
          <para><filename>HorizontalScalbility</filename> : provides configuration
            files to create a distributed virtual database on 2 controllers. One file should
            be loaded on each of the two controllers.</para>
        </listitem>
        <listitem>
          <para><filename>LinuxService</filename> and <filename>SuSE</filename> :
            contains examples to run C-JDBC controller as a Linux service.</para>
        </listitem>
        <listitem>
          <para><filename>SingleDB</filename>: a C-JDBC configuration with a unique
            MySQL backend.</para>
        </listitem>
        <listitem>
          <para><filename>RAIDb-0</filename>: C-JDBC configuration examples for
            RAIDb-0.</para>
          <itemizedlist>
            <listitem>
              <para><filename>RAIDb-0.xml</filename>: a simple 2 nodes RAIDb-0
                configuration.</para>
            </listitem>
            <listitem>
              <para><filename>RAIDb-0-schema.xml</filename>: a 2 nodes RAIDb-0
                configuration using a static database schema definition matching the
                RUBiS benchmark database schema.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><filename>RAIDb-1</filename>: contains various RAIDb-1 configuration
            examples.</para>
        </listitem>
        <listitem>
          <para><filename>RAIDb-2</filename>: contains various RAIDb-2 configuration
            examples.</para>
        </listitem>
        <listitem>
          <para><filename>RecoveryLog</filename>: gives an example of a fault tolerant
            recovery log.</para>
        </listitem>
      </itemizedlist>
      </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Request Player -->
  <!-- =============================================================== -->
  <section id="request_player">
    <title>Request Player</title>
    <para>C-JDBC comes with a tool called 'Request Player' that allows to 
      replay queries that have been recorded using the logging facility of the 
      controller. This is useful for both debugging and performance 
      tuning.</para>
    <section id="recording_a_request_trace">
      <title>Recording a request trace</title>
      <para>There is a specific logger in the 
        <filename>log4j.properties</filename> configuration file is located in 
        the <filename class="directory">/c-jdbc/config</filename> directory of 
        your installation. To learn more about configuring the log report to 
        <xref linkend="configuring_the_log"/>. To turn on the request tracing, 
        update your <filename>log4j.properties</filename> with the following 
        logger declaration:</para>
      <programlisting>
# To trace requests #
log4j.logger.org.objectweb.cjdbc.controller.VirtualDatabase.request=INFO, Requests
log4j.additivity.org.objectweb.cjdbc.controller.VirtualDatabase.request=false
      </programlisting>
      <para>The trace file is stored as defined in the logger definition. Here 
        is the default definition that is shipped with C-JDBC:</para>
      <programlisting>
log4j.appender.Requests=org.apache.log4j.RollingFileAppender
log4j.appender.Requests.File=request.log
log4j.appender.Requests.MaxFileSize=100MB
log4j.appender.Requests.MaxBackupIndex=5
log4j.appender.Requests.layout=org.apache.log4j.PatternLayout
log4j.appender.Requests.layout.ConversionPattern=%d{ABSOLUTE} %c{1} %m\n
      </programlisting>
      <para>You can set the trace file name (you can also provide a path) in 
        the <option>log4j.appender.Requests.File</option> property. The 
        <option>log4j.appender.Requests.MaxFileSize</option> property defines 
        the maximum trace file size. Finally, 
        <option>log4j.appender.Requests.MaxBackupIndex</option> defines the 
        number of trace files that will be generated. For example, in the above 
        configuration, the trace will be made of 5 files of 100MB.</para>
      <para>The file format expected by the request player is as follows:</para>
      <para>
        <literal>date virtualDatabaseName requestType transactionId 
          SQL</literal>
      </para>
      <para><literal>requestType</literal> is <option>B</option> for begin, 
        <option>S</option> for select statements, <option>W</option> for write 
        statements (insert, update, delete, create, drop), <option>C</option> 
        for commit and <option>R</option> for rollback.</para>
      <para>Here is an example of a trace of transaction n?27562:</para>
      <programlisting>
10:34:22,775 tpcw B 27562
10:34:22,776 tpcw S 27562 select count(*) from shopping_cart_line where scl_sc_id = 424
10:34:22,778 tpcw S 27562 select i_related1 from item where i_id = 5759
10:34:22,779 tpcw S 27562 select scl_qty from shopping_cart_line where scl_sc_id = 424 and scl_i_id = 4903
10:34:22,781 tpcw W 27562 insert into shopping_cart_line (scl_sc_id, scl_qty, scl_i_id) values (424,1,4903)
10:34:22,782 tpcw W 27562 update shopping_cart set sc_time = now() where sc_id = 424
10:34:22,783 tpcw S 27562 select * from shopping_cart_line, item where scl_i_id = item.i_id and scl_sc_id = 424
10:34:22,787 tpcw C 27562
      </programlisting>
    </section>
    <section id="replaying_a_trace_file">
      <title>Replaying a trace file</title>
      <para>The Request Player allows you to replay a trace file conforming to 
        the format described in the previous section. The Request Player 
        behavior is defined in a property file. The default property file is 
        <filename>requestplayer.properties</filename> located in the <filename 
        class="directory">/c-jdbc/config</filename> directory of your 
        installation. The format of this file is described in <xref 
        linkend="requestplayer.properties"/>.</para>
      <para>The <filename class="directory">bin</filename> directory of the 
        C-JDBC distribution contains the scripts to start the Request Player. 
        Unix users must start the controller with 
        <command>requestplayer.sh</command> whereas Windows users will use 
        <command>requestplayer.bat</command>. These scripts accepts the 
        following options:</para>
      <itemizedlist>
        <listitem>
          <para><option>-h</option> or <option>--help</option> displays a help 
            message.</para>
        </listitem>
        <listitem>
          <para><option>-f</option> or <option>--file</option> followed by the 
            property file name. If this option is omitted, the default file is 
            <filename>requestplayer.properties</filename> located in the 
            <filename class="directory">/c-jdbc/config</filename> directory of 
            your installation.</para>
        </listitem>
        <listitem>
          <para><option>-v</option> or <option>--version</option> displays 
            version information.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="requestplayer.properties">
      <title>requestplayer.properties</title>
      <para>The Request Player properties file defines the following 
        properties:</para>
      <itemizedlist>
        <listitem>
          <para><option>db_driver</option>: Database driver class (an example 
            is <literal>org.objectweb.cjdbc.driver.Driver</literal>).</para>
        </listitem>
        <listitem>
          <para><option>db_url</option>: Database JDBC URL (an example is 
            <literal>jdbc:cjdbc://localhost/test</literal>).</para>
        </listitem>
        <listitem>
          <para><option>db_username</option>: the login to use to connect to 
            the database.</para>
        </listitem>
        <listitem>
          <para><option>db_password</option>: the password to use to connect to 
            the database.</para>
        </listitem>
        <listitem>
          <para><option>trace_file</option>: the full path and name of the 
            request trace file to replay (an example is 
            <literal>/tmp/request.log</literal>).</para>
        </listitem>
        <listitem>
          <para><option>nb_requests</option>: the number of requests to replay 
            or 0 if the full trace file has to be played. Note that once the 
            specified number of requests has been reached, all opened 
            transactions are played by the player until they finish. Therefore, 
            there might be more requests executed than the number specified in 
            this property.</para>
        </listitem>
        <listitem>
          <para><option>nb_clients</option>: number of emulated clients that 
            will issue the requests in parallel (number of threads in the 
            player).</para>
        </listitem>
        <listitem>
          <para><option>timeout</option>: request timeout in seconds, a value 
            of 0 meaning no timeout.</para>
        </listitem>
        <listitem>
          <para><option>connection_type</option>: any value in 
            <option>standard</option>, <option>fixed</option> or 
            <option>pooling</option>. If <option>standard</option> is chosen, a 
            new connection is used for each transaction or for each non 
            transactionnal request to execute. If <option>fixed</option> is 
            chosen, one connection is dedicated to each client thread for the 
            whole run. If <option>pooling</option> is set, connection pooling 
            is used.</para>
        </listitem>
        <listitem>
          <para><option>poolsize</option>: size of the pool if 
            <literal>connection_type</literal> has been set to 
            <option>pooling</option>.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <!-- =============================================================== -->
  <!-- Section: Glossary -->
  <!-- =============================================================== -->
  <section id="glossary">
    <title>Glossary</title>
    <para><xref linkend="glossary_table"/> summarizes all the acronyms used in 
      this document.</para>
    <table id="glossary_table">
      <title>List of acronyms used in this document</title>
      <tgroup cols="2">
        <tbody>
          <row>
            <entry>C-JDBC</entry>
            <entry>Clustered Java DataBase Connectivity</entry>
          </row>
          <row>
            <entry>CVS</entry>
            <entry>Concurrent Versions System</entry>
          </row>
          <row>
            <entry>INRIA</entry>
            <entry>French National Institute for Research in Computer Science 
              and Control</entry>
          </row>
          <row>
            <entry>JDBC</entry>
            <entry>Java DataBase Connectivity (not officially recognized as 
              such)</entry>
          </row>
          <row>
            <entry>JMX</entry>
            <entry>Java Management eXtensions</entry>
          </row>
          <row>
            <entry>JRE</entry>
            <entry>Java Runtime Environment</entry>
          </row>
          <row>
            <entry>JVM</entry>
            <entry>Java Virtual Machine</entry>
          </row>
          <row>
            <entry>LGPL</entry>
            <entry>GNU Lesser General Public License</entry>
          </row>
          <row>
            <entry>RAIDb</entry>
            <entry>Redundant Array of Inexpensive Databases</entry>
          </row>
          <row>
            <entry>RDBMS</entry>
            <entry>Relational DataBase Management System</entry>
          </row>
          <row>
            <entry>RMI</entry>
            <entry>Remote Method Invocation</entry>
          </row>
          <row>
            <entry>SQL</entry>
            <entry>Standard Query Language</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  <!-- =============================================================== -->
  <!-- Section: About C-JDBC -->
  <!-- =============================================================== -->
  <section id="about_c_jdbc">
    <title>About C-JDBC</title>
    <!-- ========== License ========== -->
    <section id="license">
      <title>License</title>
      <para>C-JDBC is free software. You can redistribute it and/or modify it 
        under the terms of the <ulink 
        url="http://www.gnu.org/copyleft/lesser.html">GNU Lesser General Public 
        License</ulink> (LGPL) as published by the <ulink 
        url="http://www.fsf.org/">Free Software Foundation</ulink>; either 
        version 2.1 of the License, or any later version.</para>
      <para>C-JDBC is copyrighted by the <ulink 
        url="http://www.inria.fr/">French National Institute For Research In 
        Computer Science And Control</ulink> (INRIA) and Emic Networks.</para>
    </section>
    <!-- ========== Web Site ========== -->
    <section id="web_sites">
      <title>Web Site</title>
      <para>The C-JDBC project is hosted by ObjectWeb at the following URL: 
        <ulink url="http://c-jdbc.objectweb.org/"/>. To facilitate the 
        development, a C-JDBC project has also be created on the <ulink 
        url="http://forge.objectweb.org/">ObjectWeb Forge</ulink> facility (the 
        ObjectWeb Consortium's own installation of GForge). The main 
        project page can be found at: <ulink 
        url="http://forge.objectweb.org/projects/c-jdbc/"/>.</para>
    </section>
    <!-- ========== C-JDBC Wiki ========== -->
    <section id="wiki">
      <title>Wiki</title>
      <para>There is also a Wiki for the C-JDBC project at the following URL: 
        <ulink url="http://wiki.objectweb.org/c-jdbc/"/>. You can share ideas 
	and information there. You can also comment on the design of the code,
	bring new concepts and ideas ...</para>
    </section>
    
    <!-- ========== Mailing Lists ========== -->
    <section id="mailing_lists">
      <title>Mailing Lists</title>
      <para>Two mailing lists are currently available for C-JDBC. Both lists 
        are archived for public review at the <ulink 
        url="http://c-jdbc.objectweb.org/">C-JDBC's Web site</ulink>.</para>
      <itemizedlist>
        <listitem>
          <para><email>c-jdbc@objectweb.org</email> is the user mailing list. 
            It is the source to get the latest information about C-JDBC, send 
            your feedback and get support from the C-JDBC community.</para>
        </listitem>
        <listitem>
          <para><email>c-jdbc-commits@objectweb.org</email> is a developper 
            mailing list that reports every commit in the C-JDBC CVS 
            repository.</para>
        </listitem>
      </itemizedlist>
      <para>Feedback is crucial to improve C-JDBC. Please send us your comments 
        or any other form of input to: 
        <email>c-jdbc@objectweb.org</email>.</para>
    </section>
    <!-- ========== Reporting a Bug ========== -->
    <section id="reporting_bug">
      <title>Reporting a Bug</title>
      <para>The <ulink 
        url="http://forge.objectweb.org/projects/c-jdbc/">ObjectWeb Forge 
        C-JDBC project page</ulink> provides support for bug tracking. We 
        strongly encourage you to use the automatic Report feature (see <xref 
        linkend="dtd_controller_report"></xref>) that provides all the details 
        we usually need to figure out what happened. If you cannot use this 
        feature, please include the following information when reporting a bug 
        (when applicable):</para>
      <itemizedlist>
        <listitem>
          <para>The C-JDBC driver and controller version.</para>
        </listitem>
        <listitem>
          <para>The XML file you used to configure the C-JDBC controller.</para>
        </listitem>
        <listitem>
          <para>JDK vendor and version (example: Sun JDK 1.3.1_06). If you use 
            different JDK for driver and controller, please give as much detail 
            as possible.</para>
        </listitem>
        <listitem>
          <para>OS vendor and version (examples: Linux 2.4.19 or <trademark 
            class="registered">Windows XP</trademark>). If you use different 
            operating systems for clients, controllers and backends, give the 
            appropriate information.</para>
        </listitem>
        <listitem>
          <para>Database backend version and driver (example: MySQL 4.0.8 Linux 
            with mm.mysql driver 2.0.14).</para>
        </listitem>
        <listitem>
          <para>Detailed error description with possibly the exception stack 
            trace or a logging trace with debugging enabled.</para>
        </listitem>
      </itemizedlist>
    </section>
    <!-- ========== Getting Involved ========== -->
    <section id="getting_involved">
      <title>Getting Involved</title>
      <para>C-JDBC is an open source project and welcomes external 
        contributions. Please read the C-JDBC Developper's Guide and join 
        us!</para>
      <para>Basically, any feature you need but you do not find implemented in 
        C-JDBC may become a contribution topic. Simply send your ideas, 
        documents and developments (if any) to the 
        <email>c-jdbc@objectweb.org</email> mailing list. You may also wish to 
        get involved in an already undertaken work. The list of hot topics is 
        available at the <ulink 
        url="http://forge.objectweb.org/projects/c-jdbc/">C-JDBC's ObjectWeb 
        Forge site</ulink>. Please use also the SourceForge tools for feature 
        requests and bug reports/fixes.</para>
      <para>You can finally subscribe to the <ulink 
        url="http://www.objectweb.org/wws/admin/c-jdbc-commits">c-jdbc-commits</ulink> 
        mailing list if you want to receive notifications of the CVS 
        changes.</para>
    </section>
    <!-- ========== About INRIA ========== -->
    <section id="about_inria">
      <title>About INRIA</title>
      <para><ulink url="http://www.inria.fr/">INRIA</ulink> is the French 
        National Institute for Research in Computer Science and Control. The 
        <ulink url="http://sardes.inrialpes.fr/">Sardes project</ulink> at 
        INRIA Rhones-Alpes has defined the RAIDb concept and leads the C-JDBC 
        project developments.</para>
    </section>
    <!-- ========== About ObjectWeb ========== -->
    <section id="about_objectweb">
      <title>About ObjectWeb</title>
      <para>The goal of the <ulink url="http://www.objectweb.org/">ObjectWeb 
        Consortium</ulink> is the development of open source distributed 
        middleware, in the form of adaptable and flexible components. ObjectWeb 
        components range from specific software frameworks and protocols to 
        integrated platforms. More information on ObjectWeb and its projects is 
        available at the ObjectWeb's Web site.</para>
    </section>
  </section>
</article>
