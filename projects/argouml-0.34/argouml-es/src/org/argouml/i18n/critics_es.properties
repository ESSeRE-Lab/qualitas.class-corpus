# $Id: critics_es.properties 308 2011-02-20 09:36:35Z er_conde $
# Copyright (c) 2004-2006 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# The keys are generated from the class names of the classes that use them.
# 
# Keys in alphabetical order.
# Don't sort the lines! That will probably make a mess since they values
# span several lines.
#
# To recover editable version of this file use:
#    native2ascii -reverse -encoding ISO8859_1 <cvs_filename> <editable_filename>
#
# BE SURE to convert ASCII before commiting by using the command
#    native2ascii -encoding ISO8859_1 <editable_filename> <cvs_filename> 
#
# LITTLE DICTIONARY ////////////////////////////////////////////////
#
# This translation is based on "El Lenguaje Unificado de Modelado", Booch, 
# Rumbaugh, Jacobson. Almost every term is a direct translation. This is a 
# sample..
#
# activity diagram: diagrama de actividades
# aggregation (white diamond): agregaci\u00f3n (diamante blanco)
# association: asociaci\u00f3n
# attribute: atributo
# branch transitions: transiciones de divisi\u00f3n
# call-action: evento de llamada
# class diagram: diagrama de clases
# classifier: clasificador
# collaboration diagram: diagrama de colaboraci\u00f3n
# component diagram: diagrama de componentes
# composite (black diamond): composici\u00f3n o agregaci\u00f3n compuesta (diamante negro)
# connection: conexi\u00f3n
# component: componente
# deployment diagram: diagrama de despliegue
# fork transitions: transiciones de bifurcaci\u00f3n
# framework: framework
# guard: guarda 
# join transitions: transiciones de uni\u00f3n
# node: nodo
# object diagram: diagrama de objetos
# operation: operaci\u00f3n
# rol: papel
# send-action: se\u00f1al 
# sequence diagram: diagrama de secuencia
# state diagram: diagrama de estados
# trigger: disparador
# use cases: casos de uso
critics.CrAlreadyRealizes-head = Quita el realiza innecesario de <ocl>self</ocl>
critics.CrAlreadyRealizes-desc = La clase seleccionada ya realiza indirectamente el MInterface {item.extra}.  No hay necesidad de realizarlo otra vez.\n\nSimplificar el dise\u00f1o siempre es bueno.Simplificar el dise\u00f1o siempre es bueno.  Puedes descartar este elemento \"por hacer\" si quieres destacar que la clase seleccionada realiza este MInterface.\n\nPara arreglar esto, selecciona la Realizaci\u00f3n (l\u00ednea punteada con una flecha blanca triangular) y pulsa la tecla \"Delete\".
critics.CrAssocNameConflict-head = Resuelve conflicto en el nombre de la asociaci\u00f3n
critics.CrAssocNameConflict-desc = Todo elemento del espacio de nombres debe tener un nombre \u00fanico. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente los elementos y usa la solapa Propiedades para cambiar sus nombres.
critics.CrAttrNameConflict-head = Revisa los nombres de atributos para evitar conflictos
critics.CrAttrNameConflict-desc = Los atributos deben tener nombres diferentes. Esto se debe  quiza a un atributo heredado. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo en conflicto de la clase y cambia su nombre.
critics.CrCallWithoutReturn-head = Acci\u00f3n de retorno ausente
critics.CrCallWithoutReturn-desc = Toda se\u00f1al o evento de llamada requiere una acci\u00f3n de retorno, pero este enlace no tiene una acci\u00f3n de retorno.\n
critics.CrCircularAssocClass-head = MAssociation circular
critics.CrCircularAssocClass-desc = Las AssociationClasses no pueden incluir papeles que se refieran directamente a la MAssociationClass.
critics.CrCircularComposition-head = Quita la composici\u00f3n circular
critics.CrCircularComposition-desc = Las relaciones de composici\u00f3n (diamantes negros) no pueden tener ciclos. \n\nUna jerarqu\u00eda legal de agregaci\u00f3n se necesita para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente una de las asociaciones en el ciclo y quitala o cambia su agregaci\u00f3n a otra que no sea composici\u00f3n.
critics.CrCircularInheritance-head = Quita la herencia circular del <ocl>self</ocl>
critics.CrCircularInheritance-desc = Las relaciones de herencia no pueden tener ciclos. \n\nSe necesita una jerarquia legal de clases para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de las flechas de generalizaci\u00f3n en el ciclo y quitala.
critics.CrClassMustBeAbstract-head = La clase debe ser abstracta
critics.CrClassMustBeAbstract-desc = Las clases que incluyen o heredan m\u00e9todos abstractos de sus clases base o interfaces deben ser Abstract.\n\nDecidir que clases son abstractas o concretas es una parte clave del dise\u00f1o de la jerarqu\u00eda de clases.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y usa la solapa Propiedades para a\u00f1adir la palabra clave abstract, o manualmente sobrepon cada operaci\u00f3n abstracta que es heredada de una clase base o interface.
critics.CrClassWithoutComponent-head = Las clases estan normalmente dentro de componentes
critics.CrClassWithoutComponent-desc =  En los diagramas de despliegue las clases estan normalmente dentro de componentes
critics.CrCompInstanceWithoutNode-head = ComponentInstances estan normalmente dentro de nodos
critics.CrCompInstanceWithoutNode-desc = Hay instancias de nodos en el diagrama. Por tanto, tienes un real diagrama de despliegue, y en los diagramas de despliegue las instancias de componentes residen normalmente en instancias de nodos.
critics.CrComponentWithoutNode-head = Los componentes estan normalmente dentro de nodos
critics.CrComponentWithoutNode-desc = Hay nodos en el diagrama. Por tanto, tienes un diagrama de despliegue, y en los diagramas de despliegue los componentes residen normalmente en nodos.
critics.CrConflictingComposites-head = Quita las agregaciones compuestas en conflicto
critics.CrConflictingComposites-desc = Un papel de composici\u00f3n (diamante negro) de una association indica que las instancias de esta clase contienen instancias de las associated classes. Puesto que cada instancia solo puede ser contenida en uno de los otros objetos, cada objeto puede ser 'parte' en al menos una relaci\u00f3n es-parte-de.\n\nUn buen dise\u00f1o OO depende de construir buenas relaciones es-parte-de.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o cambia manualmente una de las asociaciones para que tenga multiplicidad 0..1 o 1..1, u otra clase de agregaci\u00f3n (por ejemplo, un diamante blanco es menos estricto), o quita una de las asociaciones
critics.CrConsiderSingleton-head = Considera el uso del patr\u00f3n Singelton 
critics.CrConsiderSingleton-desc = Esta clase no tiene atributos ni asociaciones que sean navegables fuera de la instancias de esta clase.  Esto significa que cada instancia de esta clase sera igual a cualquier otra debido a que no habr\u00e1 variables de instancia para diferenciarlas. Si esta no es tu intenci\u00f3n, deber\u00edas definir atributos o asociaciones que representen diferencias entre las instancias. Si no hay atributos o asociaciones para realizar esta diferenciaci\u00f3n, deber\u00edas considerar el uso de solo una instancia de esta clase, tal como se indica en el patr\u00f3n Singelton.\n\nDefinir la multiplicidad de instancias es necesario para completar la parte de representaci\u00f3n de informaci\u00f3n del dise\u00f1o. Usar el patr\u00f3n Singelton puede ahorrar tiempo y memoria.\n\nPara aplicar autom\u00e1ticamente el patr\u00f3n Singleton, pulsa el bot\u00f3n \"Siguiente>\"; o manualmente (1) marca la clase con el estereotipo Singlton, (2) a\u00f1ade una variable est\u00e1tica que contenga la instancia de esta clase, (3) y haz privados todos los constructores.\n\nPara saber m\u00e1s del patr\u00f3n Singleton, pulsa el icono MoreInfo.
critics.CrConstructorNeeded-head = A\u00f1ade constructor a <ocl>self</ocl>
critics.CrConstructorNeeded-desc = Aun no has definido un constructor para la clase <ocl>self</ocl>. Los constructores inicializan nuevas instancias dotando de valores v\u00e1lidos a sus atributos.  Esta clase probablemente necesite un constructor porque no todos sus atributos tienen valores iniciales. \n\nDefinir buenos constructores es clave para establecer class invariants, y class invariants son una poderosa ayuda para escribir c\u00f3digo s\u00f3lido. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un constructor pulsando en <ocl>self</ocl> en el panel de navegaci\u00f3n y usando el men\u00fa Create para hacer un constructor nuevo. 
critics.CrCrossNamespaceAssoc-head = Papel agregado en una MAssociation N-caminos
critics.CrConstructorNeeded-ins = Asignar el nombre del nuevo constructor.
critics.CrConstructorNeeded-sug = nueva Operaci\u00f3n
critics.CrCrossNamespaceAssoc-desc = Cada clase o MInterface implicado en una MAssociation deber\u00eda estar en el MNamespace de la MAssociation.\n
critics.CrDisambigClassName-head = Escoge un nombre \u00fanico para <ocl>self</ocl>
critics.CrDisambigClassName-desc = Toda clase e interfaz de un paquete debe tener un nombre \u00fanico. Hay al menos dos elementos en este paquete llamados \"<ocl>self</ocl>\".\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente una de las clases en conflicto y usa la solapa Propiedades para cambiar sus nombres.
critics.CrDisambigClassName-ins = Cambie el nombre a algo diferente.
critics.CrDisambigStateName-head = Escoge un nombre \u00fanico para <ocl>self</ocl>
critics.CrDisambigStateName-desc = Todo estado de una m\u00e1quina de estados debe tener un nombre \u00fanico. Hay al menos dos estados en esta m\u00e1quina llamados \"<ocl>self</ocl>\".\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de los estados en conflicto y usa la solapa \"Propiedades\" para cambiar sus nombres.
critics.CrDupParamName-head = Nombre de parametro duplicado
critics.CrDupParamName-desc = Cada parametro de una operaci\u00f3n debe tener un nombre \u00fanico. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o renombra manualmente uno de los parametros de esta operaci\u00f3n.
critics.CrDupRoleNames-head = Cambia los nombres de papel de <ocl>self</ocl>
critics.CrDupRoleNames-desc = La MAssociation <ocl>self</ocl> tiene dos papeles con nombres en conflicto. \n\nUsar nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa de propiedades para cambiar los nombres de papel.
critics.CrEmptyPackage-head = A\u00f1ade elementos al paquete <ocl>self</ocl>
critics.CrEmptyPackage-desc = Aun no has puesto nada en el paquete <ocl>self</ocl>. Normalmente los paquetes contienen grupos de clases relacionadas.\n\nDefinir y usar paquetes es clave para un dise\u00f1o mantenible. \n\nPara arreglar esto, selecciona el paquete <ocl>self</ocl> en el panel de navegaci\u00f3n y a\u00f1ade los diagramas o modelos como clases o casos de uso. 
critics.CrFinalSubclassed-head = Quita la palabra clave final y las subclases.
critics.CrFinalSubclassed-desc = En Java, la palabra clave 'final' indica que una clase no deber\u00eda tener subclases. .  Esta clase esta etiquetada final y tiene subclases.\n\nUna jerarqu\u00eda de clases meditada y que permita la adecuada subclasificaci\u00f3n es un parte importante para conseguir un dise\u00f1o comprensible y mantenible.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y cambia su superclase, o selecciona la superclase y usa la solapa de propiedades para quitar la palabra clave 'final'.
critics.CrForkOutgoingTransition-desc = La fuente de <ocl>self</ocl> es un \
        Fork Pseudostate pero su destino no es State. Un segmento fork deber\u00eda \
        siempre acabar en un estado.\n\nDefinir transiciones v\u00e1lidas es necesario para \
        completar la parte de especificaci\u00f3n del comportamiento del dise\u00f1o.\n\nPara fijar \
        esto, presione borrar esta transici\u00f3n pulsando en la transici\u00f3n del  \
        diagrama y presionando \"Ctrl-Delete\" . Usted puede tambi\u00e9n cambiar \
        la fuente de la transici\u00f3n o los estados destinos.
critics.CrForkOutgoingTransition-head = Inv\u00e1lido destino para la transici\u00f3n
critics.CrIllegalName-head = Escoge un nombre legal
critics.CrIllegalName-desc = Los nombres de los elementos del modelo deben ser secuencias de letras, n\u00fameros, y subrayados.  No pueden contener puntuaci\u00f3n.\n\nLa generaci\u00f3n de c\u00f3digo requiere nombres legales para que el c\u00f3digo resultante compile correctamente. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el elemento destacado y usa la solapa Propiedades para darle un nombre diferente.
critics.CrIllegalGeneralization-head = MGeneralization ilegal
critics.CrIllegalGeneralization-desc = Los elementos MModel solo pueden ser heredados por otros del mismo tipo. \n\nSe necesita una jerarqu\u00eda correcta para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o.Se necesita una jerarqu\u00eda correcta para la generaci\u00f3n de c\u00f3digo y la correcci\u00f3n del dise\u00f1o.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la flecha de generalizaci\u00f3n y quitala.
critics.CrInstanceWithoutClassifier-head = Establece un clasificador
critics.CrInstanceWithoutClassifier-desc = Las instancias tienen un clasificador
critics.CrInterfaceAllPublic-head = Las operaciones de los interfaces deben ser p\u00fablicas
critics.CrInterfaceAllPublic-desc = Los Interfaces especifican las operaciones que otras clases deben implementar.  Deben ser p\u00fablicos. \n\nUn conjunto de interfaces bien dise\u00f1ado es un buen modo de definir las posibles extensiones de un framework de clases. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente las operaciones del interfaz y usa la solapa de propiedades para hacerlas publicas.
critics.CrInterfaceOperOnly-head = Los interfaces solo deben tener operaciones
critics.CrInterfaceOperOnly-desc = Los Interfaces especifican las operaciones que otras clases deben implementar.  No implementan esas operaciones ellos mismos , y no pueden tener atributos. \n\nUn conjunto de interfaces bien dise\u00f1ado es un buen modo de definir las posibles extensiones de un framework de clases. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el interfaz y usa la solapa Propiedades para quitar todos los atributos.
critics.CrInterfaceWithoutComponent-head = Los interfaces estan normalmente dentro de componentes
critics.CrInterfaceWithoutComponent-desc =  En Deployment-diagrams los interfaces estan normalmente dentro de componentes
critics.CrInvalidBranch-head = Cambia las transiciones de divisi\u00f3n
critics.CrInvalidBranch-desc = Este estadod de divisi\u00f3n tiene un n\u00famero invalido de transiciones. Normalmente los estados de divisi\u00f3n tienen una transici\u00f3n entrante y dos o m\u00e1s salientes. \n\nDefinir correctamente la transici\u00f3n de estados es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita transitions manualmente pulsando en la transici\u00f3n en el diagrama y pulsando la tecla Delete, o a\u00f1ade transiciones usando la herramienta de transiciones.
critics.CrInvalidFork-head = Cambia las transiciones de bifurcaci\u00f3n
critics.CrInvalidFork-desc = Este estado de bifurcaci\u00f3n tiene un n\u00famero invalido de transiciones. Normalmente los fork states tienen una transici\u00f3n entrante y dos o m\u00e1s salientes. \n\nDefinir transiciones de estado correctas es neceario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente las transiciones pulsando en una transici\u00f3n en el diagrama y pulsando la tecla Delete. 
critics.CrInvalidForkTriggerOrGuard-desc = La Transición resaltada debería \
        no tener un trigger o guarda porque es un Fork PseudoState de \
        una trasición saliente.  Las transiciones salientes desde un vértice fork debe \
        no tener triggers o guardas.\n\nDefinir transiciones válidas es necesario \
        para completar la parte de la especificación del comportamiento de tu diseño.\n\nPara \
        fijar esto, eliminar el trigger seleccionándolo en el panel explorador y \
        quitándolo del model con el menu del click-derecho del ratón. O, en el caso de una \
        guarda, quitarlo mediante el doble click en el campo de la guarda de la transición \
        y presionando \"Ctrl-Delete\" .
critics.CrInvalidForkTriggerOrGuard-head = Quitar Trigger or Guard del Fork \
        de la transición saliente
critics.CrInvalidJoin-head = Cambia las transiciones de uni\u00f3n
critics.CrInvalidJoin-desc = Este estado de uni\u00f3n tiene un n\u00famero invalido de transiciones. Normally join states tienen dos o m\u00e1s transiciones entrantes y una saliente. \n\nDefinir correctamente la transici\u00f3n de estados es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las transiciones manualmente pulsando en la transici\u00f3n en el diagrama y pulsando la tecla Delete. 
critics.CrJoinIncomingTransition-desc = El destino de <ocl>self</ocl> es un \
        Join Pseudostate pero su fuente no es un State. Un segmento de unión debería \
        siempre originarse desde un estado.\n\nDefinir transiciones válidas es necesario \
        para completar la parte de la especificación del comportamiento de tu diseño.\n\nPara \
        fijar esto, borrar esta transición haciendo click en la transición en el \
        diagrama y presionando \"Ctrl-Delete\". Usted también puede cambiar la \
        fuente de la transición o los estados de destino.
critics.CrJoinIncomingTransition-head = Inválida fuente para la transición
critics.CrLinkWithoutStimulus-head = No hay est\u00edmulo en estos enlaces
critics.CrLinkWithoutStimulus-desc = En los diagramas de secuencia un objeto emisor env\u00eda un est\u00edmulo a un objeto que lo recibe a traves de un enlace. El enlace solo es la comunicaci\u00f3n-conexi\u00f3n, asi que se necesita un est\u00edmulo.
critics.CrMergeClasses-head = Considera combinar las clases
critics.CrMergeClasses-desc = La clase realzada, <ocl>self</ocl>, solo participa en una asociaci\u00f3n y esa asociaci\u00f3n es uno-a-uno con otra clase.  Puesto que las instancias de estas clases deben ser creadas y destruidas juntas, combinar estas clases puede simplificar el dise\u00f1o sin perdida de poder representativo.  Sin embargo, quiza la clase resultante sea demasiado grande y compleja, en cuyo caso ser\u00e1 mejor mantenerla separada.\n\nSiempre es importante organizar clases para administrar la complejidad del dise\u00f1o, especialmente cuando el dise\u00f1o ya es complejo de por s\u00ed. \n\nPara arreglar esto, pulsa en el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente los atributos y operaciones de la clase realzada a la otra clase, luego quita la clase realzada del proyecto. 
critics.CrMissingAttrName-head = Escoge un nombre
critics.CrMissingAttrName-desc = Todo atributo debe tener un nombre.. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo y usa la solapa Propiedades para darle un nombre.
critics.CrMissingAttrName-ins = Asigne el nombre de este atributo.
critics.CrMissingAttrName-sug = NombreAtributo
critics.CrMissingClassName-head = Escoge un nombre
critics.CrMissingClassName-desc = Cada clase e interfaz de un paquete deber\u00eda tener un nombre. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente la clase y usa la solapa Propiedades para asignarle un nombre.
critics.CrMissingClassName-ins = Asigne el nombre de este elemento.
critics.CrMissingClassName-sug = NombreClase
critics.CrMissingOperName-head = Escoge un nombre
critics.CrMissingOperName-desc = Toda operaci\u00f3n debe tener un nombre.. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el atributo y usa la solapa Propiedades para darle un nombre.
critics.CrMissingOperName-ins = Asigne el nombre de este atributo.
critics.CrMissingOperName-sug = NombreAtributo
critics.CrMissingStateName-head = Escoge un nombre
critics.CrMissingStateName-desc = Todo estado de una m\u00e1quina de estados deber\u00eda tener un nombre. \n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el estado y usa la solapa Propiedades para darle un nombre, o selecciona el estado y escribe un nombre.
critics.CrMissingStateName-ins = Asigne el nombre de este estado.
critics.CrMissingStateName-sug = NombreEstado
critics.CrMultiComposite-desc = Una instancia podr\u00eda no pertenecer por composici\u00f3n a \
        m\u00e1s de una instancia compuesto. Debe cambiar la multiplicidad en \
        el compuesto fin de la asociaci\u00f3n a 0..1 o 1..1 (1) para \
        que su modelo tenga sentido.\r\n\r\nRecuerde que la composici\u00f3n es  \
        el tipo m\u00e1s fuerte de agregaci\u00f3n y la agregaci\u00f3n es m\u00e1s d\u00e9bil. El problema \
        puede ser comparado a un modelo donde un dedo puede ser una parte integral de \
        muchas manos al mismo tiempo.\r\n\r\nEste el el segunda regla de \
        buena formaci\u00f3n de Fin de Asociaci\u00f3n en  UML 1.4.
critics.CrMultiComposite-head = Compuesto Fin de Asociaci\u00f3n con multiplicidad > 1
critics.CrMultipleAgg-head = Papeles agregados multiples
critics.CrMultipleAgg-desc = Solo un papel de una MAssociation puede tener un agregado o compuesto.\n\nUna jerarqu\u00eda es-parte-de clara y consistente es clave para la claridad del dise\u00f1o, almacenamiento de objetos, e implementaci\u00f3n de m\u00e9todos recursivos.\nPara arreglar esto, selecciona la MAssociation y establece algunos de sus papeles de agregaci\u00f3n a Ninguno.
critics.CrMultipleInheritance-head = Sustituye la herencia multiple por interfaces
critics.CrMultipleInheritance-desc = <ocl>self</ocl> tiene multiples clases base, pero Java no soporta herencia multiple.  Debes implementar interfaces en vez de usar multiples clases base. \n\nEste cambio se requiere antes de poder generar c\u00f3digo Java.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o manualmente (1) quita una de las clases base y luego (2) opcionalmente define un nuevo interfaz con las mismas declaraciones de m\u00e9todos y (3) a\u00f1adelo como un interface de <ocl>self</ocl>, y (4) mueve los cuerpos de los m\u00e9todos de la antigua clase base a <ocl>self</ocl>.
critics.CrMultipleInitialStates-head = Quita los estados inicialies que sobran
critics.CrMultipleInitialStates-desc = Hay multiples y ambiguos estados iniciales en esta m\u00e1quina. Normalmente cada m\u00e1quina de estados o composite state tiene un estado inicial. \n\nDefinir estados no ambiguos es necesario para completar la parte de definici\u00f3n de comportamiento del dise\u00f1o.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o selecciona manualmente uno de los estados y quitalo. 
critics.CrMultipleRealization-desc = <ocl>self</ocl> implementa multiples \
        interfaces. Aunque este código es legal en UML no compilará en \
        Java. Sustituya las multiples realizaciones por generalizaciones si usted \
        quiere crear código compilable y libre de errores.
critics.CrMultipleRealization-head = Cambiar Realización múltiple en \
        <ocl>self</ocl> por Generalizaciones.
critics.CrMultipleShallowHistoryStates-desc = Existe multiples, ambiguos \
        shallow history states es esta máquina o un estado compuesto. Normalmente \
        cada máquina de estados o estado compuesto tiene sólo una shallow history \
        state. \n\nDefiniendo unambiguous history states es necesario completar \
        the behavioral specification parte de tu diseño.\n\nPara fijar esto, \
        seleccionar uno de the shallow history states y borrarlo presionando \
        \"Ctrl-Delete\".
critics.CrNameConflict-desc = Los nombres de los elementos contenidos en un espacio de nombres (por ejemplo: \
        paquetes) debe ser \u00fanico. El elemento <ocl>self</ocl> viola esta \
        condici\u00f3n. Esta condici\u00f3n no aplica para nombres de  \
        Generalizaciones.
critics.CrNameConflict-head = Conflicto de nombres causado por <ocl>self</ocl>
critics.CrNameConflict-ins = Cambiar el nombre a otro diferente.
critics.CrNameConflictAC-head = El nombre del papel esta en conflicto con el miembro
critics.CrNameConflictAC-desc = Los nombres de papel MAssociation de la MAssociationClass no deben estar en conflicto con los nombres de las caracter\u00edsticas estructurales (por ejemplo las variables de instancia) de la clase.\n
critics.CrNameConfusion-head = Revisa los nombres para evitar confusiones
critics.CrNameConfusion-desc = Los nombres deber\u00edan distinguirse claramente unos de otros. Estos dos nombres son tan parecidos que pueden ser confundidos.\n\nLa asignaci\u00f3n de nombres claros e inequ\u00edvocos es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente los elementos y usa la solapa Propiedades para cambiar sus nombres.  Evita usar nombres que solo difieren en distinciones may\u00fasculas-min\u00fasculas, o en subrayados, o en un solo car\u00e1cter.
critics.CrNavFromInterface-head = Quita la navegaci\u00f3n del MInterface <ocl>self</ocl>
critics.CrNavFromInterface-desc = Las asociaciones que implican un MInterface no pueden ser navegables en la direcci\u00f3n desde el MInterface.  Esto se debe a que los interfaces contienen solo declaraciones de operaciones y no pueden contener punteros a otros objetos.\n\nEsta parte del dise\u00f1o deber\u00eda cambiarse antes de generar el c\u00f3digo de este dise\u00f1o.  Si generas c\u00f3digo antes de arreglar este problema, el c\u00f3digo no se ajustar\u00e1 al dise\u00f1o.\n\nPara arreglar esto, selecciona la MAssociation y usa la solapar \"Propiedades\" para tab to desactivar Navigable para el extremo que toca el MInterface.  La MAssociation deber\u00eda parecer entonces con una flecha apuntado fuera del MInterface.
critics.CrNoAssociations-head = A\u00f1ade asociaciones a <ocl>self</ocl>
critics.CrNoAssociations-desc = Aun no has especificado asociaciones para <ocl>self</ocl>. Normalmente las clases, actores, y casos de uso estan asociadas con otras. \n\nDefinir las asociaciones entre objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade las asociaciones manualmente pulsando en la herramienta de asociaci\u00f3nen la barra de tareas y arrastrando desde <ocl>self</ocl> a otro nodo. 
critics.CrNodeInsideElement-head = Los nodos normalmente no tienen contenedores
critics.CrNodeInsideElement-desc =  Los nodos normalmente no estan dentro de otros elementos. Los nodos representan objetos f\u00edsicos en tiempo de ejecuci\u00f3n con un recurso de procesamiento, generalmente tienen al menos memoria y capacidad de procesamiento.
critics.CrNodeInstanceInsideElement-head = Las NodeInstances normalmente no tienen contenedores
critics.CrNodeInstanceInsideElement-desc = Las NodeInstances normalmente no estan dentro de otros elementos. Las instancias de nodos representan objetos f\u00edsicos en tiempo de ejecuci\u00f3n con un recurso de procesamiento, generalmente tienen al menos memoria y capacidad de procesamiento.
critics.CrNodesOverlap-head = Limpia el diagrama
critics.CrNodesOverlap-desc = Algunos objetos en este diagrama se solapan sobre otros. Esto puede ocultar informaci\u00f3n importante y hacer el dise\u00f1o m\u00e1s dif\u00edcil de entender. Una apariencia cuidada ayuda a otros dise\u00f1adores, implementadores, y analistas.\n\nConstruir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, mueve los nodos destacados en el diagrama.
critics.CrNoGuard-head = A\u00f1ade MGuard a la transici\u00f3n
critics.CrNoGuard-desc = La transici\u00f3n destacada esta incompleta porque no tiene guard condition.  Las condiciones MGuard deben ser verdaderas para que la transici\u00f3n se produzca.  Si solo se usa una guarda, la transici\u00f3n se produce cuando la condici\u00f3n es verdadera.\n\nEste problema debe ser resuelto para completar la m\u00e1quina de estado.\n\nPara arreglar esto, selecciona la MTransition y usa la solapa \"Propiedades\", o selecciona la MTransition y escribe algun texto con el formato:\n[GUARDA]\nDonde GUARDA es una expresi\u00f3n booleana.
critics.CrNoIncomingTransitions-head = A\u00f1ade transiciones entrantes a <ocl>self</ocl>
critics.CrNoIncomingTransitions-desc = MState <ocl>self</ocl> no tiene transiciones entrantes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transiciones de estados completas es clave para completar la especificaci\u00f3n de comportamiento del dise\u00f1o. Sin transiciones entrantes, este estado nunca puede ser alcanzado.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente transiciones pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando esde otro estado a <ocl>self</ocl>. 
critics.CrNoInitialState-head = Pon un MState inicial
critics.CrNoInitialState-desc = No hay estado inicial en esta m\u00e1quina o composite state. Normalmente cada m\u00e1quina o composite state tiene un estado inicial. \n\nDefinir estados no ambiguos es necesario para completar la definici\u00f3n de comportamiento del dise\u00f1o.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un estado inicial usando la barra de herramientas y a\u00f1adelo al diagrama. 
critics.CrNoInstanceVariables-head = A\u00f1ade variables de instancia a <ocl>self</ocl>
critics.CrNoInstanceVariables-desc = Aun no has especificado variables de instancia para <ocl>self</ocl>. Normalmente las clases tienen variables de instancia que almacenan la informaci\u00f3n para cada instancia. Las clases que solo proporcionan atributos y m\u00e9todos est\u00e1ticos deber\u00edan ser estereotipadas con <<utility>>.\n\nQuiza deber\u00edas definir las variables de instancia para completar la parte de representaci\u00f3n de la informaci\u00f3n de tu dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade variables de instancia haciendo doble click en <ocl>self</ocl> en el panel de navegaci\u00f3n o usando el menu Crear para crear un nuevo atributo. 
critics.CrNoInstanceVariables-ins = Asigne el nombre a la nueva variable.
critics.CrNoInstanceVariables-sug = nuevoAttr
critics.CrNonAggDataType-head = Envuelve MDataType
critics.CrNonAggDataType-desc = Los DataTypes no son clases y no pueden ser asociadas con clases, a menos que el MDataType sea parte de una agregaci\u00f3n compuesta (diamante negro). \n\nUn buen dise\u00f1o OO depende de elecciones cuidadosas acerca de que entidades representar como objetos y cuales representar como atributos de objetos.\n\nPara arreglar esto, use el bot\u00f3n \"Siguiente>\" , o reemplace manualmente el MDataType con una clase, o cambie la asociaci\u00f3n de agregaci\u00f3n a una clase.\n
critics.CrNoOperations-head = A\u00f1ade operaciones a <ocl>self</ocl>
critics.CrNoOperations-desc = Aun no has especificado operaciones para <ocl>self</ocl>. Normalmente las clases proporcionan operaciones que definen su comportamiento. \n\nNecesitas definir operaciones para completar la parte de especificaci\u00f3n de la comportamiento del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade operaciones manualmente pulsando en <ocl>self</ocl> en el panel de navegaci\u00f3n y usando el menu\u00fa Crear para hacer nuevas operaciones. 
critics.CrNoOperations-ins = Asigne el nombre de la nueva operaci\u00f3n.
critics.CrNoOperations-sug = nuevaOperacion
critics.CrNoOutgoingTransitions-head = A\u00f1ade transiciones salientes desde <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc = MState <ocl>self</ocl> no tiene transacciones salientes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transacciones de estados completas es necesario para completar la especificaci\u00f3n de comportamiento del dise\u00f1o.  Sin transiciones salientes este estado esta \"muerto\" y nunca se puede salir de \u00e9l.\n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente transiciones pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando desde otro estado a <ocl>self</ocl>. 
critics.CrNoTransitions-head = A\u00f1ade transiciones a <ocl>self</ocl>
critics.CrNoTransitions-desc = MState <ocl>self</ocl> no tiene transiciones entrantes o salientes. Normalmente los estados tienen transiciones entrantes y salientes. \n\nDefinir transiciones de estados completas es necesario para la parte de especificaci\u00f3n de comportamiento de tu dise\u00f1o.  \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o a\u00f1ade transiciones manualmente pulsando en la herramienta de transiciones en la barra de herramientas y arrastrando desde otro estado a <ocl>self</ocl> o desde <ocl>self</ocl> a otro estado. 
critics.CrNoTriggerOrGuard-head = A\u00f1ade un disparador o guarda a la transici\u00f3n
critics.CrNoTriggerOrGuard-desc = La transici\u00f3n destacada es incompleta porque no tiene disparador ni condici\u00f3n de guarda.  Los disparadores son eventos que producen una transici\u00f3n. Las condiciones de guarda deben ser verdaderas para que la transici\u00f3n se produzca.  Si solo se usa una guarda, la transici\u00f3n se produce cuando la condici\u00f3n es verdadera.\n\nEste problema debe ser resuelto para completar la m\u00e1quina de estados.\n\nPara arreglar esto, selecciona la transition y usa la solapa \"Propiedades\", o selecciona la transition y escribe texto con el formato:\nDISPARADOR [GUARDA] / ACCI\u00d3N\ndonde DISPARADOR es el nombre de un evento, GUARDA es una expresi\u00f3n booleana, y ACCI\u00d3N es una acci\u00f3n a realizar cuando se produce MTransition.  Las tres partes son opcionales.
critics.CrNWayAgg-head = Papel agregado en una relaci\u00f3n de N-caminos MAssociation
critics.CrNWayAgg-desc = Las asociaciones de 3 o m\u00e1s caminos no pueden tener aggregate ends.\n\nUna consistente y clara jerarquia es-parte-de es clave para la claridad del dise\u00f1o, el almacenamiento mantenible de objetos, y la implementaci\u00f3n de m\u00e9todos recursivos.\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente the MAssociation y establece todos los role aggregations a None.
critics.CrObjectWithoutComponent-head = Los objetos estan normalmente dentro de componentes
critics.CrObjectWithoutComponent-desc = En los diagramas de despliegue los objetos estan normalmente dentro de componentes or component-instances
critics.CrOperNameConflict-head = Cambia los nombres o firmas en <ocl>self</ocl>
critics.CrOperNameConflict-desc = Dos operaciones tienen exactamente la misma firma.  Deber\u00edan ser distintas.  Una firma es una combinaci\u00f3n del nombre de la operaci\u00f3n, y sus tipos de parametros. \n\nEvitar firmas en conflicto es clave para la generaci\u00f3n de c\u00f3digo y el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente las operaciones en conflicto de esta clase y cambia su nombre o sus parametros.
critics.CrOppEndConflict-head = Renombra los papeles MAssociation
critics.CrOppEndConflict-desc = Dos papeles de <ocl>self</ocl> tienen el mismo nombre. Los papeles deben tener nombres distintos.  Esto quiza sea debido a un atributo heredado. \n\nUsar nombres claros y no ambiguos es clave para la generaci\u00f3n de c\u00f3digo y la producci\u00f3n de un dise\u00f1o f\u00e1cil de entender y mantener.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el papel en conflicto en el extremo de la asociaci\u00f3n de esta clase y cambia su nombre.
critics.CrOppEndVsAttr-desc = Dos atributos no pueden tener el mismo nombre con \
        un Clasificador.\n\nEsta es la segunda regla para una correcta formaci\u00f3n de Clasificadores \
        en UML 1.4.
critics.CrOppEndVsAttr-head = Renombre el rol o el atributo
critics.CrParamTypeNotImported-head = Importa el tipo MParameter en la clase
critics.CrParamTypeNotImported-desc = El tipo del parametro de cada operaci\u00f3n debe ser visible y haber sido importado en la clase que posee dicha operaci\u00f3n.\n\nImportar clases es necesario para la generaci\u00f3n de c\u00f3digo. Una buena modularizaci\u00f3n de clases en paquetes es clave para conseguir un dise\u00f1o f\u00e1cil de entender.\n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o a\u00f1ade manualmente un import a la clase que posee esta operaci\u00f3n.
critics.CrReservedName-head = Cambia <ocl>self</ocl> a una palabra no reservada
critics.CrReservedName-desc = \"<ocl>self</ocl>\" es una palabra reservada o muy parecida a una.  Los nombres de los elementos del modelo no deben estar en conflicto con palabras reservadas de lenguajes de programaci\u00f3n o del UML.\n\nEs necesario usar nombres legales para generar c\u00f3digo compilable.. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente el elemento realzado y usa la solapa Propiedades para darle un nombre diferente.
critics.CrReservedName-ins = Change the name to something different.
critics.CrReservedNameJava-desc = \"<ocl>self</ocl>\" es una palabra reservada o muy \
        cercana a una.  Los nombres de los elementos del model no deben tener conflictos con \
        palabras reservadas del lenguaje de programaci\u00f3n Java.\n\nUsar nombres legales \
        es necesario para generar c\u00f3digo compilable. \n\nUse el bot\u00f3n \
        \"Next>\", o manualmente seleccione el elemento resaltado y use \
        la pesta\u00f1a Propiedades para cambiar el nombre.
critics.CrReservedNameJava-head = Cambie <ocl>self</ocl> a una palabra no reservada
critics.CrReservedNameJava-ins = Cambie el nombre a otro diferente.
critics.CrReturnWithoutCall-head = Ausencia de se\u00f1al o evento de llamada
critics.CrReturnWithoutCall-desc = Toda acci\u00f3n de retorno requiere una se\u00f1al o evento de llamada, pero este enlace no tiene su correspondiente se\u00f1al o evento de llamada.\n
critics.CrSeqInstanceWithoutClassifier-head = Establece un clasificador
critics.CrSeqInstanceWithoutClassifier-desc =  Las instancias tienen un clasificador
critics.CrSingletonViolatedMissingStaticAttr-desc = <ocl>self</ocl> está \
        marcado con <<singleton>>; estereotipo, pero no sastiface las \
        restricciones impuestas sobre Singletons.\nNo tiene una atributo \
        estático (una variable de clase) to hold the instance.\n\nSi usted marca \
        una clase con un estereotipo, la clase debería satisfacer todas las \
        restricciones de los estereotipos. Esta es una parte importante \
        para hacer un diseño consistente y comprensible. Usando el patrón \
        Singleton puede ahorrar tiempo y espacio en memoria.\n\nSi usted no quiere en adelante \
        que su clase sea un Singleton, quite el estereotipo <<singleton>> \
        pulsando sobre la clase y seleccionando el elemento vacío en la lista \
        de estereotipos dentro la pestaña de propiedades.\n
critics.CrSingletonViolatedMissingStaticAttr-head = Estereotipo Singleton  \
        incorrecto, no existente Atributo Estático en <ocl>self</ocl>
critics.CrSingletonViolatedOnlyPrivateConstructors-desc = <ocl>self</ocl> está \
        marcado con el estereotipo <<singleton>>; pero ello no satisface las \
        restricciones impuestas sobre los Singletons.\nDebe tener sólo constructores \
        privados así que las nuevas instancias no puedan se hechas por otro \
        código.\nSi usted marca una clase con un estereotip, la clase debería \
        satisfacer todas las restricciones del estereotipo.  Esta es una parte importante \
        para hacer un diseño consistente y comprensible. Usando el patrón \
        Singleton puede ahorrar tiempo y espacio en memoria.\n\nSi usted no quiere en adelante \
        que su clase sea un Singleton, quite el estereotipo <<singleton>> \
        pulsando sobre la clase y seleccionando el elemento vacío en la lista \
        de estereotipos dentro la pestaña de propiedades.\n
critics.CrSingletonViolatedOnlyPrivateConstructors-head = Estereotipo Singleton \
        incorrecto, tiene un constructor no privado en <ocl>self</ocl>
critics.CrStimulusWithWrongPosition-head = Posici\u00f3n incorrecta de estos estimulos
critics.CrStimulusWithWrongPosition-desc = En los diagramas de secuencia la parte de env\u00edo de la comunicaci\u00f3n-conexi\u00f3n de estos est\u00edmulos es conectada al comienzo de una activaci\u00f3n. Para ser un emisor, un objeto ha de tener primero un foco-de-control.
critics.CrSubclassReference-head = Quita la referencia a la subclase especifica
critics.CrSubclassReference-desc = La clase <ocl>self</ocl> tiene una referencia a una de sus subclases. Normalmente todas las subclases deber\u00edan ser tratadas de modo similar por la superclase.  Esto permite a\u00f1adir nuevas subclases sin modificar la superclase. \n\nDefinir las asociaciones entre objetos es una parte importante del dise\u00f1o.  Algunos patrones de asociaciones son m\u00e1s f\u00e1ciles e mantener que otros, dependiendo de la naturaleza de los cambios futuros. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente la asociaci\u00f3n pulsando en ella en el diagrama y pulsando Delete. 
critics.CrTooManyAssoc-head = Reduce las asociaciones en <ocl>self</ocl>
critics.CrTooManyAssoc-desc = Hay demasiadas asociaciones en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir las asociaciones entre los objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las asociaciones manualmente pulsando en una asociaci\u00f3n en el panel de navegaci\u00f3n o diagrama y pulsando la tecla \"Del\". 
critics.CrTooManyAttr-head = Reduce los atributos de <ocl>self</ocl>
critics.CrTooManyAttr-desc = Hay demasiados atributos en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir los atributos de los objetos es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los atributos haciendo doble click en el compartimiento de la clase realzada en el diagrama y quitando la l\u00ednea de texto para un atributo. 
critics.CrTooManyClasses-head = Reduce clases en el diagrama <ocl>self</ocl>
critics.CrTooManyClasses-desc = Hay demasiados classes in <ocl>self</ocl>.  Si un diagrama de clases tiene demasiadas clases puede resultar dif\u00edcil de entender. \n\nDefinir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita las clases manualmente pulsando en una clase en el panel de navegaci\u00f3n o diagrama y pulsando la tecla \"Del\".  O podr\u00edas hacer un nuevo diagrama...
critics.CrTooManyOper-head = Reduce las operaciones de <ocl>self</ocl>
critics.CrTooManyOper-desc = Hay demasiadas operaciones en la clase <ocl>self</ocl>.  Cuando una clase es centraliza demasiado el dise\u00f1o puede convertirse en un cuello de botella que debe ser acutalizado frecuentemente. \n\nDefinir las operaciones de un objeto es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los atributos haciendo doble click en el compartiemiento de la operaci\u00f3n de la clase realzada en el diagrama y quitando la l\u00ednea de texto para la operaci\u00f3n. 
critics.CrTooManyStates-head = Reduce estados en la m\u00e1quina <ocl>self</ocl>
critics.CrTooManyStates-desc = Hay demasiados estados en <ocl>self</ocl>.  Si una m\u00e1quina de estados tiene demasiados estados puede resultar dif\u00edcil de entender. \n\nDefinir un conjunto de estados f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente los estados pulsando en los estados en el panel de navegaci\u00f3n o el diagrama y pulsando la tecla \"Del\".  O podr\u00edas anidar estados...
critics.CrTooManyTransitions-head = Reduce transitions en <ocl>self</ocl>
critics.CrTooManyTransitions-desc = Hay demasiadas transiciones en el estado <ocl>self</ocl>.  Cuando un estado queda demasiado centralizado en la m\u00e1quina puede convertirse en un cuello de botella que requiera frecuentes actualizaciones. \nDefinir las transiciones entre estados es una parte importante del dise\u00f1o. \n\nPara arreglar esto, pulsa el bot\u00f3n \"Siguiente>\", o quita manualmente las transiciones pulsando en una transici\u00f3n en el panel de navegaci\u00f3n o diagramay pulsando la tecla \"Del\". 
critics.CrUnconventionalAttrName-head = Escoge un nombre de MAttribute m\u00e1s adecuado
critics.CrUnconventionalAttrName-desc = Normalmente los nombres de atributos comienzan con una letra min\u00fascula. El nombre '<ocl>self</ocl>' es poco convencional porque no comienza por min\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para give it a name.
critics.CrUnconventionalAttrName-ins = Cambie el nombre del atributo para que empiece con \
	una m\u00ednuscula.
critics.CrUnconventionalClassName-head = Capitaliza el nombre de clase <ocl>self</ocl>
critics.CrUnconventionalClassName-desc = Normalmente el nombre de las clases comienza con may\u00fascula. El nombre '<ocl>self</ocl>' es poco convencional porque no comienza con may\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente.
critics.CrUnconventionalClassName-ins = Cambie el nombre de la clase para que empiece con una \
	may\u00fascula.
critics.CrUnconventionalOperName-head = Escoge un nombre de MOperation m\u00e1s adecuado
critics.CrUnconventionalOperName-desc = Normalmente los nombres de operaci\u00f3n comienzan con una letra min\u00fascula. El nombre '<ocl>self</ocl>' no es convencional porque no comienza por min\u00fascula.\n\nSeguir buenas convenciones de nombres facilita el entendimiento y mantenibilidad del dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para darle un nombre.
critics.CrUnconventionalOperName-ins = Cambie el nombre de la operaci\u00f3n para comenzar con \
	una letra min\u00fascula.
critics.CrUnconventionalOperName-ins-ext = Cambie el nombre de la operaci\u00f3n para que empiece con \
	una min\u00fascula o haga un constructor.
critics.CrUnconventionalPackName-head = Revisa el nombre del paquete <ocl>self</ocl>
critics.CrUnconventionalPackName-desc = Normalmente los nombres de paquetes estan escritos en min\u00fasculas con puntos para indicar paquetes \"anidados\".  El nombre '<ocl>self</ocl>' no es aconsejable porque no esta formado por min\u00fasculas y puntos.\n\nSeguir las convenciones para asignar nombres ayuda a entender y mantener el dise\u00f1o. \n\nPara arreglar esto, usa el bot\u00f3n \"Siguiente>\", o selecciona manualmente <ocl>self</ocl> y usa la solapa Propiedades para asignarle un nombre diferente.
critics.CrUnconventionalPackName-ins = Cambie el nombre de este paquete.
critics.CrUnnavigableAssoc-head = Haz navegable a <ocl>self</ocl>
critics.CrUnnavigableAssoc-desc = La MAssociation <ocl>self</ocl> no es navegable en ninguna direcci\u00f3n. Todas las asociaciones deber\u00edan ser navegables al menos en una direcci\u00f3n.\n\nEstablecer la navegabilidad de las asociaciones permite al c\u00f3digo acceder a los datos siguiendo los punteros. \n\nPara arreglar esto, selecciona la asociaci\u00f3n \"<ocl>self</ocl>\" en el diagrama o panel de navegaci\u00f3n y haz click en la solapa de propiedades.  Luego usa los checkboxes al fondo del panel de propiedades para activar la navegabilidad. 
critics.CrUselessAbstract-head = Define (Sub)Clases concretas
critics.CrUselessAbstract-desc = <ocl>self</ocl> resulta superfluo en el sistema porque ni \u00e9l ni sus subclases pueden tener instancias. \n\nPara areglar este problem : (1) define subclases concretas que implementen el interface de esta clase; o (2) haz concreto <ocl>self</ocl> o una de sus subclases .
critics.CrUselessInterface-head = Define una class para implementar <ocl>self</ocl>
critics.CrUselessInterface-desc = <ocl>self</ocl> no es usado porque ninguna clase lo implementa.\n\nPara arreglar este problema, pulsa el bot\u00f3n \"Siguiente>\" o usa el bot\u00f3n \"Class\" de la barra de herramientas para definir clases y el bot\u00f3n \"Realizes\" para crear una relaci\u00f3n de la clase al interfaz realzado.
critics.CrUtilityViolated-desc = <ocl>self</ocl> est\u00e1 marcado con el estereotipo \
        <<utility>>; pero no safisface las restricciones \
        impuestas en Utilidades.\nTiene atributos de instancia, variables u \
        operaciones.\n\nSi no quiere que la clase sea una Utilidad, \
        quite el estereotipo <<utility>> seleccionando la clase y \
        escogiendo la selecci\u00f3n en blanco en el menu de la pesta\u00f1a Propiedades.\n
critics.CrUtilityViolated-head = Estereotipo Utilidad err\u00f3neo. Instancias pueden ser \
        creadas.
critics.CrWrongLinkEnds-head = Los LinkEnds no tienen el mismo emplazamiento
critics.CrWrongLinkEnds-desc =  En los diagramas de despliegue los objetos pueden residir en componentes o en instancias de componentes. Por tanto, no es posible tener dos objetos conectados con un Link, estando un objeto en un componente y otro en una instancia de un componente.\n\n Para arreglar esto quita un objetos de los dos conectados de su emplazamiento a un elemento que tenga el mismo tipo que el emplazamiento del otro objeto
critics.CrZeroLengthEdge-head = Haz el borde m\u00e1s visible
critics.CrZeroLengthEdge-desc = Esta l\u00ednea es demasiado peque\u00f1a para ser vista con facilidad. Esto puede ocultar informaci\u00f3n importante y hacer el dise\u00f1o m\u00e1s dif\u00edcil de entender. Una apariencia cuidada ayuda a otros dise\u00f1adores, implementadores, y analistas.\n\nConstruir un conjunto de diagramas de clases f\u00e1cil de entender es una parte importante del dise\u00f1o. \n\nPara arreglar esto, mueve uno o m\u00e1s nodos de modo que las l\u00edneas realzadas sean m\u00e1s largas, o pulsa en el centro de la l\u00ednea y arrastra para hacer un nuevo vertice.

critics.WizAddInstanceVariable-ins = Por favor cambie el nombre del elemento del modelo culpable
critics.WizAddConstructor-ins = Por favor cambie el nombre del elemento del modelo culpable.
critics.WizAssocComposite-ins = Por favor seleccione uno de las siguientes opciones de agregaci\u00f3n: 
critics.WizAssocComposite-option1 = es una agregaci\u00f3n compuesta de  
critics.WizAssocComposite-option2 = es una agregaci\u00f3n compartida de 
critics.WizAssocComposite-option3 = No agregaci\u00f3n
critics.WizBreakCircularComp-ins1 = Por favor selecciones una de las siguientes clases. \
	En los siguientes dos pasos una asociaci\u00f3n se har\u00e1 no agregada. 
critics.WizBreakCircularComp-ins2 = Por favor selecciones una de las siguientes asociaciones. \
	En el siguiente paso esa asociaci\u00f3n se har\u00e1 no agregrada.
critics.WizBreakCircularComp-ins3 = \u00bfEst\u00e1 usted seguro de que quiere hacer esta asociaci\u00f3n \
	no agregada?
critics.WizBreakCircularComp-from = desde
critics.WizBreakCircularComp-to = a
critics.WizManyNames-ins = Cambiar cada nombre para ser significativamente diferente a \
	los otros. Los nombres deber\u00eda diferenciarse en m\u00e1s de un caracter y \
	no s\u00f3lo diferir por las may\u00fasculas.
critics.WizMEName-ins = Por favor cambie el nombre del elemento del modelo culpable.
critics.WizNavigable-ins = Por favor seleccione una de las siguientes opciones de navegabilidad. 
critics.WizNavigable-option1 = Navegable hacia el comienzo
critics.WizNavigable-option2 = Navegable hacia el fin 
critics.WizNavigable-option3 = Navegable en ambos sentidos 
critics.WizNavigable-option4 = Navegable hacia  
critics.WizNavigable-option5 = Navegable hacia 
critics.WizOperName-options1 = Esto es realmente un constructor.
critics.WizOperName-options2 = Esto no es un constructor. 
critics.WizOperName-stereotype = Este operador es ahora un constructor. 
critics.WizTooMany-ins = Por favor ajuste el de acuerdo a sus necesidades. \
	Esto le permite ajustar cuando la cr\u00edtica crea un particular ToDoItem. 
