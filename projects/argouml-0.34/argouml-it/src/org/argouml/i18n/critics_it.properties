# $Id: critics_it.properties 139 2010-01-12 18:36:12Z linus $
# Copyright (c) 2003-2006 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Le chiavi sono in ordine alfabetico
#

critics.CrAlreadyRealizes-desc=La classe selezionata realizza giá indirettamente l'Interfaccia {item.extra}.  Non c'è bisogno di realizzarla un'altra volta.\n\
		\n\
		Semplificare il disegno è sempre una buona idea. Puoi eliminare questo "to do" item se vuoi rendere esplicito che la Classe selezionata realizza l'interfaccia.\n\
		\n\
		
critics.CrAlreadyRealizes-head=Togli "Realizza" non necessari da <ocl>self</ocl>
critics.CrAssocNameConflict-desc=Ogni elemento di un namespace deve avere un nome univoco.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente gli elementi e usa la Proprietà tab per cambiarne i nomi.
critics.CrAssocNameConflict-head=Risolvi Conflitto nell'Associazione di Nomi
critics.CrAttrNameConflict-desc=Gli Attributi devono avere nomi distinti. Questa critica potrebbe essere stata causata dal nome di un attributo ereditato.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente gli attributi di questa classe e cambiane i nomi.
critics.CrAttrNameConflict-head=Revisiona i Nomi degli Attributi per Evitare Conflitti
critics.CrCallWithoutReturn-desc=Ogni azione -chiama o -invia- richiede un'azione -ritorno,\n\
		ma questo Collegamento non ha nessuna azione -ritorno.
critics.CrCallWithoutReturn-head=Azioni-Ritorno Mancanti
critics.CrCircularAssocClass-desc=Classi di Associazione non possono includere regole che auto-referenzino direttamente le Classi di Associazione.
critics.CrCircularAssocClass-head=Associazione Circolare
critics.CrCircularComposition-desc=Le relazioni di composizione (i diamanti neri) non possono avere cicli.\n\
		\n\
		Una gerarchia di aggregazioni legale è necessaria per la generazione di codice e la correttezza del disgeno\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente una delle associazioni del ciclo e rimuovila o cambia le sue aggregazioni a qualcosa di diverso dal composito.
critics.CrCircularComposition-head=Rimuovi Composizione Circolare
critics.CrCircularInheritance-desc=Le relazioni di ereditarietà non possono avere cicli.\n\
		\n\
		Una gerarchia di ereditarietà legale è necessaria per la generazione di codice e la correttezza del disegno.
critics.CrCircularInheritance-head=Rimuovi l'Ereditarietà Circolare di <ocl>self</ocl>
critics.CrClassMustBeAbstract-desc=Le classi che includono o ereditano metodi astratti dalle classi padri o da interfacce devono essere segnate come astratte.\n\
		\n\
		Decidere quali classi sono astratte o concrete è un parte cruciale del disegno di una gerarchia di classi.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente la classe e usa la scheda proprietà per aggiungere la parole chiave Abstract, o implementa manualmente ogni operazione astratta ereditata da una classe base o da un'interfaccia.
critics.CrClassMustBeAbstract-head=La Classe <ocl>self</ocl> Deve Essere Astratta
critics.CrClassWithoutComponent-desc=Nei diagrammi di dispiegamento le classi di solito sono dentro ai componenti
critics.CrClassWithoutComponent-head=La Classi Di Solito Sono Dentro Ai Componenti
critics.CrCompInstanceWithoutNode-desc=Ci sono nodi-istanze nel Diagramma. Così hai un vero diagramma\n\
		di dispiegamento, e nei diagrammi di dispiegamento le istanze-Componenti\n\
		risiedono solitamente nei nodi-istanze.
critics.CrCompInstanceWithoutNode-head=Le Istanze Componenti Normalmente Sono Dentro Ai Nodi
critics.CrComponentWithoutNode-desc=Ci sono nodi nel diagramma. Così, hai un vedo diagramma di\n\
		dispiegamento, e nei diagrammi di dispiegamento i componenti\n\
		risiedono solitamente nei nodi.
critics.CrComponentWithoutNode-head=I Componenti Di Solito Sono Dentro Ai Nodi
critics.CrConflictingComposites-desc=
critics.CrConsiderSingleton-desc=<ocl>self</ocl> ha solo attributi statici, e non ha associazioni che siano raggiungibili da istanze di questa classe. Questo significa che ogni istanza di questa classe sarà identica alle altre, dato che non ci sarà nulla che le possa differenziare.\n\
		\n\
		Date le circostanze, potresti prendere in considerazione di rendere esplicita la presenza di un'unica istanza di questa classe, usando il Pattern Singleton. L'uso di quest'ultimo può far risparmiare sui tempi di esecuzione e sull'utilizzo della memoria. Dentro ad ArgoUML, ciò si può fare usando lo stereotipo <<singleton>> su questa classe.\n\
		\n\
		Se non è tua intenzione avere una singola istanza, dovresti definire variabili d'istanza (es: attributi non statici) e/o associazioni in uscita che rappresentino differenze tra le istanze.\n\
		\n\
		Specificando <ocl>self</ocl> come Singleton, dovrai definire la classe in modo che ci possa essere solo una singola istanza. Questo completerà la parte di rappresentazione del tuo disegno. Per farlo dovrai procedere nel seguente modo:\n\
		\n\
		1. Definire un'attributo statico (una variabile di classe) che mantenga l'istanza. Pertanto ques'ultima deve avere <ocl>self</ocl> come suo tipo.\n\
		\n\
		2. Fornire solo costruttori privati per <ocl>self</ocl>, in modo che non si possano ottenere nuove istanze da codice esterno. La creazione di una singola istanza potrebbe avvenire attraverso un'opportuna operazione d'appoggio, che invochi questo costruttore privato un'unica volta.\n\
		\n\
		3. Fornire almeno un costruttore che sovrascriva il costruttore di default, in modo che il costruttore di default non sia usato per creare istanze multiple.\n\
		\n\
		Nello standard UML 1.4, un costruttore è un'operazione con lo stereotipo <<crea>>.\n\
		\n\
		Per convenzione in Java e C++ un costruttore ha lo stesso nome della classe, non è statico, e non restituisce valori. Nota che in ArgoUML ciò significa che bisogna togliere il valore di ritorno creato di default dall'operazione costruttore.
critics.CrConsiderSingleton-head=Considera l'Uso del Pattern Singleton per <ocl>self</ocl>
critics.CrConstructorNeeded-desc=Non hai definito un costruttore per la classe <ocl>self</ocl>. I costruttori inizializzano le nuove istanze in modo che i loro attributi abbiano valori validi. Questa classe probabilmente ha bisogno di un costruttore, perchè non tutti i suoi attributi hanno valori iniziali.\n\
		\n\
		Definire buoni costruttori è un punto cruciale nello stabilire classi invarianti, e le classi invarianti sono un potente aiuto nella scrittura di codice solido.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente un costruttore cliccando su <ocl>self</ocl> nel pannello di navigazione e aggiungendo un'operazione usando la pop-up sensibile al contesto nella scheda proprietà, o seleziona <ocl>self</ocl> dove appare nel diagramma di classi e usa lo strumento "Aggiungi Operazione". Poi usa la scheda proprietà nel Pannello Dettagli per selezionare lo stereotipo <<crea>> sull'operazione.\n\
		\n\
		Un costruttore è un'operazione con lo stereotipo <<crea>>.
critics.CrConstructorNeeded-head=Aggiungi Costruttore a <ocl>self</ocl>
critics.CrCrossNamespaceAssoc-desc=Ogni classe, interfaccia o altro classificatore (<ocl>self</ocl>) coinvolto in un'associazione dovrebbe essere nel namespace dell'associazione.\n\
		\n\
		Se questo non è il caso, allora non ci sarà modo per le classi, interfacce o altri classificatori di referenziare gli altri usando l'associazione.\n\
		\n\
		Nota che questa critica attualmente non interpreta i namespace in modo gerarchico. Verrà chiamata se i componenti finali dei namespace sono differenti, anche se condividono una radice comune, e questa critica dovrebbe essere interpretata alla luce di tutto ciò.\n\
		\n\
		Per risolvere il problema, cancella l'associazione, e ricreala in un diagramma il cui namespace includa le classi, interfacce e i classificatori coinvolti.
critics.CrCrossNamespaceAssoc-head=Classificatore <ocl>self</ocl> non nel Namespace delle sue Associazioni
critics.CrDisambigClassName-desc=Ogni classe e interfaccia appartenenti ad uno stesso pacchetto devono avere un nome univoco. Ci sono almeno due elementi in questo pacchetto chiamati "<ocl>self</ocl>.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice ed aiuta a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente una delle classi in conflitto ed utilizza la scheda Proprietà per cambiarne i nomi.
critics.CrDisambigClassName-head=Scegli un Nome Univoco per <ocl>self</ocl>
critics.CrDisambigStateName-desc=Ogni stato in una macchina a stati deve avere un nome univoco. Ci sono almeno due stati in questa macchina chiamata "<ocl>self</ocl>".\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice ed aiuta a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente uno degli stati in conflitto ed utilizza la scheda Proprietà per cambiarne i nomi.
critics.CrDisambigStateName-head=Scegli un Nome Univoco per <ocl>self</ocl>
critics.CrDupParamName-desc=Ogni parametro di un'operazione deve avere un nome univoco.\n\
		\n\
		Una nomenclatura pulita e non ambigua è necessaria per la generazione di codice e per ottenere un disegno più chiaro e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rinomina manualmente uno dei parametri di questa operazione.
critics.CrDupParamName-head=Nome Parametro Duplicato
critics.CrDupRoleNames-desc=L'Associazione <ocl>self</ocl> ha due (o più) ruoli con lo stesso nome.\n\
		\n\
		Una nomenclatura pulita e non ambigua è necessaria per la generazione di codice e per ottenere un disegno più chiaro e mantenibile.\n\
		\n\
		Per risolvere il problema seleziona manualmente <ocl>self</ocl> ed utilizza la scheda Proprietà per cambiare uno o più nomi in conflitto.\n\
		
critics.CrDupRoleNames-head=Nome di Fine (Ruolo) Duplicato per <ocl>self</ocl>
critics.CrEmptyPackage-desc=Non hai inserito nulla nel pacchetto <ocl>self</ocl>. Solitamente i pacchetti contengono grouppi di classi relazionate.\n\
		\n\
		Definire ed usare pacchetti è un punto chiave per creare un disegno mantenibile.\n\
		\n\
		Per risolvere il problema, seleziona il pacchetto <ocl>self</ocl> nel pannello di navigazione ed aggiungi diagrammi od elementi di modello come classi o casi d'uso.\n\
		
critics.CrEmptyPackage-head=Aggiungi Elementi al Pacchetto <ocl>self</ocl>
critics.CrFinalSubclassed-desc=La parola chiave 'final' indica che non si permetta ad una classe di avere sottoclassi. Questa classe o interfaccia è marcata come 'final' e ha sottoclassi.\n\
		\n\
		Una gerarchia di ereditarietà ben pensata che trasmetta informazioni e supporti estensioni ordinate è una parte importante nel conseguimento di un disegno comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente la classe e cambiale la classe base, o seleziona la classe base e usa la scheda Proprietà per rimuovere la parola chiave 'final'
critics.CrFinalSubclassed-head=Rimuovi la Parola Chiave Final o Rimuovi le Sottoclassi da <ocl>self</ocl>
critics.CrForkOutgoingTransition-desc=La fonte di <ocl>self</ocl> è uno Pseudostato Ramificato ma il suo obiettivo non è uno Stato. Un segmento ramificato dovrebbe sempre puntare ad uno stato.\n\
		\n\
		Definire transazioni valide è necessario per completare la parte di specifiche comportamentali del tuo disegno.\n\
		\n\
		Per risolvere questo problema, rimuovi questa transazione cliccando sulla transazione nel diagramma e premendo la combinazione di tasti "Ctrl-Delete". Puoi anche cambiare la sorgente della transazione o gli stati destinazione
critics.CrForkOutgoingTransition-head=Obiettivo non valido per la transazione
critics.CrIllegalGeneralization-desc=Gli elementi di un modello possono ereditare solo da altri dello stesso tipo.\n\
		\n\
		Una gerarchia d'ereditarietà legale è necessaria per la generazione di codice e la correttezza del disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente la freccia generalizzazione e rimuovila.
critics.CrIllegalGeneralization-head=Generalizzazione Illegale
critics.CrIllegalName-desc=I nomi degli elementi del modello devono essere sequenza di lettere, numeri e trattini bassi. Non possono contenere punteggiatura.\n\
		\n\
		La generazione di codice richiede nomi legali per il codice risultante al fine di compilare correttamente.\n\
		\n\
		Per risolvere il problema, seleziona manualmente l'elemento selezionato ed utilizza la scheda Proprietà per dargli un nome differente.
critics.CrIllegalName-head=Scegli un Nome Legale per <ocl>self</ocl>
critics.CrInstanceWithoutClassifier-desc=Le istanze hanno un classificatore
critics.CrInstanceWithoutClassifier-head=Setta Classificatore
critics.CrInterfaceAllPublic-desc=Si suppone che le interfacce specifichino la gamma di operazioni che le altre classi devono implementare. Devono essere pubbliche.\n\
		\n\
		Una gamma di interfacce ben disegnato è un buon metodo di definire le possibili estensioni di una struttura di classi.+\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente le operazioni dell'interfaccia ed usa la scheda Proprietà per farle diventare pubbliche.
critics.CrInterfaceAllPublic-head=Le Operazioni nelle Interfacce devono essere Pubbliche
critics.CrInterfaceOperOnly-desc=Si suppone che le interfacce specifichino la gamma di operazioni che\n\
		le altre classi devono implementare. Non implementano queste stesse\n\
		operazioni, nè possono avere attributi.\n\
		\n\
		Una gamma di interfacce ben disegnato è un buon metodo di definire le possibili estensioni di una struttura di classi.+\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente l'interfaccia ed usa la scheda Proprietà per rimuovere tutti gli attributi.
critics.CrInterfaceOperOnly-head=Le interfacce possono solo Avere Operazioni
critics.CrInterfaceWithoutComponent-desc=Nei Diagrammi di Dispiegamento le interfacce sono di solito interne ai componenti
critics.CrInterfaceWithoutComponent-head=Le Interfacce Di Solito Sono Interne ai Componenti
critics.CrInvalidBranch-desc=Questo ramo di uno stato (scelta o giunzione) ha un numero non valido di transazioni.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, aggiungi delle transazioni usando lo strumento transazione.
critics.CrInvalidBranch-head=Aggiungi Transazioni di Scelta/Giunzione
critics.CrInvalidFork-desc=Questo stato ramificazione ha un numero non valido di transazioni. Di solito gli stati di ramificazione hanno una transazione in entrata e due in uscita.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, aggiungi o rimuovi le transazioni manualmente.
critics.CrInvalidFork-head=Cambia le Transazioni di Ramificazione
critics.CrInvalidForkTriggerOrGuard-desc=La Transazione sottolineata non dovrebbe avere attivazioni o presidi perchè è una transazione in uscita di uno PseudoStato Ramificazione. Le transazioni in uscita dal vertice di una ramificazione non devono avere vincoli o presidi.\n\
		\n\
		Definire transazioni valide è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, rimuovi il vincolo selezionandolo nel pannello di esplorazione e rimuovilo dal modello con il menù attivabile da tasto destro. O, nel caso di un presidio, rimuovilo facendo doppio click nel campo presidio della transazione e premendo il tasto "Ctrl-Delete".
critics.CrInvalidForkTriggerOrGuard-head=Rimuovi Vincolo o Presidio dalla Transazione in Uscita della Ramificazione.
critics.CrInvalidHistory-desc=Questo stato Storico ha un numero non valido di transazioni. Di solito stati Storici Superficiali e Storici Profondi hanno al massimo una transazione in uscita.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, rimuovi le transazioni clicckando sulla transazione nel diagramma e premendo i tasti "Ctrl-Delete".
critics.CrInvalidHistory-head=Rimuovi Transazioni in Uscita Extra
critics.CrInvalidInitial-desc=Questo stato Iniziale ha un numero non valido di transazioni. Di solito gli stati Iniziali hanno al massimo una transazioni in uscita.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, rimuovi le transazioni clicckando sulla transazione nel diagramma e premendo i tasti "Ctrl-Delete".
critics.CrInvalidInitial-head=Rimuovi Transazioni in Uscita Extra
critics.CrInvalidJoin-desc=Questo stato d'unione ha un numero non valido di transazioni. Di solito gli stati d'unione hanno due o più transazioni d'entrata e una d'uscita.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, aggiungi o rimuovi le transazioni manualmente.
critics.CrInvalidJoin-head=Cambia le Transazioni d'Unione
critics.CrInvalidJoinTriggerOrGuard-desc=La Transazione sottolineata non dovrebbe avere un vincolo o presidio in quanto è una transazione in ingresso di uno PsuedoStato Unione. La transazioni in ingresso ad un vertice di un unione non devono avere vincoli o presidi.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per rimuovere questo problema, rimuovi i il vincolo selezionandolo nel pannello d'esplorazione e rimuovendolo dal modello attraverso il menù attivabile col tasto destro del mouse. O, nel caso di un presidio, rimuovilo facendo doppio click sul campo presidio e premendo i tasti "Ctrl-Delete".
critics.CrInvalidJoinTriggerOrGuard-head=Rimuovi Vincolo o Presidio dalla Transazione Ingresso di un Unione
critics.CrInvalidPseudoStateTrigger-desc=La Transazione sottolineata non dovrebbe avere un vincolo in quanto è una transazione in uscita di uno PsuedoStato. La transazioni in uscita di uno pseudostato non possono avere vincoli.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per rimuovere questo problema, rimuovi i il vincolo selezionandolo nel pannello d'esplorazione e rimuovendolo dal modello attraverso il menù attivabile col tasto destro del mouse.
critics.CrInvalidPseudoStateTrigger-head=Rimuovi il Vincolo dalla Transazione in Uscita dello PseudoStato
critics.CrInvalidSynch-desc=Questo stato sincronizzazione ha transazioni non valide. Di solito tutte le transazioni in ingresso ad uno stato sincronizzazione provengono dalla stessa regione e tutte le transazioni d'uscita vanno alla stessa regione. Inoltre, i contenitori degli stati delle transazioni di origine e destinazione devono essere regioni concorrenti.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per rimuovere questo problema, rimuovi le transazioni cliccando sulla transazione nel diagramma e premendo i tasti "Ctrl-Delete". Puoi anche cambiare gli stati delle transazioni d'origine o la destinazione.
critics.CrInvalidSynch-head=Cambia le Transazione dello Stato Sincronizzazione
critics.CrJoinIncomingTransition-desc=La destinazione di <ocl>self</ocl> è uno PseudoStato Unione ma la sua origine non è uno Stato. Un segmento unione dovrebbe sempre originarsi da uno stato.\n\
		\n\
		Definire stati di transazione corretti è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per rimuovere questo problema, rimuovi le transazioni cliccando sulla transazione nel diagramma e premendo i tasti "Ctrl-Delete". Puoi anche cambiare gli stati delle transazioni d'origine o la destinazione.
critics.CrJoinIncomingTransition-head=Origine non valida per la transazione
critics.CrLinkWithoutStimulus-desc=Nei diagrammi di sequenza un oggetto mittente invia stimoli\n\
		all'oggetto ricevente attraverso un collegamento. Il collegamento\n\
		è solo la comunicazione-connessione, quindi c'è bisogno anche di\n\
		uno stimolo.
critics.CrLinkWithoutStimulus-head=Nessuno Stimolo su Questi Collegamenti
critics.CrMergeClasses-desc=La classe selezionata, <ocl>self</ocl>, partecipa solo in un'associazione e quell'associazione è in rapporto uno-a-uno con un'altra classe. Dato che le istanze di queste due classi devono sempre essere create e distrutte insieme, combinare queste classi potrebbe semplificare il tuo disegno senza perdere potere rappresentativo. Ad ogni modo, potresti trovare la classe combinata troppo larga e complessa, nel qual caso tenere le classi separate è solitamente migliore.\n\
		\n\
		Organizzare le classi per gestire la complessità del disegno è sempre importante, specialmente quando anche il disegno è complesso.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi manualmente gli attributi e le operazioni della classe selezionata alle altre classi, dopodichè rimuovi la classe selezionata dal progetto.
critics.CrMergeClasses-head=Considera una Combinazione di Classi (<ocl>self</ocl>)
critics.CrMissingAttrName-desc=Ogni attributo deve avere un nome.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente l'attributo e usa la scheda Proprietà per dargli un nome.
critics.CrMissingAttrName-head=Scegli un Nome
critics.CrMissingClassName-desc=Ogni classe ed interfaccia dentro un pacchetto deve avere un nome.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente la classe ed usa la scheda Proprietà per darle un nome.
critics.CrMissingClassName-head=Scegli un Nome
critics.CrMissingOperName-desc=Ogni operazione deve avere un nome.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente l'operazione ed usa la scheda Proprietà per darle un nome.
critics.CrMissingOperName-head=Scegli un Nome
critics.CrMissingStateName-desc=Ogni stato dentro un sistema di stati dovrebbe avere un nome.\n\
		\n\
		Una nomenclatura chiara e non ambigua è un elemento chiave nella generazione di codice e serve a creare un disegno più comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente lo stato ed usa la scheda Proprietà per dargli un nome, o seleziona lo stato e scrivi un nome.
critics.CrMissingStateName-head=Scegli un Nome
critics.CrMultiComposite-desc=Un'istanza non può appartenere appartenere da una composizione a più di un'istanza composta. Devi cambiare la moltiplicità dell'associazione alla fine della composta a 0..1 o 1..1 (1) affinchè il tuo modello abbia senso.\n\
		\n\
		Ricorda che la composizione è il più forte tipo di aggregazione e l'aggregazione è la più debole. Il problema può essere comparato ad un modello dove un dito possa essere parte integrante di diverse mani contemporaneamente.\n\
		\n\
		Questa è la seconda regola di "buona forma" delle Associazioni Finali di UML 1.4.
critics.CrMultiComposite-head=Composizione di Associazione Finale con Molteplicità > 1
critics.CrMultipleAgg-desc=Solo un (ruolo) fine di un'Associazione binaria può essere aggregato o composto.\n\
		\n\
		L'aggregazione e la composizione sono usate per indicare intere parti di relazioni, e, per definizione, la "parte" finale non può essere un'aggregazione.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >" per usare la procedura guidata , o seleziona manualmente l'Associazione e setta il nome dei suoi ruoli aggregazione a "Nessuno"..
critics.CrMultipleAgg-head=Due (Ruoli di) Aggregazioni Finali in un'Associazione Binaria
critics.CrMultipleDeepHistoryStates-desc=Ci sono molteplici,ambigui stati storici profondo in questo stato sistema o composto. Di solito ogni stato sistema o composto ha solo uno stato storico profondo.\n\
		\n\
		Definire stati storici non ambigui è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere questo problema, seleziona uno degli stati storici profondi e cancellalo premendo i tasti "Ctrl-Delete".
critics.CrMultipleDeepHistoryStates-head=Rimuovi gli Stati Storici Profondi Extra
critics.CrMultipleInheritance-desc=<ocl>self</ocl> ha divere classi base, ma Java non supporta l'ereditarietà multipla. Al loro posto dovresti usare delle interfacce.\n\
		\n\
		Questo cambio è richiesto prima che tu possa generare codice Java.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente (1) una delle classi base e poi (2) definisci (opzionalmente) una nuova interfaccia con le stesse dichiarazioni di metodi e (3) aggiungila come un'interfaccia di <ocl>self</ocl>, infine (4) sposta i corpi dei metodi dalla vecchia classe base in <ocl>self</ocl>.
critics.CrMultipleInheritance-head=Cambia l'Ereditarietà Multipla in Interfacce
critics.CrMultipleInitialStates-desc=Ci sono stati iniziali multipli e ambigui in questo sistema o stato composto. Di solito ogni sistema di stati o stato composto ha un solo stato iniziale.\n\
		\n\
		Definire stati non ambigui è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente uno degli stati iniziali extra e rimuovilo.
critics.CrMultipleInitialStates-head=Rimuovi gli Stati Iniziali Extra
critics.CrMultipleRealization-desc=<ocl>self</ocl> implementa interfacce multiple. Nonostante questo sia legale in UML questo codice non compilerà in Java. Rimpiazza le realizzazioni multiple con generalizzazioni se vuoi creare codice compilabile e senza errori.
critics.CrMultipleRealization-head=Cambia Realizzazioni Multiple di <ocl>self</ocl> in Generalizzazioni
critics.CrNWayAgg-desc=Associazioni a tre (o più) vie non possono avere finali (di ruoli) aggregati.\n\
		\n\
		L'aggregazione e la composizione sono usate per indicare parti complete di relazioni, e per definizione si possono applicare solo ad associazioni binarie tra artefatti.\n\
		\n\
		Per risolvere questo problema, seleziona manualmente l'Associazione e setta l'aggregazione di ognuna dei suoi ruoli finali a Nessuno.
critics.CrNWayAgg-head=Finali (di Ruoli) Aggregati in un'Associazione a Tre (o più) Vie
critics.CrNameConflict-desc=I nomi degli elementi contenuti in un namespace (es: pacchetti) devono essere univoci. L'elemento <ocl>self</ocl> viola questa condizione. Questa condizione non si applica per nomi di Associazioni o Generalizzazioni.
critics.CrNameConflict-head=Conflitto di Nomi Causato da <ocl>self</ocl>
critics.CrNameConflictAC-desc=I nomi dei ruoli associazione di una ClasseAssociazione non devono\n\
		essere in conflitto coi nomi delle funzionalità strutturali (es: variabili d'istanza)\n\
		della classe.
critics.CrNameConflictAC-head=Conflitti del Nome Ruolo con un Membro
critics.CrNameConfusion-desc=I nomi dovrebbero essere chiaramente distinti l'uno dall'altro. Questi due nomi sono così simili tra loro che i lettori potrebbero essere confusi.\n\
		\n\
		Clear and unambiguous naming is a key element in code generation and serves to make the design more understandable and maintainable. \n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente  gli elementi ed usa la scheda Proprietà per cambiarne i nomi. Evita nomi che differiscano dagli altri solo per maiuscole/minuscole, o per caratteri con trattino basso, o per solo un carattere.
critics.CrNameConfusion-head=Revisiona i Nomi per Evitare Confusione
critics.CrNavFromInterface-desc=Associazioni che coinvolgano un'interfaccia potrebbero non essere navigabili nella direzione dall'interfaccia. Questo a causa del fatto che le interfacce contengono solo dichiarazioni di operazioni e non possono mantenere puntatori ad altri oggetti.\n\
		\n\
		Questa parte del disegno dovrebbe essere cambiata prima di essere usata nella generazione di codice. Il codice generato senza risolvere questo problema non coinciderà col disegno voluto.\n\
		\n\
		Per risolvere il problema, seleziona l'associazione ed usa la scheda "Proprietà" per selezionare a turno ogni fine associazione che NON sia connessa all'interfaccia. Deseleziona "Navigabile" per ognuna di queste fini.\n\
		\n\
		NOTA: ArgoUML non dovrebbe permettere la creazione di associazioni che siano navigabili dalle interfacce.\n\
		\n\
		ATTENZIONE: La versione attuale di ArgoUML ha un bug noto per il quale viene creata un'associazione tra una classe e interfaccia che è navigabile in entrambe le direzioni, o navigabile solo dall'interfaccia alla classe. La risoluziona consiste nel rimuovere la navigazione dalla classe finale dell'associazione e, se necessarrio, aggiungere la navigazione verso l'interfaccia finale (navigazione si riferisce alla navigabilità VERSO la fine) se questa critica è eseguita.
critics.CrNavFromInterface-head=Rimuovi la Navigazione dall'Interfaccia attraverso l'Associazione <ocl>self</ocl>
critics.CrNoAssociations-desc=Non hai specificato nessuna Associazione per <ocl>self</ocl>. Di solito le classi, gli attori e i casi d'uso sono associati con altri.\n\
		\n\
		Definire associazioni tra oggetti è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi manualmente  delle associazioni cliccando sullo strumento associazione nella barra degli strumenti e trascinandolo da <ocl>self</ocl> ad un altro nodo.\ 
critics.CrNoAssociations-head=Aggiungi Associazioni a <ocl>self</ocl>
critics.CrNoGuard-desc=La Trasposizione sottolineate non è completa in quanto non ha una condizione di presidio. Le condizioni di presidio devono essere affinchè le transazioni possano essere prese. Se si usa solo un presidio, la transazione è presa quando la condizione diventa vera.\n\
		\n\
		Questo problema deve essere risolto per completare il sistema di stati.\n\
		\n\
		Per risolvere questo problema, seleziona la Transazione e usa la scheda "Proprietà", o seleziona la Transazione e inserisci alcun testo nella forma:\n\
		[PRESIDIO]\n\
		Dove per PRESIDIO si intende un'espressione booleana.
critics.CrNoGuard-head=Aggiungi Presidio a Transazione.
critics.CrNoIncomingTransitions-desc=Lo stato <ocl>self</ocl> non ha transazioni in ingresso. Di solito gli stati hanno sia transazioni in ingresso che in uscita.\n\
		\n\
		Definire delle transazioni di stato complete è necessario per completa la parte di specifiche di comportamento del tuo disegno. Senza transazioni di ingresso, questo stato non potrà mai essere raggiunto.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi delle transazioni manualmente  cliccando sullo strumento transazione della barra degli strumenti e trascinandolo da un'altro stato a <ocl>self</ocl>.
critics.CrNoIncomingTransitions-head=Aggiungi Transazioni in Ingresso a <ocl>self</ocl>
critics.CrNoInitialState-desc=Non c'è nessuno stato iniziale in questo sistema o stato composto. Di solito ogni sistema di stati o stato composto ha uno stato iniziale.\n\
		\n\
		Definire stati non ambigui è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente lo stato iniziale dalla barra degli strumenti e piazzalo nel diagramma.
critics.CrNoInitialState-head=Inserisci uno Stato Iniziale
critics.CrNoInstanceVariables-desc=Non hai ancora specificato variabili d'istanza per <ocl>self</ocl>. Di solito le classi hanno variabili d'istanza che contengono le informazioni di stato per ogni istanza. Le classi che forniscono solo attributi e metodi statici dovrebbero essere stereotipizzate come <<utilità>>.\n\
		\n\
		Definire variabili d'istanza è necessario per completare la parte di rappresentazione delle informazioni del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi variabili d'istanza facendo doppio click su <ocl>self</ocl> nel pannello di navigazione ed usando il menù Crea per creare un nuovo attributo.
critics.CrNoInstanceVariables-head=Aggiungi Variabili d'Istanza a <ocl>self</ocl>
critics.CrNoOperations-desc=Non hai ancora specificato operazioni per <ocl>self</ocl>. Di solito le classi forniscono operazioni che definiscono il loro comportamento.\n\
		\n\
		Definire operazioni è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi operazioni manualmente cliccando su <ocl>self</ocl> nel pannello di navigazione ed usando il menù Crea per creare una nuova operazione.
critics.CrNoOperations-head=Aggiungi Operazioni a  <ocl>self</ocl>
critics.CrNoOutgoingTransitions-desc=Lo stato  <ocl>self</ocl> non ha Transazioni d'Uscita. Di solito gli stati hanno sia transazioni d'ingresso che d'uscita.\n\
		\n\
		Definire stati di transazione completi è necessario per completare la parte di specifiche di comportamento del tuo disegno. Senza transazioni d'uscita, questo stato è uno stato "morto" da cui non si potrà mai uscire.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi delle transazioni manualmente cliccando sullo strumento transazioni nella barra degli strumenti e trascinandolo da <ocl>self</ocl> ad un altro stato.
critics.CrNoOutgoingTransitions-head=Aggiungi Transazioni d'Uscita da <ocl>self</ocl>
critics.CrNoTransitions-desc=Lo stato <ocl>self</ocl> non ha transazioni d'Ingresso o d'Uscita. Di solito gli stati hanno sia transazioni d'ingresso che d'uscita.\n\
		\n\
		Definire stati di transazione completi è necessario per completare la parte di specifiche di comportamento del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi delle transazioni manualmente cliccando sullo strumento transazioni nella barra degli strumenti e trascinandolo da un altro stato a <ocl>self</ocl> o da <ocl>self</ocl> ad un altro stato.
critics.CrNoTransitions-head=Aggiungi Transazioni a <ocl>self</ocl>
critics.CrNoTriggerOrGuard-desc=La Transazione sottolineata è incompleta in quanto non ha una condizione di vincolo o presidio. I vincoli sono eventi che fanno in modo che una transazione sia catturata. Le condizioni presidio devono essere vere perchè la transazione sia catturata. Se si usa solo un presidio, la transazione è catturata quando la condizione diventa vera.\n\
		\n\
		Questo problema deve essere risolto per completare il sistema di stati.\n\
		\n\
		Per risolvere questo problema, seleziona la Transazione ed usa la scheda "Proprietà", o seleziona la Transazione e scrivi del testo in questa forma:\n\
		VINCOLO [PRESIDIO] / AZIONE\n\
		Dove per VINCOLO si intende il nome di un evento, PRESIDIO un'espressione booleana, ed AZIONE è un'azione da eseguire quando la Transazione sia catturata. Tutte e tre le parti sono opzionali.
critics.CrNoTriggerOrGuard-head=Aggiungi Vincolo o Presidio alla Transazione
critics.CrNodeInsideElement-desc=I nodi di solito non sono dentro ad altri Elementi. Rappresentano\n\
		oggetti fisici a tempo di esecuzione con una risorsa di processamento,\n\
		solitamente con almeno una memoria e spesso anche con capacità di processamento.
critics.CrNodeInsideElement-head=I Nodi Di Solito Non Hanno Inclusori
critics.CrNodeInstanceInsideElement-desc=I NodiIstanze di solito non sono dentro ad altri Elementi. Rappresentano\n\
		oggetti fisici a tempo di esecuzione con una risorsa di processamento,\n\
		solitamente con almeno una memoria e spesso anche con capacità di processamento.
critics.CrNodeInstanceInsideElement-head=I NodiIstanze Di Solito Non Hanno Inclusori
critics.CrNodesOverlap-desc=Alcuni degli oggetti di questo diagramma si sovrappongono e si nascondono l'uno con l'altro. Questo potrebbe nascondere informazioni importanti e rendere difficile la comprensione ad un umano. Un aspetto ordinato può anche rendere i tuoi diagrammi più influenti rispetto ad altri disegnatori, implementatori e a chi ha potere decisionale.\n\
		\n\
		Costruire un gruppo di diagrammi di classi comprensibile è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere questo problema, sposta i nodi evidenziati nel diagramma.
critics.CrNodesOverlap-head=Pulisci Il Diagramma <ocl>self</ocl>
critics.CrNonAggDataType-desc=I Tipi di Dati non sono classi complete e non possono essere associati a classi, a meno che il Tipo di Dato non sia una parte di un'aggregazione composta (diamante nero).\n\
		\n\
		Un buon disegno orientato agli oggetti dipende da scelte attente riguardo a quali entità rappresentano oggetti completi e quali rappresentare come attributi di oggetti.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o sostituisci manualmente il Tipo di Dato con una classe completa o cambia l'associazione di aggregazione a contenitore per una classe completa.
critics.CrNonAggDataType-head=Circonda Tipo di Dato
critics.CrObjectWithoutComponent-desc=Nei diagrammi di dispiegamento gli oggetti sono di solito dentro ai componenti o istanze di componenti
critics.CrObjectWithoutComponent-head=Gli Oggetti Sono Di Solito Dentro ai Componenti
critics.CrOperNameConflict-desc=Due operazioni in <ocl>self</ocl> hanno la stessa, identica firma. Le operazioni devono avere firme distinte. Una firma è la combinazione del nome dell'operazione dei tipi dei parametri (esclusi i parametri di ritorno).\n\
		\n\
		Firme ambigue riducono la chiarezza ed introducono potenziali processamenti non corretti. Inoltre non è possibile la generazione di codice per i principali linguaggi orientati agli oggetti.\n\
		\n\
		Per risolvere questo problema, seleziona una delle operazioni in conflitto di questa classe e cambiane il nome o i parametri.
critics.CrOperNameConflict-head=Cambia il Nome o le Firme delle Operazioni in <ocl>self</ocl>
critics.CrOppEndConflict-desc=Due ruoli di <ocl>self</ocl> hanno lo stesso nome. I ruoli devono avere nomi distinti.\n\
		\n\
		Una nomenclatura chiara e non ambigue è un punto chiave per la generazione di codice e per un disegno comprensibile e mantenibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o sostituisci manualmente uno dei ruoli in conflitto alla fine di un'associazione di questa classe e cambiane il nome.
critics.CrOppEndConflict-head=Rinomina i Ruoli dell'Associazione
critics.CrOppEndVsAttr-desc=Due attributi non possono avere lo stesso nome dentro ad un Classificatore.\n\
		\n\
		Questa è la seconda regola di buona formazione sui Classificatori in UML 1.4
critics.CrOppEndVsAttr-head=Rinomina Ruolo o Attributo
critics.CrParamTypeNotImported-desc=Il tipo di ogni parametro di un'operazione deve essere visibile ed importate nella classe che possiede l'operazione.\n\
		\n\
		Importare classi è necessario per la generazione di codice. Una buona modularità delle classi nei pacchetti è un punto chiave per un disegno comprensibile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o aggiungi manualmente un import alla classe che possiede questa operazione.
critics.CrParamTypeNotImported-head=Importa il Tipo del Parametro nella Classe
critics.CrReservedName-desc="<ocl>self</ocl>" è una parola riservata, o è molto simile a una di queste. I nomi degli elementi dei modelli non devono essere in conflitto con le parole riservate dei linguaggi di programmazione o di UML.\n\
		\n\
		Usare nomi legali è necessario per generare codice compilabile.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente l'elemento sottolineato ed usa la scheda Proprietà per dargli u nome differente.
critics.CrReservedName-head=Cambia <ocl>self</ocl> in una Parola Non Riservata
critics.CrReturnWithoutCall-desc=Ogni azione -ritorno richiede un'azione -chiama o -invia,\n\
		ma questo Collegameno non ha azioni -chiama o -invia corrispondenti
critics.CrReturnWithoutCall-head=Azione -Chiama o -Invia Mancante
critics.CrSeqInstanceWithoutClassifier-desc=Le istanze hanno un classificatore
critics.CrSeqInstanceWithoutClassifier-head=Setta Classificatore
critics.CrSingletonViolatedMissingStaticAttr-desc=<ocl>self</ocl> è contrassegnato con lo stereotipo <<singleton>>, ma non soddisfa i vincoli imposti sulle classi Singleton.\n\
		Non possiede un attributo statico (una variabile di classe) per tenere un'unica istanza.\n\
		\n\
		Ogni volta che contrassegni una classe con uno stereotipo, la classe deve soddisfare tutti i vincoli dello stereotipo. Questa è una parta importante nella costruzione di un disegno comprensibile e auto-consistente. Usare il pattern Singleton può risparmiarmiare tempo e spazio di memoria.\n\
		\n\
		Se non vuoi più che questa classe sia un Singleton, rimuovi lo stereotipo <<singleton>> cliccando sulla classe e selezionando la la selezione vuota sulla lista di stereotipo nella scheda proprietà.
critics.CrSingletonViolatedMissingStaticAttr-head=Violazione dello Stereotipo Singleton, Manca l'Attributo Statico d'Istanza in <ocl>self</ocl>
critics.CrSingletonViolatedOnlyPrivateConstructors-desc=<ocl>self</ocl> è contrassegnato con lo stereotipo <<singleton>>, ma non soddisfa i vincoli imposti sulle classi Singleton.\n\
		Deve avere solo costruttori privati in modo che le nuove istanze non possano essere fatte da codice esterno.\n\
		\n\
		Ogni volta che contrassegni una classe con uno stereotipo, la classe deve soddisfare tutti i vincoli dello stereotipo. Questa è una parta importante nella costruzione di un disegno comprensibile e auto-consistente. Usare il pattern Singleton può risparmiarmiare tempo e spazio di memoria.\n\
		\n\
		Se non vuoi più che questa classe sia un Singleton, rimuovi lo stereotipo <<singleton>> cliccando sulla classe e selezionando la la selezione vuota sulla lista di stereotipo nella scheda proprietà.
critics.CrSingletonViolatedOnlyPrivateConstructors-head=Violazione dello Stereotipo Singleton, Ha un Costruttore Non Privato in <ocl>self</ocl>
critics.CrStimulusWithWrongPosition-desc=Nei diagrammi di sequenza la parte-mittente delle connessioni di comunicazione\n\
		di questi stimoli sono connesse all'inizio di un'attivazione. Per essere mittente, un oggetto\n\
		deve prima avere una focalizzazione-di-controllo.
critics.CrStimulusWithWrongPosition-head=Posizione Errata di Questi Stimoli
critics.CrSubclassReference-desc=La classe <ocl>self</ocl> ha una referenza ad una delle sue sottoclassi. Di solito tutte le sottoclassi dovrebbero essere trattate uniformemente dalla superclasse. Ciò permette l'aggiunta di nuove sottoclassi senza modifiche alla superclasse.\n\
		\n\
		Definire le associazioni tra oggetti è una parte importante del tuo disegno. Alcuni pattern di associazioni sono meglio mantenibili di altri, a seconda della natura dei cambi futuri.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente l'associazione cliccando su di essa nel diagramma e premendo Delete.
critics.CrSubclassReference-head=Rimuovi Referenza a Sottoclasse Specifica
critics.CrTooManyAssoc-desc=Ci sono troppe associazioni sulla classe <ocl>self</ocl>. Quando una classe divente troppo centrale nel disegno, può diventare un "collo di bottiglia" per il mantenimento ed essere aggiornata di frequente.\n\
		\n\
		Definire le associazioni tra gli oggetti è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente le associazioni cliccando su di un'associazione nel pannello di navigazione o diagramma e premendo il tasto "Del".
critics.CrTooManyAssoc-head=Riduci le Associazioni su <ocl>self</ocl>
critics.CrTooManyAttr-desc=Ci sono troppi Attributi nella classe <ocl>self</ocl>. Quando una classe divente troppo centrale nel disegno, può diventare un "collo di bottiglia" per il mantenimento ed essere aggiornata di frequente.\n\
		\n\
		Definire gli attributi degli oggetti è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente gli attributi facendo doppio click sulla sezione "attributi" della classe evidenziata nel diagramma e rimuovi la linea di testo corrispondente all'attributo.
critics.CrTooManyAttr-head=Riduci gli Attributi di <ocl>self</ocl>
critics.CrTooManyClasses-desc=Ci sono troppi Attributi nella classe <ocl>self</ocl>. Se un diagramma di classi ha troppe classi può diventare di difficile comprensione per gli umani.\n\
		\n\
		Definire un'insieme di diagrammi di classi comprensibile è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente le classi cliccando su di una classe nel pannello di navigazione o diagramma e premendo il tasto "Del". Altrimenti, crea un nuovo diagramma...
critics.CrTooManyClasses-head=Riduci le Classi nel Diagramma <ocl>self</ocl>
critics.CrTooManyOper-desc=Ci sono troppe Operazioni nella classe <ocl>self</ocl>. Quando una classe divente troppo centrale nel disegno, può diventare un "collo di bottiglia" per il mantenimento ed essere aggiornata di frequente.\n\
		\n\
		Definire le operazioni degli oggetti è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente le operazioni facendo doppio click sul compartimento "operazioni" della classe evidenziata nel diagramma e rimuovi la linea di testo per un'operazione.
critics.CrTooManyOper-head=Riduci le Operazioni in  <ocl>self</ocl>
critics.CrTooManyStates-desc=Ci sono troppi Stati nella classe <ocl>self</ocl>. Se un sistema di stati ha troppi stati può diventare di difficile comprensione per gli umani.\n\
		\n\
		Definire un'insieme di stati comprensibile è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente gli stati cliccando su di uno di essi nel pannello di navigazione o diagramma e premendo il tasto "Del". Altrimenti, puoi innestare alcuni stati..
critics.CrTooManyStates-head=Riduci gli Stati nel Sistema <ocl>self</ocl>
critics.CrTooManyTransitions-desc=Ci sono troppe Transazioni nella classe <ocl>self</ocl>. Quando uno stato diventa troppo centrale nel sistema, può diventare un "collo di bottiglia" per il mantenimento ed essere aggiornata di frequente.\n\
		\n\
		Definire le transazioni tra stati è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o rimuovi manualmente le transazioni cliccando su di una transazione nel pannello di navigazione o diagramma e premendo il tasto "Del".
critics.CrTooManyTransitions-head=Riduci le Transazioni in <ocl>self</ocl>
critics.CrUnconventionalAttrName-desc=Di solito gli attributi iniziano con una lettere minuscola. Il nome '<ocl>self</ocl>' è anomalo in quanto non segue questa convenzione.\n\
		\n\
		Seguire delle buoni convenzioni di nomenclatura aiuta a migliorare la comprensibilità e mantenibilità del disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente <ocl>self</ocl> e usa la scheda Proprietà per cambiarne il nome.
critics.CrUnconventionalAttrName-head=Scegli un Nome Attributo Migliore
critics.CrUnconventionalClassName-desc=Di solito le classi iniziano con una lettere maiuscola. Il nome '<ocl>self</ocl>' è anomalo in quanto non inizia con una lettera maiuscola.\n\
		\n\
		Seguire delle buoni convenzioni di nomenclatura aiuta a migliorare la comprensibilità e mantenibilità del disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente <ocl>self</ocl> e usa la scheda Proprietà per cambiarne il nome.
critics.CrUnconventionalClassName-head=Metti un'Iniziale Maiuscola al Nome della Classe <ocl>self</ocl>
critics.CrUnconventionalOperName-desc=Di solito i nomi di un'operazione iniziano con una lettere minuscola. Il nome '<ocl>self</ocl>' è anomalo in quanto non segue questa convenzione.\n\
		\n\
		Seguire delle buoni convenzioni di nomenclatura aiuta a migliorare la comprensibilità e mantenibilità del disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente <ocl>self</ocl> e usa la scheda Proprietà per cambiarne il nome.
critics.CrUnconventionalOperName-head=Scegli un Nome Operazione Migliore
critics.CrUnconventionalPackName-desc=Di solito i nomi dei pacchetti sono scritti tutti in minuscolo, con punti a indicare i pacchetti "innestati". Il nome '<ocl>self</ocl>' è anomalo in quanto non è completamente in minuscolo e con punti.\n\
		\n\
		Seguire delle buoni convenzioni di nomenclatura aiuta a migliorare la comprensibilità e mantenibilità del disegno.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o seleziona manualmente <ocl>self</ocl> e usa la scheda Proprietà per cambiarne il nome.
critics.CrUnconventionalPackName-head=Rivedi il Nome del Pacchetto <ocl>self</ocl>
critics.CrUnnavigableAssoc-desc=L'Associazione <ocl>self</ocl> non è navigabile in nessuna direzione. Tutte le associazioni dovrebbero essere navigabili in almeno un modo.\n\
		\n\
		Settare la navigabilità delle associazioni permette al tuo codice di accedere ai dati attraverso dei puntatori.\n\
		\n\
		Per risolvere il problema,seleziona l'associazione "<ocl>self</ocl>" nel diagramma o pannello di navigazione e clicca la scheda proprietà. Dopodichè usa i checkbox in basso al pannello delle proprietà per attivare la navigabilità.
critics.CrUnnavigableAssoc-head=Rendi <ocl>self</ocl> Navigabile
critics.CrUselessAbstract-desc=<ocl>self</ocl>non potrà mai influenzare il sistema avviato in quanto non potrà mai avere nessuna istanza, così come non potrà averne nessuna delle sue sottoclassi.\n\
		\n\
		Per risolvere questo problema: (1) definire sottoclassi concrete che implementano l'interfaccia di questa classe; o (2) rendi concreta <ocl>self</ocl> o una delle sue sottoclassi esistenti.
critics.CrUselessAbstract-head=Definisci (Sotto)Classi Concrete
critics.CrUselessInterface-desc=<ocl>self</ocl> non potrà mai essere usata in quanto non ha classi che la implementino.\n\
		\n\
		Per risolvere il problema, premi il pulsante "Avanti >", o usa manualmente il pulsante "Classe" della barra degli strumenti per definire le classi e il pulsante "Realizza" per creare una relazione dalla classe all'interfaccia evidenziata.
critics.CrUselessInterface-head=Definisci una Classe per Implementare <ocl>self</ocl>
critics.CrUtilityViolated-desc=<ocl>self</ocl> è segnata con lo stereotipo <<utilità>>, ma non soddisfa i vincoli imposti sulle Utilità.\n\
		Possiede attributi, variabili od operazioni di istanza.\n\
		\n\
		Se non vuoi che questa classe continui ad essere un'Utilità, rimuovi lo stereotipo <<utilità>> cliccando sulla classe e selezionando la selezione "vuota" nel menù a cascata dentro alla scheda proprietà.
critics.CrUtilityViolated-head=Violazione dello Stereotipo Utilità, Possibilità di Creare Istanze
critics.CrWrongLinkEnds-desc=Negli diagrammi di dispiegamento gli oggetti possono stare nei componenti o\n\
		nelle istanze di componenti. Quindi non è possibile avere due oggetti connessi\n\
		con un Collegamento, mentre un'oggetto sta su di un componente e l'altro\n\
		sta su di un'istanza di un componente.\n\
		\n\
		Per risolvere questo problema rimuovi uno dei due oggetti connessi dalla sua posizione ad un altro elemento,\n\
		che sia dello stesso tipo e abbia la posizione dell'altro oggetto.
critics.CrWrongLinkEnds-head=I Collegamenti Finali Non Hanno Le Stesse Posizioni
critics.CrZeroLengthEdge-desc=Questo bordo è troppo piccolo per essere visto facilmente. Ciò potrebbe nascondere informazioni importanti e renderlo difficile per una comprensione umana. Un\n\
		\n\
		Costruire un'insieme di diagrammi comprensibili è una parte importante del tuo disegno.\n\
		\n\
		Per risolvere questo problema, sposta uno o più nodi in modo che i bordi evidenziati siano più lunghi, e clicca nel centro del bordo e trascinalo in modo da creare un nuovo vertice.
critics.CrZeroLengthEdge-head=Rendi i Bordi Più Visibili

