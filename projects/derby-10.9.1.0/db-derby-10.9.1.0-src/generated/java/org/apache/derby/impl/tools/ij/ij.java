/* Generated By:JavaCC: Do not edit this line. ij.java */
package org.apache.derby.impl.tools.ij;

import org.apache.derby.tools.JDBCDisplayUtil;


import org.apache.derby.iapi.tools.i18n.LocalizedInput;
import org.apache.derby.iapi.tools.i18n.LocalizedResource;

import org.apache.derby.iapi.services.info.JVMInfo;

import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.Vector;
import java.util.Enumeration;
import java.util.Locale;
import java.util.List;
import java.util.ArrayList;
import javax.transaction.xa.XAResource;


/**
	This parser works on a statement-at-a-time basis.
	It maintains a connection environment that is
	set by the caller and contains a list of
	connections for the current thread/ij session.
	Multi-user frameworks that use this parser
	tend to maintain multiple connectionEnv's and
	pass in the current one to set ij up.
	A connectionEnv has a default connection in use,
	and the ij connect/set connection/disconnect commands 
	are used to change the current connection.

	Each connection has associated with it a list
	of prepared statements and cursors, created by
	the ij prepare and get cursor statements and
	manipulated by additional ij statements.

	To enable multiple display modes, this parser will
	not output anything, but will return
	objects that the caller can then display.

	This means the caller is responsible for displaying
	thrown exceptions and also SQLWarnings. So, our
	return value is the JDBC object upon which warnings
	will be hung, i.e. the one manipulated by the statement,
	if any.

	If there is no object to display, then a null is
	returned.

 */
class ij implements ijConstants {
        static final String PROTOCOL_PROPERTY = "ij.protocol";
    static final String URLCHECK_PROPERTY = "ij.URLCheck";
        static final String USER_PROPERTY = "ij.user";
    static final String PASSWORD_PROPERTY = "ij.password";
        static final String FRAMEWORK_PROPERTY = "framework";

        boolean                 elapsedTime = false;

        Connection theConnection = null;
        ConnectionEnv currentConnEnv = null;
        String urlCheck = null;

        xaAbstractHelper xahelper = null;
        boolean exit = false;

        utilMain utilInstance = null;
        Hashtable ignoreErrors = null;
        String protocol = null;         // the (single) unnamed protocol
        Hashtable namedProtocols;



        /**
	 * A constructor that understands the local state that needs to be
	 * initialized.
	 *
	 * @param tm			The token manager to use
	 * @param utilInstance	The util to use
	 */
        ij(ijTokenManager tm, utilMain utilInstance) {
                this(tm);
                this.utilInstance = utilInstance;
        }

        /**
	   Initialize this parser from the environment
	   (system properties). Used when ij is being run
	   as a command line program.
	*/
        void initFromEnvironment() {

                // load all protocols specified via properties
                //
        Properties p = (Properties) AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                return System.getProperties();
            }
        });
        urlCheck = p.getProperty(URLCHECK_PROPERTY);
                protocol = p.getProperty(PROTOCOL_PROPERTY);
                String framework_property = p.getProperty(FRAMEWORK_PROPERTY);

                if (ij.JDBC20X() && ij.JTA() && ij.JNDI())
                {
                        try {
                                xahelper = (xaAbstractHelper) Class.forName("org.apache.derby.impl.tools.ij.xaHelper").newInstance();
                                xahelper.setFramework(framework_property);
                        } catch (Exception e) {
                        }

                }


                namedProtocols = new Hashtable();
                String prefix = PROTOCOL_PROPERTY + ".";
                for (Enumeration e = p.propertyNames(); e.hasMoreElements(); )
                {
                        String key = (String)e.nextElement();
                        if (key.startsWith(prefix)) {
                                String name = key.substring(prefix.length());
                                installProtocol(name.toUpperCase(Locale.ENGLISH), p.getProperty(key));
                        }
                }
        }
        /**
	 * Return whether or not JDBC 2.0 (and greater) extension classes can be loaded
	 *
	 * @return true if JDBC 2.0 (and greater) extension classes can be loaded
	 */
        private static boolean JDBC20X()
        {
                try
                {
                        Class.forName("javax.sql.DataSource");
                        Class.forName("javax.sql.ConnectionPoolDataSource");
                        Class.forName("javax.sql.PooledConnection");
                        Class.forName("javax.sql.XAConnection");
                        Class.forName("javax.sql.XADataSource");
                }
                catch(ClassNotFoundException cnfe)
                {
                        return false;
                }
                return true;
        }
        /**
	 * Return whether or not JTA classes can be loaded
	 *
	 * @return true if JTA classes can be loaded
	 */
        private static boolean JTA()
        {
                try
                {
                        Class.forName("javax.transaction.xa.Xid");
                        Class.forName("javax.transaction.xa.XAResource");
                        Class.forName("javax.transaction.xa.XAException");
                }
                catch(ClassNotFoundException cnfe)
                {
                        return false;
                }
                return true;
        }

        /**
	 * Return whether or not JNDI extension classes can be loaded
	 *
	 * @return true if JNDI extension classes can be loaded
	 */
        private static boolean JNDI()
        {
                try
                {
                        Class.forName("javax.naming.spi.Resolver");
                        Class.forName("javax.naming.Referenceable");
                        Class.forName("javax.naming.directory.Attribute");
                }
                catch(ClassNotFoundException cnfe)
                {
                        return false;
                }
                return true;
        }
// FIXME: caller has to deal with ignoreErrors and handleSQLException behavior

        /**
		Add the warnings of wTail to the end of those of wHead.
	 */
        SQLWarning appendWarnings(SQLWarning wHead, SQLWarning wTail) {
                if (wHead == null) return wTail;

                if (wHead.getNextException() == null) {
                        wHead.setNextException(wTail);
                } else {
                        appendWarnings(wHead.getNextWarning(), wTail);
                }
                return wHead;
        }

        /**
	 * Get the "elapsedTime state".
	 */
        boolean getElapsedTimeState()
        {
                return elapsedTime;
        }

        /**
	   this removes the outside quotes from the string.
	   it will also swizzle the special characters
	   into their actual characters, like '' for ', etc.
	 */
        String stringValue(String s) {
                String result = s.substring(1,s.length()-1);
                char quotes = '\'';
                int             index;

                /* Find the first occurrence of adjacent quotes. */
                index = result.indexOf(quotes);

                /* Replace each occurrence with a single quote and begin the
		 * search for the next occurrence from where we left off.
		 */
                while (index != -1)
                {
                        result = result.substring(0, index + 1) + result.substring(index + 2);

                        index = result.indexOf(quotes, index + 1);
                }

                return result;
        }

        void installProtocol(String name, String value) {
            try {
                        // `value' is a JDBC protocol;
                        // we load the "driver" in the prototypical
                        // manner, it will register itself with
                        // the DriverManager.
                        util.loadDriverIfKnown(value);
            } catch (ClassNotFoundException e) {
                        throw ijException.classNotFoundForProtocol(value);
            } catch (IllegalArgumentException e) {
                        throw ijException.classNotFoundForProtocol(value);
            } catch (IllegalAccessException e) {
                        throw ijException.classNotFoundForProtocol(value);
            } catch (InstantiationException e) {
                        throw ijException.classNotFoundForProtocol(value);
            }
                if (name == null)
                        protocol = value;
                else
                        namedProtocols.put(name, value);
        }

        void haveConnection() {
                JDBCDisplayUtil.checkNotNull(theConnection, "connection");
        }

        /**
		Find a session by its name. Throws an exception if the session does 
		not exists.
	*/
        Session findSession(String name) {
                Session session = currentConnEnv.getSession(name);

                if (session == null)
                        throw ijException.noSuchConnection(name);

                return session;
        }

        /**
		Find a prepared statement. Throws an exception if the session does 
		not exists or the prepared statement can't be found.
	*/
        PreparedStatement findPreparedStatement(QualifiedIdentifier qi) {
                Session session = findSession(qi.getSessionName());
                PreparedStatement ps = session.getPreparedStatement(qi.getLocalName());

                JDBCDisplayUtil.checkNotNull(ps, "prepared statement " + qi);

                return ps;
        }

        /**
		Find a cursor. Throws an exception if the session does not exits or
		it deosn't have the correspondig cursor.
	*/
        ResultSet findCursor(QualifiedIdentifier qi) {
                Session         session = findSession(qi.getSessionName());
                ResultSet       c               = session.getCursor(qi.getLocalName());

                JDBCDisplayUtil.checkNotNull(c, "cursor " + qi);

                return c;
        }

        /**
		We do not reuse statement objects at all, because
		some systems require you to close the object to release
		resources (JBMS), while others will not let you reuse
		the statement object once it is closed (WebLogic).

		If you want to reuse statement objects, you need to
		use the ij PREPARE and EXECUTE statements.

		@param stmt the statement

	 **/
        ijResult executeImmediate(String stmt) throws SQLException {
                Statement aStatement = null;
                try {
                        long    beginTime = 0;
                        long    endTime = 0;
                        boolean cleanUpStmt = false;

                        haveConnection();
                        aStatement = theConnection.createStatement();

                        // for JCC - remove comments at the beginning of the statement
                        // and trim; do the same for Derby Clients that have versions
                        // earlier than 10.2.
                        if (currentConnEnv != null) {
                                boolean trimForDNC = currentConnEnv.getSession().getIsDNC();
                                if (trimForDNC) {
                                // we're using the Derby Client, but we only want to trim
                                // if the version is earlier than 10.2.
                                        DatabaseMetaData dbmd = theConnection.getMetaData();
                                        int majorVersion = dbmd.getDriverMajorVersion();
                                        if ((majorVersion > 10) || ((majorVersion == 10) &&
                                                (dbmd.getDriverMinorVersion() > 1)))
                                        { // 10.2 or later, so don't trim/remove comments.
                                                trimForDNC = false;
                                        }
                                }
                                if (currentConnEnv.getSession().getIsJCC() || trimForDNC) {
                                // remove comments and trim.
                                        int nextline;
                                        while(stmt.startsWith("--"))
                                        {
                                                nextline = stmt.indexOf('\n')+1;
                                                stmt = stmt.substring(nextline);
                                        }
                                        stmt = stmt.trim();
                                }
                        }

                        aStatement.execute(stmt);

                        // FIXME: display results. return start time.
                        return new ijStatementResult(aStatement,true);

                } catch (SQLException e) {
            try {
                            if (aStatement!=null)  // free the resource
                                    aStatement.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

        ijResult quit() throws SQLException {
                exit = true;
                if (getExpect()) { // report stats
                        // FIXME: replace with MVC...
                        // FIXME: this is a kludgy way to quiet /0 and make 0/0=1...
                        int numExpectOr1 = (numExpect==0?1:numExpect);
                        int numPassOr1 = (numPass==numExpect && numPass==0)?1:numPass;
                        int numFailOr1 = (numFail==numExpect && numFail==0)?1:numFail;
                        int numUnxOr1 = (numUnx==numExpect && numUnx==0)?1:numUnx;

            LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("IJ_TestsRun0Pass12Fail34",
            new Object[]{
                        LocalizedResource.getNumber(numExpect), LocalizedResource.getNumber(100*(numPassOr1/numExpectOr1)),
                        LocalizedResource.getNumber(100*(numFailOr1/numExpectOr1))}));
                        if (numUnx > 0) {
                                                        LocalizedResource.OutputWriter().println();
                                                        LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("IJ_UnexpResulUnx01",
                                                        LocalizedResource.getNumber(numUnx), LocalizedResource.getNumber(100*(numUnxOr1/numExpectOr1))));
                        }
                }
                currentConnEnv.removeAllSessions();
                theConnection = null;
                return null;
        }

        /**
		Async execution wants to return results off-cycle.
		We want to control their output, and so will hold it
		up until it is requested with a WAIT FOR asyncName
		statement.  WAIT FOR will return the results of
		the async statement once they are ready.  Note that using
		a select only waits for the execute to complete; the
		logic to step through the result set is in the caller.
	 **/
        ijResult executeAsync(String stmt, QualifiedIdentifier qi) {
                Session sn = findSession(qi.getSessionName());
                AsyncStatement as = new AsyncStatement(sn.getConnection(), stmt);

                sn.addAsyncStatement(qi.getLocalName(),as);

                as.start();

                return null;
        }



        void setConnection(ConnectionEnv connEnv, boolean multipleEnvironments) {
                Connection conn = connEnv.getConnection();

                if (connEnv != currentConnEnv) // single connenv is common case
                        currentConnEnv = connEnv;

                if (theConnection == conn) return; // not changed.

                if ((theConnection == null) || multipleEnvironments) {
                        // must have switched env's (could check)
                        theConnection = conn;
                } else {
                        throw ijException.needToDisconnect();
                }
        }

        /**
		Note the Expect Result in the output and in the stats.

		FIXME
	 */
        int numExpect, numPass, numFail, numUnx;
        private void noteExpect(boolean actual, boolean want) {
                numExpect++;
                if (actual) numPass++;
                else numFail++;

                LocalizedResource.OutputWriter().print(LocalizedResource.getMessage(actual?"IJ_Pass":"IJ_Fail"));
                if (actual != want) {
                        numUnx++;
                                        LocalizedResource.OutputWriter().println(LocalizedResource.getMessage("IJ_Unx"));
                }
                else LocalizedResource.OutputWriter().println();
        }

        private boolean getExpect() {
                String s = util.getSystemProperty("ij.expect");
                return Boolean.valueOf(s).booleanValue();
        }

        private ijResult        addSession
        (
                Connection      newConnection,
                String          name
        )
                throws SQLException
        {
                if (currentConnEnv.haveSession(name)) {
                        throw ijException.alreadyHaveConnectionNamed(name);
                }

                currentConnEnv.addSession( newConnection, name );
                return new ijConnectionResult( newConnection );
        }

        private String[] sortConnectionNames()
        {
                int size = 100;
                int count = 0;
                String[] array = new String[size];
                String key;

                Hashtable ss = currentConnEnv.getSessions();
                // Calculate the number of connections in the sessions list and
                // build an array of all the connection names.
                for (Enumeration connectionNames = ss.keys(); connectionNames.hasMoreElements();) {
                    if (count == size) {
                       // need to expand the array
                       size = size*2;
                       String[] expandedArray = new String[size];
                       System.arraycopy(array, 0, expandedArray, 0, count);
                       array = expandedArray;
                    }
                    key = (String)connectionNames.nextElement();
                    array[ count++ ] = key;
                }

                java.util.Arrays.sort(array, 0, count);

        return array;
        }

            /**
	  This is used at the ij startup time to see if there are already some
	      connections made and if so, show connections made so far.
	  Following also gets executed when user types show connections command
	      in ij. In the former case, ignore0Rows is set whereas in the later cas
	  it's set to false. The reason for this is, at ij startup time, if there
	  are no connections made so far, we don't want to show anything. Only if
	  there are connections made, we show the connections. Whereas in show
	  connection command case, we want to show the connection status either way
	  ie if there are no connections, we say no connections. Otherwise we list
	  all the connections made so far.
	    */
        public ijResult showConnectionsMethod(boolean ignore0Rows) throws SQLException {
                Hashtable ss = currentConnEnv.getSessions();
                Vector v = new Vector();
                SQLWarning w = null;
        if (ss == null || ss.size() == 0) {
                if (!ignore0Rows)
                v.addElement(LocalizedResource.getMessage("IJ_NoConneAvail"));
        }
        else {
                boolean haveCurrent=false;
                        int count = 0;
                        for (Enumeration connectionNames = ss.keys(); connectionNames.hasMoreElements();
                                                connectionNames.nextElement())
                        count++;
            String[] array = sortConnectionNames();
                    for ( int ictr = 0; ictr < count; ictr++ ) {
                                String connectionName = array[ ictr ];
                Session s = (Session)ss.get(connectionName);
                if (s.getConnection().isClosed()) {
                        if (currentConnEnv.getSession() != null &&
                                        connectionName.equals(currentConnEnv.getSession().getName())) {
                                currentConnEnv.removeCurrentSession();
                                theConnection = null;
                        }
                        else
                        currentConnEnv.removeSession(connectionName);
                }
                else {
                        StringBuffer row = new StringBuffer();
                        row.append(connectionName);
                        if (currentConnEnv.getSession() != null &&
                                connectionName.equals(currentConnEnv.getSession().getName())) {
                                row.append('*');
                                haveCurrent=true;
                        }

                                //If ij.dataSource property is set, show only connection names.
                                //In this case, URL is not used to get connection, so do not append URL
                                String dsName = util.getSystemProperty("ij.dataSource");
                                        if(dsName == null){
                                row.append(" - \u0009");
                                row.append(s.getConnection().getMetaData().getURL());
                                }
                        // save the warnings from these connections
                        w = appendWarnings(w,s.getConnection().getWarnings());
                        s.getConnection().clearWarnings();
                        v.addElement(row.toString());
                }
                }
                if (haveCurrent)
                v.addElement(LocalizedResource.getMessage("IJ_CurreConne"));
                    else
                v.addElement(LocalizedResource.getMessage("IJ_NoCurreConne"));
                }
                return new ijVectorResult(v,w);
        }

        /**
	   Returns a subset of the input integer array
	   
	   @param input The input integer array
	   @param start Starting index, inclusive
	   @param end   Ending index, exclusive
	 */
        public static int[] intArraySubset(final int[] input, int start, int end) {
                int[] res = new int[end-start];
                System.arraycopy(input, start, res, 0, end-start);
                return res;
        }

        /**
	   Verify that a table exists within a schema. Throws an exception
	   if table does not exist.
	   
	   @param schema Schema for the table
	   @param table  Name of table to check for existence of
	 */
        public void verifyTableExists(String schema, String table)
        throws SQLException {
                if(schema == null)
                        return;

                ResultSet rs = null;
                try {
                        DatabaseMetaData dbmd = theConnection.getMetaData();
                        rs = dbmd.getTables(null,schema,table,null);
                        if(!rs.next())
                                throw ijException.noSuchTable(table);
                } finally {
                        try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException e) {
            }
                }
        }

        /**
	   Return a resultset of tables (or views, procs...) in the given schema. 

	   @param schema  Schema to get tables for, or null for search 
	                  in all schemas.
	   @param tableType Types of tables to return, see
	                  {@link java.sql.DatabaseMetaData#getTableTypes}
	 */
        public ijResult showTables(String schema, String[] tableType) throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();

                        DatabaseMetaData dbmd = theConnection.getMetaData();
                        rs = dbmd.getTables(null,schema,null,tableType);

                        int[] displayColumns = new int[] {
                                rs.findColumn("TABLE_SCHEM"),
                                rs.findColumn("TABLE_NAME"),
                                rs.findColumn("REMARKS"),
                        };
                        int[] columnWidths = new int[] {
                                20,
                                30,
                                20,
                        };

                        return new ijResultSetResult(rs, displayColumns, columnWidths);
                } catch (SQLException e) {
                        try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

        /**
	   Return a resultset of indexes for the given table or schema

	   @param schema  schema to find indexes for
	   @param table the exact name of the table to find indexes for
	*/
    private ResultSet getIndexInfoForTable(String schema, String table)
      throws SQLException {

        haveConnection();
        verifyTableExists(schema, table);

        DatabaseMetaData dbmd = theConnection.getMetaData();
        return dbmd.getIndexInfo(null, schema, table, false, true);
    }

    /**
     * Used by showIndexes to get columns in correct order
     */
    private int[] getDisplayColumnsForIndex(String schema, ResultSet rs)
        throws SQLException{
        int[] displayColumns = new int[] {
            rs.findColumn("TABLE_SCHEM"),
            rs.findColumn("TABLE_NAME"),
            rs.findColumn("COLUMN_NAME"),
            rs.findColumn("NON_UNIQUE"),
            rs.findColumn("TYPE"),
            rs.findColumn("ASC_OR_DESC"),
            rs.findColumn("CARDINALITY"),
            rs.findColumn("PAGES"),
        };
        if(schema!=null) {
            displayColumns = intArraySubset(displayColumns, 1,
                                            displayColumns.length);
        }
        return displayColumns;
    }

    /**
     * Used by showIndexes to get correct column widths
     */
    private int[] getColumnWidthsForIndex(String schema){
        int[] columnWidths = new int[] {
            20,
            20,
            20,
            6,
            4,
            4,
            8,
            8,
        };
        if(schema!=null) {
            columnWidths = intArraySubset(columnWidths, 1,
                                            columnWidths.length);
        }
        return columnWidths;
    }

    /**
     * Used to show all indices.
     *
     * @param schema the schema indices are shown from. 
     * @param table the table name to show indices for. If <code>null</code>,
     *      all indices of the schema are returned.
     */
    public ijResult showIndexes(String schema, String table)
            throws SQLException {

        ijResult result = null;

        int[] displayColumns = null;
        int[] columnWidths = null;

        try {
            if (table != null) {
                ResultSet rs = getIndexInfoForTable(schema, table);
                displayColumns = getDisplayColumnsForIndex(schema, rs);
                columnWidths = getColumnWidthsForIndex(schema);
                result = new ijResultSetResult(rs, displayColumns,
                                               columnWidths);
            }
            else {
                /* DatabaseMetaData#getIndexInfo requires exact table names.
                 * If table is null, we must first get all table names in
                 * the appropriate schema, and then get all indices for each
                 * of these. 
                 */
                haveConnection();
                verifyTableExists(schema, table);

                DatabaseMetaData dbmd = theConnection.getMetaData();
                ResultSet tablers = dbmd.getTables(null,schema,null,null);

                List resultSets = new ArrayList();
                boolean firstIteration = true;
                ResultSet current_rs = null;
                while (tablers.next()){
                    String tableName = tablers.getString("TABLE_NAME");
                    current_rs = getIndexInfoForTable(schema, tableName);
                    resultSets.add(current_rs);

                    if (firstIteration) {
                        displayColumns = getDisplayColumnsForIndex(schema,
                                                                   current_rs);
                        columnWidths = getColumnWidthsForIndex(schema);
                        firstIteration = false;
                    }
                }
                result = new ijMultipleResultSetResult(resultSets,
                                                       displayColumns,
                                                       columnWidths);
            }
            return result;
        } catch (SQLException e) {
            try {
                if(result!=null)
                    result.closeStatement();
            } catch (SQLException se) {
            }
            throw e;
        }
    }

        /**
	   Return a resultset of procedures from database metadata
	 */
        public ijResult showProcedures(String schema) throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();

                        DatabaseMetaData dbmd = theConnection.getMetaData();
                        rs = dbmd.getProcedures(null,schema,null);

                        int[] displayColumns = new int[] {
                                rs.findColumn("PROCEDURE_SCHEM"),
                                rs.findColumn("PROCEDURE_NAME"),
                                rs.findColumn("REMARKS"),
                        };
                        int[] columnWidths = new int[] {
                                20,
                                30,
                                20,
                        };

                        return new ijResultSetResult(rs, displayColumns, columnWidths);
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

    /**
       Return a resultset of functions from database metadata.

       JDBC4.0 has a method in DatabaseMetaData called getFunctions().
       Since this method is implemented in Derby's JDBC3.0 driver
       we can use it. But only through Java reflection.
     */
    public ijResult showFunctions(String schema) throws SQLException {
        ResultSet rs = null;

        try {
            haveConnection();

            DatabaseMetaData dbmd = theConnection.getMetaData();
            Method getFunctions;
            try {
                getFunctions = dbmd.getClass().getMethod("getFunctions",
                                                    new Class[] { String.class,
                                                               String.class,
                                                               String.class});
                rs = (ResultSet)getFunctions.invoke(dbmd, new Object[] { null, schema, null});
            } catch(NoSuchMethodException nsme) {
                throw ijException.notAvailableForDriver(dbmd.getDriverName());
            } catch(IllegalAccessException iae) {
                throw ijException.notAvailableForDriver(dbmd.getDriverName());
            } catch(AbstractMethodError ame) {
                // According to http://bugs.sun.com/view_bug.do?bug_id=6531596
                // invoke() may throw AbstractMethodError instead of
                // InvocationTargetException on some JREs
                throw ijException.notAvailableForDriver(dbmd.getDriverName());
            } catch(InvocationTargetException ite) {
                Throwable cause = ite.getCause();
                // 'cause' *must* be an SQLException if the method is
                // *actually* called. But may be AbstractMethodError in some
                // cases, if the driver implements an older version of the
                // JDBC spec (pre-JDBC 4.0). See issue DERBY-3809.
                if (cause instanceof SQLException)
                    throw (SQLException)cause;

                // else
                throw ijException.notAvailableForDriver(dbmd.getDriverName());
            }

            int[] displayColumns = new int[] {
                    rs.findColumn("FUNCTION_SCHEM"),
                    rs.findColumn("FUNCTION_NAME"),
                    rs.findColumn("REMARKS")
            };
            int[] columnWidths = new int[] {
                    14,
                    28,
                    35
            };

            return new ijResultSetResult(rs, displayColumns, columnWidths);
        } catch (SQLException e) {
            try {
                if(rs!=null)
                    rs.close();
            } catch (SQLException se) {
            }
            throw e;
        }
    }

        /**
	   Return a resultset of schemas from database metadata
	 */
        public ijResult showSchemas() throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();

                        DatabaseMetaData dbmd = theConnection.getMetaData();
                        rs = dbmd.getSchemas();

                        int[] displayColumns = new int[] {
                                rs.findColumn("TABLE_SCHEM")
                        };
                        int[] columnWidths = new int[] {
                                30
                        };

                        return new ijResultSetResult(rs, displayColumns, columnWidths);
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

        /**
	   Return a resultset of roles. No database metadata
	   available, so select from SYS.SYSROLES directly. This has
	   the side effect of starting a transaction if one is not
	   already active, so we should perhaps give warning when not
	   in autocommit mode.
	*/
        public ijResult showRoles() throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();

                        if (currentConnEnv.getSession().getIsDNC() ||
                                currentConnEnv.getSession().getIsEmbeddedDerby()) {
                                rs = theConnection.createStatement().executeQuery
                                        ("SELECT ROLEID FROM SYS.SYSROLES WHERE ISDEF='Y' " +
                                         "ORDER BY ROLEID ASC");

                                int[] displayColumns = new int[] {
                                        rs.findColumn("ROLEID")
                                };
                                int[] columnWidths = new int[] {
                                        30
                                };

                                return new ijResultSetResult(rs, displayColumns, columnWidths);
                        } else {
                                throw ijException.notAvailableForDriver(
                                        theConnection.getMetaData().getDriverName());
                        }
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

        /**
	 * Return a resultset of enabled roles, sorted on ROLEID. No information
	 * schema is available, we select from VTI SYSCS_DIAG.CONTAINED_ROLES
	 * instead.
	 */
        public ijResult showEnabledRoles() throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();

                        if (currentConnEnv.getSession().getIsDNC() ||
                                currentConnEnv.getSession().getIsEmbeddedDerby()) {
                                rs = theConnection.createStatement().executeQuery
                                        ("SELECT * FROM" +
                                        "\u0009 TABLE(" +
                                        "\u0009   SYSCS_DIAG.CONTAINED_ROLES(CURRENT_ROLE)) T " +
                                        "ORDER BY ROLEID");

                                int[] displayColumns = new int[] {
                                        rs.findColumn("ROLEID")
                                };
                                int[] columnWidths = new int[] {
                                        30
                                };

                                return new ijResultSetResult(rs, displayColumns, columnWidths);
                        } else {
                                throw ijException.notAvailableForDriver(
                                        theConnection.getMetaData().getDriverName());
                        }
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }


        /**
	 * Return a resultset of settable roles, sorted on ROLEID.  This has the
	 * side effect of starting a transaction if one is not already active, so
	 * we should perhaps give warning when not in autocommit mode.
	 */
        public ijResult showSettableRoles() throws SQLException {
                ResultSet rs = null;
                final String query  =
                        // Ordinary user is restricted to roles explicitly granted:
                        "select distinct * from (" +
                        "  select roleid from sys.sysroles s" +
                        "    where s.grantee = current_user or s.grantee = 'PUBLIC'" +
                        "  union" +
                        // Data base owner can set all roles:
                        "  select roleid from sys.sysroles s" +
                        "    where s.isdef='Y' and current_user in" +
                        "        (select authorizationid from sys.sysschemas" +
                        "             where schemaname = 'SYS')) t " +
                        "order by roleid";

                try {
                        haveConnection();

                        if (currentConnEnv.getSession().getIsDNC() ||
                                currentConnEnv.getSession().getIsEmbeddedDerby()) {
                                rs = theConnection.createStatement().executeQuery(query);

                                int[] displayColumns = new int[] {
                                        rs.findColumn("ROLEID")
                                };
                                int[] columnWidths = new int[] {
                                        30
                                };

                                return new ijResultSetResult(rs, displayColumns, columnWidths);
                        } else {
                                throw ijException.notAvailableForDriver(
                                        theConnection.getMetaData().getDriverName());
                        }
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }




        /**
	   Outputs the names of all fields of given table. Outputs field
	   names and data type.
	 */
        public ijResult describeTable(String schema, String table) throws SQLException {
                ResultSet rs = null;
                try {
                        haveConnection();
                        verifyTableExists(schema,table);

                        DatabaseMetaData dbmd = theConnection.getMetaData();
                        rs = dbmd.getColumns(null,schema,table,null);

                        int[] displayColumns = new int[] {
                                rs.findColumn("TABLE_SCHEM"),
                                rs.findColumn("TABLE_NAME"),
                                rs.findColumn("COLUMN_NAME"),
                                rs.findColumn("TYPE_NAME"),
                                rs.findColumn("DECIMAL_DIGITS"),
                                rs.findColumn("NUM_PREC_RADIX"),
                                rs.findColumn("COLUMN_SIZE"),
                                rs.findColumn("COLUMN_DEF"),
                                rs.findColumn("CHAR_OCTET_LENGTH"),
                                rs.findColumn("IS_NULLABLE"),
                        };
                        int[] columnWidths = new int[] {
                                20,
                                20,
                                20,
                                9,
                                4,
                                4,
                                6,
                                10,
                                10,
                                8
                        };

                        //
                        // If schema is specified (if util.getSelectedSchema in
                        // DescTableStatement() returns correct value), then we
                        // don't need to output schema and table names.
                        if(schema!=null && table != null) {
                                displayColumns = intArraySubset(displayColumns, 2,
                                                                                                displayColumns.length);
                                columnWidths   = intArraySubset(columnWidths, 2,
                                                                                                columnWidths.length);
                        }

                        return new ijResultSetResult(rs, displayColumns, columnWidths);
                } catch (SQLException e) {
            try {
                            if(rs!=null)
                                    rs.close();
            } catch (SQLException se) {
            }
                        throw e;
                }
        }

        private Object makeXid(int xid)
        {
                return null;
        }

//
// start of BNF rules
//
  final public ijResult ijStatement() throws ParseException, SQLException {
        ijResult r = null;
    if (jj_2_1(1)) {
      if (getToken(1).kind == ROLLBACK &&
                              (!(getToken(3).kind == TO || getToken(3).kind == SAVEPOINT))) {
        r = RollbackStatement();
      } else {
        switch (jj_nt.kind) {
        case ABSOLUTE:
          r = AbsoluteStatement();
          break;
        case AFTER:
          r = AfterLastStatement();
          break;
        case AUTOCOMMIT:
          r = AutocommitStatement();
          break;
        case ASYNC:
          r = AsyncStatement();
          break;
        case BANG:
          r = Bang();
          break;
        case BEFORE:
          r = BeforeFirstStatement();
          break;
        case CLOSE:
          r = CloseStatement();
          break;
        case COMMIT:
          r = CommitStatement();
          break;
        case CONNECT:
          r = ConnectStatement();
          break;
        case DESCRIBE:
          r = DescTableStatement();
          break;
        case DISCONNECT:
          r = DisconnectStatement();
          break;
        case DRIVER:
          r = DriverStatement();
          break;
        case ELAPSEDTIME:
          r = ElapsedTimeStatement();
          break;
        case EXECUTE:
          r = ExecuteStatement();
          break;
        case FIRST:
          r = FirstStatement();
          break;
        case EXIT:
        case QUIT:
          r = ExitStatement();
          break;
        case EXPECT:
          r = ExpectStatement();
          break;
        case GET:
          r = GetCursorStatement();
          break;
        case GETCURRENTROWNUMBER:
          r = GetCurrentRowNumber();
          break;
        case HELP:
          r = HelpStatement();
          break;
        case LAST:
          r = LastStatement();
          break;
        case LOCALIZEDDISPLAY:
          r = LocalizedDisplay();
          break;
        case MAXIMUMDISPLAYWIDTH:
          r = MaximumDisplayWidthStatement();
          break;
        case NEXT:
          r = NextStatement();
          break;
        case NOHOLDFORCONNECTION:
          r = NoHoldForConnectionStatement();
          break;
        case PREPARE:
          r = PrepareStatement();
          break;
        case PREVIOUS:
          r = PreviousStatement();
          break;
        case PROTOCOL:
          r = ProtocolStatement();
          break;
        case READONLY:
          r = ReadOnlyStatement();
          break;
        case RELATIVE:
          r = RelativeStatement();
          break;
        case REMOVE:
          r = RemoveStatement();
          break;
        case RUN:
          r = RunStatement();
          break;
        case SET:
          r = SetConnectionStatement();
          break;
        case SHOW:
          r = ShowStatement();
          break;
        case WAIT:
          r = WaitForStatement();
          break;
        case XA_DATASOURCE:
          r = XA_DataSourceStatement();
          break;
        case XA_CONNECT:
          r = XA_ConnectStatement();
          break;
        case XA_COMMIT:
          r = XA_CommitStatement();
          break;
        case XA_DISCONNECT:
          r = XA_DisconnectStatement();
          break;
        case XA_GETCONNECTION:
          r = XA_GetConnectionStatement();
          break;
        case XA_END:
          r = XA_EndStatement();
          break;
        case XA_FORGET:
          r = XA_ForgetStatement();
          break;
        case XA_PREPARE:
          r = XA_PrepareStatement();
          break;
        case XA_RECOVER:
          r = XA_RecoverStatement();
          break;
        case XA_ROLLBACK:
          r = XA_RollbackStatement();
          break;
        case XA_START:
          r = XA_StartStatement();
          break;
        case DATASOURCE:
          r = DataSourceStatement();
          break;
        case CP_DATASOURCE:
          r = CP_DataSourceStatement();
          break;
        case CP_CONNECT:
          r = CP_ConnectStatement();
          break;
        case CP_GETCONNECTION:
          r = CP_GetConnectionStatement();
          break;
        case CP_DISCONNECT:
          r = CP_DisconnectStatement();
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } else {
      ;
    }
    jj_consume_token(0);
                {if (true) return r;}
    throw new Error("Missing return statement in function");
  }

/**
 * ProtocolStatement is PROTOCOL 'JDBC protocol' where
 * the protocol is used to prefix any connect request that
 * cannot find a driver.  We will take a stab at loading
 * a driver as each protocol comes in -- we only know about
 * two.
 */
  final public ijResult ProtocolStatement() throws ParseException, SQLException {
        Token t;
        String n = null;
    jj_consume_token(PROTOCOL);
    t = jj_consume_token(STRING);
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
                installProtocol(n, stringValue(t.image));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * DriverStatement is DRIVER 'class' where class is the
 * name of a class that is a JDBC driver. It is loaded
 * into the DriverManager with a Class.forName call.
 * <p>
 * You can load as many drivers as you want, the idea is
 * to load up the appropriate one(s) for the connect(s)
 * that you will be issuing.
 */
  final public ijResult DriverStatement() throws ParseException, SQLException {
        Token t;
        String sVal = null;
    jj_consume_token(DRIVER);
    t = jj_consume_token(STRING);
            try {
                // t.image is a class name;
                // we load the "driver" in the prototypical
                // manner, it will register itself with
                // the DriverManager.
                        sVal = stringValue(t.image);
                        util.loadDriver(sVal);
            } catch (ClassNotFoundException e) {
                        {if (true) throw ijException.classNotFound(sVal);}
            } catch (IllegalArgumentException e) {
                        {if (true) throw ijException.driverNotClassName(sVal);}
            } catch (IllegalAccessException e) {
                        {if (true) throw ijException.classNotFound(sVal);}
            } catch (InstantiationException e) {
                        {if (true) throw ijException.classNotFound(sVal);}
            }
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public ijResult ConnectStatement() throws ParseException, SQLException {
        ijResult        result;
    jj_consume_token(CONNECT);
    switch (jj_nt.kind) {
    case TO:
      jj_consume_token(TO);
      result = dynamicConnection(true);
      break;
    case IDENTIFIER:
    case STRING:
      switch (jj_nt.kind) {
      case STRING:
        result = dynamicConnection(false);
        break;
      case IDENTIFIER:
        result = staticConnection();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/**
 * ConnectStatement is CONNECT 'url' [ PROTOCOL proto ] 
	[ USER 	String PASSWORD String ] 
	[ATTRIBUTES attributeName = value [, attributeName = value]* ]
	[ AS ident ], where url is the
 * url for the database, i.e. jdbc:protocol:dbname etc.
 * Attributes are connection attributes to 
 * <p>
 * There can only be one connection at a time; if there
 * is already one, it is put on hold and this one takes its place.
 * <p>
 * if a driver can't be found, the current protocol will
 * be added at the front.
 * <p>
 * the as ident part is used for set connection.  If you don't
 * specify a name, we create one that is CONNECTION# for the #
 * of open connections that now exists. If the name duplicates,
 * an error results.
 */
  final public ijResult dynamicConnection(boolean simplifiedPath) throws ParseException, SQLException {
        Token t;
        Token userT = null;
        Token passwordT = null;
        String n = null, p = null, sVal;
    String userS =  util.getSystemProperty(USER_PROPERTY);
    String passwordS = util.getSystemProperty(PASSWORD_PROPERTY);
        Properties connInfo = new Properties();
    t = jj_consume_token(STRING);
    switch (jj_nt.kind) {
    case PROTOCOL:
      jj_consume_token(PROTOCOL);
      p = identifier();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case USER:
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PASSWORD:
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case ATTRIBUTES:
      jj_consume_token(ATTRIBUTES);
      if (jj_2_2(1)) {
        attributeList(connInfo);
      } else {
        ;
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                // t.image is a database URL
                // we get the connection and salt it away
                // for use with other statements.
                //
                // FUTURE: we could have the syntax be
                // CONNECT <STRING> AS <IDENTIFIER>
                // and have a SET CONNECTION string to
                // re-activate a named connection.
                // Or not, and wait for SQL-J to support that
                // statement... although then we will have to
                // figure out if we will allow that SQL-J through
                // JDBC or not.
                // get the value of the string
                // n.b. at some point this will have to deal with ''s
                if (userT != null)
                userS = stringValue(userT.image);

        if (passwordT != null)
                passwordS = stringValue(passwordT.image);

        //If ij.dataSource property is set,use DataSource to get the connection
                String dsName = util.getSystemProperty("ij.dataSource");
                if (dsName != null){
                //Check that t.image does not start with jdbc:
                //If it starts with jdbc:, do not use DataSource to get connection
                sVal = stringValue(t.image);
                if(!sVal.startsWith("jdbc:") ){
                        theConnection = util.getDataSourceConnection(dsName,userS,passwordS,sVal,false);
                        {if (true) return addSession( theConnection, n );}
                }
        }

                if (simplifiedPath)
                        // url for the database W/O 'jdbc:protocol:', i.e. just a dbname
                        // For example,
                        //		CONNECT TO 'test'
                        // is equivalent to
                        // 		CONNECT TO 'jdbc:derby:test'
                        sVal = "jdbc:derby:" + stringValue(t.image);
                else
                        sVal = stringValue(t.image);

                // add named protocol if it was specified
                if (p != null) {
                        String protocol = (String)namedProtocols.get(p);
                        if (protocol == null) { {if (true) throw ijException.noSuchProtocol(p);} }
                        sVal = protocol + sVal;
                }

                // add protocol if no driver matches url
                boolean noDriver = false;
                        // if we have a full URL, make sure it's loaded first
                        try {
                                if (sVal.startsWith("jdbc:"))
                                        util.loadDriverIfKnown(sVal);
                        } catch (Exception e) {
                                // want to continue with the attempt
                        }
                        // By default perform extra checking on the URL attributes.
                        // This checking does not change the processing.
                        if (urlCheck == null || Boolean.valueOf(urlCheck).booleanValue()) {
                          URLCheck aCheck = new URLCheck(sVal);
                        }
                if (!sVal.startsWith("jdbc:") && (p == null) && (protocol != null)) {
                        sVal = protocol + sVal;
                }


                // If no ATTRIBUTES on the connection get them from the
                // defaults
                connInfo = util.updateConnInfo(userS,passwordS, connInfo);


                theConnection = DriverManager.getConnection(sVal,connInfo);

                {if (true) return addSession( theConnection, n );}
    throw new Error("Missing return statement in function");
  }

/**
 * Handles DESCRIBE table
 */
  final public ijResult DescTableStatement() throws ParseException, SQLException {
        String i = null;
        String i2 = null;
        Token  s = null;
        String schema;
        String table;
    jj_consume_token(DESCRIBE);
    switch (jj_nt.kind) {
    case ABSOLUTE:
    case AFTER:
    case ALIASES:
    case ALL:
    case AS:
    case ASYNC:
    case ATTRIBUTES:
    case AUTOCOMMIT:
    case BANG:
    case BEFORE:
    case CLOSE:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONNECTIONS:
    case CURRENT:
    case CURSOR:
    case DESCRIBE:
    case DISCONNECT:
    case DRIVER:
    case ELAPSEDTIME:
    case END:
    case EXECUTE:
    case EXIT:
    case EXPECT:
    case FAIL:
    case FIRST:
    case FOR:
    case FROM:
    case GET:
    case GETCURRENTROWNUMBER:
    case HOLD:
    case HELP:
    case IN:
    case INDEXES:
    case INSENSITIVE:
    case INTO:
    case LAST:
    case LOCALIZEDDISPLAY:
    case MAXIMUMDISPLAYWIDTH:
    case NAME:
    case NEXT:
    case NOHOLD:
    case NOHOLDFORCONNECTION:
    case OFF:
    case ON:
    case PASSWORD:
    case PERIOD:
    case PREPARE:
    case PREVIOUS:
    case PROCEDURE:
    case PROCEDURES:
    case PROPERTIES:
    case PROTOCOL:
    case QUIT:
    case READONLY:
    case RELATIVE:
    case REMOVE:
    case RESOURCE:
    case ROLLBACK:
    case RUN:
    case TO:
    case SCHEMAS:
    case SCROLL:
    case SENSITIVE:
    case SET:
    case SHOW:
    case SHUTDOWN:
    case STATEMENT:
    case SYNONYMS:
    case TABLES:
    case USER:
    case USING:
    case VIEWS:
    case WAIT:
    case WITH:
    case XA_1PHASE:
    case XA_2PHASE:
    case XA_DATASOURCE:
    case XA_CONNECT:
    case XA_COMMIT:
    case XA_DISCONNECT:
    case XA_END:
    case XA_ENDRSCAN:
    case XA_FAIL:
    case XA_FORGET:
    case XA_GETCONNECTION:
    case XA_JOIN:
    case XA_NOFLAGS:
    case XA_PREPARE:
    case XA_RECOVER:
    case XA_RESUME:
    case XA_ROLLBACK:
    case XA_START:
    case XA_STARTRSCAN:
    case XA_SUCCESS:
    case XA_SUSPEND:
    case DATASOURCE:
    case CP_DATASOURCE:
    case CP_CONNECT:
    case CP_GETCONNECTION:
    case CP_DISCONNECT:
    case WORK:
    case IDENTIFIER:
      i = caIdentifier();
      switch (jj_nt.kind) {
      case PERIOD:
        jj_consume_token(PERIOD);
        i2 = caIdentifier();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
                        if (i2 == null) {
                                schema = null;
                                table = i;
                        } else {
                                schema = i;
                                table = i2;
                        }
      break;
    case STRING:
      s = jj_consume_token(STRING);
                        i2 = stringValue(s.image);

                        if (i2.length() == 0)
                                {if (true) throw ijException.noSuchTable("(missing)");}

                        int dotPosition = i2.indexOf('.');
                        if(dotPosition!=-1) {
                                i = i2.substring(0,dotPosition);
                                i2 = i2.substring(dotPosition+1);
                        }
                        if ("*".equals(i2))
                                i2 = null;

                        schema = i;
                        table = i2;
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (schema == null) {
                        schema = util.getSelectedSchema(theConnection);
                }

                {if (true) return describeTable(schema, table);}
    throw new Error("Missing return statement in function");
  }

/**
  * Handles CONNECT yadda.yadda.foo( stringArg, ... stringArg ) AS connectionName
  */
  final public ijResult staticConnection() throws ParseException, SQLException {
        String                  name = null;
        Vector                  idList;
        int                             idx = 0;
        int                             lastID = 0;
        StringBuffer    buffer;
        String                  className;
        String                  methodName;
        Class                   classC;
        Method                  method;
        int                             argCount;
        String[]                args;
        Class                   stringClass;
        Class[]                 argTypes;
        ijResult                result = null;
    idList = staticMethodName();
    args = staticMethodArgs();
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      name = identifier();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
                lastID = idList.size() - 1;
                buffer = new StringBuffer();

                for ( ; idx < lastID; idx++ )
                {
                        if ( idx > 0 ) { buffer.append( "." ); }
                        buffer.append( (String) idList.elementAt( idx ) );
                }
                methodName = (String) idList.elementAt( idx );
                className = buffer.toString();

                try {
                        argCount = args.length;
                        argTypes = new Class[ argCount ];
                        stringClass = Class.forName( "java.lang.String" );
                        for ( idx = 0; idx < argCount; idx++ ) { argTypes[ idx ] = stringClass; }

                        classC = Class.forName( className );
                        method = classC.getMethod( methodName, argTypes );
                        theConnection = (Connection) method.invoke( null, args );
                        result = addSession( theConnection, name );

                }
                catch (java.lang.reflect.InvocationTargetException ite) {
                        Throwable t = ite.getTargetException();
                        if (t instanceof SQLException)
                                {if (true) throw (SQLException) t;}

                        {if (true) throw new SQLException( t.toString() );}
                }
                catch (Exception e) { {if (true) throw new SQLException( e.toString() );} }

                {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/**
 * SetConnectionStatement is SET CONNECTION ident
 * <p>
 * Moves to the named session, if it exists. If it doesn't
 * exist, remains on the current session and returns an error.
 */
  final public ijResult SetConnectionStatement() throws ParseException, SQLException {
        String t;
    jj_consume_token(SET);
    jj_consume_token(CONNECTION);
    t = identifier();
                if (!currentConnEnv.haveSession(t)) {
                        {if (true) throw ijException.noSuchConnection(t);}
                }
                currentConnEnv.setCurrentSession(t);
                theConnection = currentConnEnv.getConnection();
                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

/**
 * Handles showing current connections for the current environment, and
 * SHOW TABLES/VIEWS/... commands.
 */
  final public ijResult ShowStatement() throws ParseException, SQLException {
        String schema  = null;
        String tblname = null;
        String str     = null;
        String[] types = null;
        Token t = null;
        Token v = null;
    jj_consume_token(SHOW);
    switch (jj_nt.kind) {
    case CONNECTIONS:
      jj_consume_token(CONNECTIONS);
                {if (true) return showConnectionsMethod(false);}
      break;
    case ALIASES:
    case SYNONYMS:
    case TABLES:
    case VIEWS:
      switch (jj_nt.kind) {
      case TABLES:
        t = jj_consume_token(TABLES);
        break;
      case VIEWS:
        v = jj_consume_token(VIEWS);
        break;
      case SYNONYMS:
        jj_consume_token(SYNONYMS);
        break;
      case ALIASES:
        jj_consume_token(ALIASES);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case IN:
        jj_consume_token(IN);
        schema = caIdentifier();
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
                if(t!=null) {
                    types = new String[] { "TABLE", "SYSTEM TABLE" };
                }
                else if(v!=null)
                        types = new String[] { "VIEW" };
                else
                        types = new String[] { "SYNONYM" };
                {if (true) return showTables(schema, types);}
      break;
    case INDEXES:
      jj_consume_token(INDEXES);
      switch (jj_nt.kind) {
      case FROM:
      case IN:
        switch (jj_nt.kind) {
        case IN:
          jj_consume_token(IN);
          schema = caIdentifier();
          break;
        case FROM:
          jj_consume_token(FROM);
          tblname = caIdentifier();
          switch (jj_nt.kind) {
          case PERIOD:
            jj_consume_token(PERIOD);
            str = caIdentifier();
            break;
          default:
            jj_la1[14] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
                if(str != null) {
                        // if absolute table reference given
                        schema = tblname;
                        tblname = str;
                }

                // If user specifies a table name, then assume schema is
                // current schema. Note that getSelectedSchema may return
                // null for some DBMSes.
                if(schema == null && tblname != null)
                        schema = util.getSelectedSchema(theConnection);
                {if (true) return showIndexes(schema,tblname);}
      break;
    case PROCEDURES:
      jj_consume_token(PROCEDURES);
      switch (jj_nt.kind) {
      case IN:
        jj_consume_token(IN);
        schema = caIdentifier();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
                {if (true) return showProcedures(schema);}
      break;
    case FUNCTIONS:
      jj_consume_token(FUNCTIONS);
      switch (jj_nt.kind) {
      case IN:
        jj_consume_token(IN);
        schema = caIdentifier();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
                {if (true) return showFunctions(schema);}
      break;
    case SCHEMAS:
      jj_consume_token(SCHEMAS);
                {if (true) return showSchemas();}
      break;
    case ROLES:
      jj_consume_token(ROLES);
            {if (true) return showRoles();}
      break;
    case ENABLED_ROLES:
      jj_consume_token(ENABLED_ROLES);
            {if (true) return showEnabledRoles();}
      break;
    case SETTABLE_ROLES:
      jj_consume_token(SETTABLE_ROLES);
            {if (true) return showSettableRoles();}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * CommitStatement is simply COMMIT.
 * It commits the current transation.
 */
  final public ijResult CommitStatement() throws ParseException, SQLException {
    jj_consume_token(COMMIT);
    switch (jj_nt.kind) {
    case WORK:
      jj_consume_token(WORK);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
                haveConnection();
                theConnection.commit();
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * RollbackStatement is simply ROLLBACK.
 * It undoes the current transation.
 */
  final public ijResult RollbackStatement() throws ParseException, SQLException {
    jj_consume_token(ROLLBACK);
    switch (jj_nt.kind) {
    case WORK:
      jj_consume_token(WORK);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
                haveConnection();
                theConnection.rollback();
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * DisconnectStatement is simply DISCONNECT [ ALL | CURRENT | connectionName ]
 * it ends the specified connection(s) and
 * releases its statement resource.
 * <p>
 * If ALL is specified, it disconnects all available sessions
 * in the current environment.
 */
  final public ijResult DisconnectStatement() throws ParseException, SQLException {
        Token a = null;
        String n = null;
    jj_consume_token(DISCONNECT);
    switch (jj_nt.kind) {
    case ALL:
    case CURRENT:
    case IDENTIFIER:
      switch (jj_nt.kind) {
      case CURRENT:
        jj_consume_token(CURRENT);
        break;
      case ALL:
        a = jj_consume_token(ALL);
        break;
      case IDENTIFIER:
        n = identifier();
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
                if ( a == null ) {
                        if (n == null) {
                        // only remove the current session
                            haveConnection();
                            // Also need to release the session object
                            currentConnEnv.removeCurrentSession();
                            theConnection = null;
                        }
                        else {
                            if (! currentConnEnv.haveSession(n))
                                    {if (true) throw ijException.noSuchConnection(n);}
                                currentConnEnv.removeSession(n);
                            if (currentConnEnv.getSession() == null)
                                    theConnection = null;
                        }
                } else {
                        currentConnEnv.removeAllSessions();
                        theConnection = null;
                }
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public ijResult ExitStatement() throws ParseException, SQLException {
    switch (jj_nt.kind) {
    case EXIT:
      jj_consume_token(EXIT);
                {if (true) return quit();}
      break;
    case QUIT:
      jj_consume_token(QUIT);
                {if (true) return quit();}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ijResult PrepareStatement() throws ParseException, SQLException {
        Token t;
        QualifiedIdentifier qi;
        PreparedStatement ps;
        String sVal;
    jj_consume_token(PREPARE);
    switch (jj_nt.kind) {
    case PROCEDURE:
      jj_consume_token(PROCEDURE);
      jj_consume_token(AS);
      t = jj_consume_token(STRING);
                // "procedure" is not allowed as a statement name. This is
                // because "execute procedure" is a valid Foundation2000
                // command.
                {if (true) throw ijException.illegalStatementName( "procedure" );}
      break;
    case IDENTIFIER:
      qi = qualifiedIdentifier();
      jj_consume_token(AS);
      t = jj_consume_token(STRING);
                Session session = findSession(qi.getSessionName());

                sVal = stringValue(t.image);
                ps = session.getConnection().prepareStatement(sVal);
                JDBCDisplayUtil.checkNotNull(ps,"prepared statement");
                session.addPreparedStatement(qi.getLocalName(),ps);

                // all we want callers to see are the warnings.
                SQLWarning w = ps.getWarnings();
                ps.clearWarnings();
                {if (true) return new ijWarningResult(w);}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ijResult GetCursorStatement() throws ParseException, SQLException {
        haveConnection();
        int scrollType = ResultSet.TYPE_FORWARD_ONLY;
        Token s;
        Token scrolling = null;
        Token withtoken = null;
        int holdType = theConnection.getHoldability();
        QualifiedIdentifier qi;
        Statement st = null;
        String sVal;
        ResultSet rs = null;
        SQLWarning warns;
    jj_consume_token(GET);
    switch (jj_nt.kind) {
    case SCROLL:
      scrolling = jj_consume_token(SCROLL);
      scrollType = scrollType();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case WITH:
      withtoken = jj_consume_token(WITH);
      holdType = holdType();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(CURSOR);
    qi = qualifiedIdentifier();
    jj_consume_token(AS);
    s = jj_consume_token(STRING);
                sVal = stringValue(s.image);
                try {
                        Session sn = findSession(qi.getSessionName());

                        st = sn.getConnection().createStatement(
                                scrollType, ResultSet.CONCUR_READ_ONLY, holdType);
                        JDBCDisplayUtil.checkNotNull(st,"cursor");
                        st.setCursorName(qi.getLocalName());
                        rs = st.executeQuery(sVal);
                        JDBCDisplayUtil.checkNotNull(rs,"cursor");
                        sn.addCursorStatement(qi.getLocalName(),st);
                        sn.addCursor(qi.getLocalName(),rs);
                } catch (SQLException e) {
            try {
                            if (rs!=null) rs.close();
            } catch (SQLException se) {
            }
            try {
                        if (st!=null) st.close();
            } catch (SQLException se) {
            }
                        {if (true) throw e;}
                }

                // all we want callers to see are the warnings.
                SQLWarning w1 = theConnection.getWarnings();
                SQLWarning w2 = st.getWarnings();
                SQLWarning w3 = rs.getWarnings();
                theConnection.clearWarnings();
                st.clearWarnings();
                rs.clearWarnings();
                warns = appendWarnings(w1,w2);
                {if (true) return new ijWarningResult(appendWarnings(warns,w3));}
    throw new Error("Missing return statement in function");
  }

  final public int scrollType() throws ParseException, SQLException {
    switch (jj_nt.kind) {
    case INSENSITIVE:
      jj_consume_token(INSENSITIVE);
                {if (true) return ResultSet.TYPE_SCROLL_INSENSITIVE;}
      break;
    case SENSITIVE:
      jj_consume_token(SENSITIVE);
                {if (true) return ResultSet.TYPE_SCROLL_SENSITIVE;}
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int holdType() throws ParseException, SQLException {
    switch (jj_nt.kind) {
    case HOLD:
      jj_consume_token(HOLD);
                {if (true) return ResultSet.HOLD_CURSORS_OVER_COMMIT;}
      break;
    case NOHOLD:
      jj_consume_token(NOHOLD);
                {if (true) return ResultSet.CLOSE_CURSORS_AT_COMMIT;}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public ijResult AbsoluteStatement() throws ParseException, SQLException {
        int row;
        QualifiedIdentifier qi;
    jj_consume_token(ABSOLUTE);
    row = intLiteral();
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.absolute(rs, row);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult RelativeStatement() throws ParseException, SQLException {
        int row;
        QualifiedIdentifier qi;
    jj_consume_token(RELATIVE);
    row = intLiteral();
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.relative(rs, row);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult BeforeFirstStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(BEFORE);
    jj_consume_token(FIRST);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.beforeFirst(rs);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult FirstStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(FIRST);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.first(rs);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult NextStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(NEXT);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return new ijRowResult(rs, rs.next());}
    throw new Error("Missing return statement in function");
  }

  final public ijResult AfterLastStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(AFTER);
    jj_consume_token(LAST);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.afterLast(rs);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult LastStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(LAST);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.last(rs);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult PreviousStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(PREVIOUS);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return utilInstance.previous(rs);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult GetCurrentRowNumber() throws ParseException, SQLException {
        QualifiedIdentifier qi;
    jj_consume_token(GETCURRENTROWNUMBER);
    qi = qualifiedIdentifier();
                // Verify that we have JDBC 2.0
                ResultSet rs = findCursor(qi);
                {if (true) return new ijVectorResult(utilInstance.getCurrentRowNumber(rs), null);}
    throw new Error("Missing return statement in function");
  }

  final public ijResult CloseStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
        Statement s;
    jj_consume_token(CLOSE);
    qi = qualifiedIdentifier();
                Session sn = findSession(qi.getSessionName());

                ResultSet rs = sn.getCursor(qi.getLocalName());
                JDBCDisplayUtil.checkNotNull(rs,"cursor " + qi);
                s = (Statement) sn.getCursorStatement(qi.getLocalName());
                JDBCDisplayUtil.checkNotNull(s,"cursor" + qi);
                rs.close();
                s.close();
                sn.removeCursor(qi.getLocalName());
                sn.removeCursorStatement(qi.getLocalName());

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * Two forms of execute: immediate, with a string
 * and prepared, with the id of a prepared statement.
 * We expect the latter form will
 * eventually support a USING clause to supply
 * parameter values (that will be constants).
 * No parameters yet, however.
 * <p>
 * Syntax:
 *   EXECUTE statementSource [ USING statementSource] ;
 *
 *	 statementSource is an identifier of a previously prepared statement
 *	 or a string containing SQL-J text.
 */
  final public ijResult ExecuteStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi = null;
        Token s = null;
        PreparedStatement ps;
        String sVal = null;

        QualifiedIdentifier qiUsing = null;
        Token sUsing = null;
        Token   usingObject = null;
    jj_consume_token(EXECUTE);
    switch (jj_nt.kind) {
    case STATEMENT:
      jj_consume_token(STATEMENT);
      s = jj_consume_token(STRING);
                {if (true) return executeImmediate(stringValue(s.image));}
      break;
    case PROCEDURE:
      jj_consume_token(PROCEDURE);
      s = jj_consume_token(STRING);
                haveConnection();

                Statement       aStatement = theConnection.createStatement();
                String          text = "execute procedure " + s;

                aStatement.execute( text );

                {if (true) return new ijStatementResult( aStatement,true );}
      break;
    case IDENTIFIER:
    case STRING:
      switch (jj_nt.kind) {
      case IDENTIFIER:
        qi = qualifiedIdentifier();
        break;
      case STRING:
        s = jj_consume_token(STRING);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch (jj_nt.kind) {
      case USING:
        jj_consume_token(USING);
        switch (jj_nt.kind) {
        case IDENTIFIER:
          qiUsing = qualifiedIdentifier();
          break;
        case STRING:
          sUsing = jj_consume_token(STRING);
          break;
        default:
          jj_la1[31] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
            if (qiUsing!=null || sUsing!=null) { // parameters in use
                        String sUsingVal = null;
                        PreparedStatement psUsing;
                        SQLWarning warns = null;

                        // haveConnection();

                        /*
				Steps:
				1. find or prepare the statement
				2. execute the using statement
				3. push the row of the using statement into the parameters
				4. execute the statement against those parameters
				5. clear the parameters
			 */
                        /*
				get the prepared statement
			 */
                        boolean closeWhenDone = false; // will we close the ps when done?
                if (qi!=null) {
                        ps = findPreparedStatement(qi);
                }
                else { // (s!=null)
                                sVal = stringValue(s.image);
                                ps = theConnection.prepareStatement(sVal);
                                closeWhenDone = true;
                                JDBCDisplayUtil.checkNotNull(ps,"prepared statement");
                                warns = appendWarnings(warns, ps.getWarnings());
                                ps.clearWarnings();
                }

                        /*
				execute the using statement
			 */
                if (qiUsing!=null) {
                        psUsing = findPreparedStatement(qiUsing);
                }
                else { // (sUsing!=null)
                                sUsingVal = stringValue(sUsing.image);
                                psUsing = theConnection.prepareStatement(sUsingVal);
                                JDBCDisplayUtil.checkNotNull(psUsing,"prepared statement");
                                warns = appendWarnings(warns, psUsing.getWarnings());
                                psUsing.clearWarnings();
                }

                        ResultSet rsUsing;
                        /*
				If the USING statement is not a query, we
				will not execute the statement; the number of
				rows controls the execution.
			 */
                        if (psUsing.execute()) {
                                rsUsing = psUsing.getResultSet();

                                /*
					push the row of the using statement into the parameters
				 */

                                ResultSetMetaData rsmdUsing = rsUsing.getMetaData();
                                int numCols = rsmdUsing.getColumnCount();

                                /*
					Insufficient or too many parameters will
					be caught at the JDBC level, and halt execution.
				 */
                                boolean exec = false;

                                /* Only do 1 next on rsUsing if autocommit is on,
				 * since rsUsing will be closed when ps is closed.
				 */
                            boolean autoCommited = false;
                                ijMultiResult result = new ijMultiResult(ps,rsUsing,closeWhenDone);

//				while (! autoCommited && rsUsing.next()) {
//					// note the first time through
//					if (!exec) {
//						exec = true;
//
//						// send a warning if additional results may be lost
//						if (theConnection.getAutoCommit()) {
//							// FIXME: currOut.println("IJ WARNING: Autocommit may close using result set");
//							autoCommited = true;
//						}
//					}
//					for (int c=1; c<=numCols; c++) {
//						if (usingObject == null)
//						{
//							ps.setObject(c,rsUsing.getObject(c),
//								rsmdUsing.getColumnType(c));
//						} 
//						else
//						{
//							ps.setObject(c,rsUsing.getObject(c));
//						}
//					}
//
//					/*
//						4. execute the statement against those parameters
//					 */
//
//					ps.execute();
//					result.addStatementResult(ps);
//
//					/*
//						5. clear the parameters
//					 */
//					ps.clearParameters();
//
//				}
//				if (!exec) {
//					throw ijException.noUsingResults();
//				}
//
//				if (! theConnection.getAutoCommit())
//				{
//					rsUsing.close();
//				}
//				// REMIND: any way to look for more rsUsing rows if autoCommit?
//				// perhaps just document the behavior... 

                                {if (true) return result;}
                        }
                        else
                                {if (true) throw ijException.noUsingResults();}
                }
                else { // no parameters in use
                if (qi!=null) {
                                haveConnection();
                                ps = findPreparedStatement(qi);
                                ps.execute();

                                {if (true) return new ijStatementResult(ps,false);}
                }
                else { // (s!=null)
                            {if (true) return executeImmediate(stringValue(s.image));}
                }
            }
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Async: like execute immediate, without using,
 * but runs the statement in a separate thread, against
 * the current connection.
 * <p>
 * Syntax:
 *   ASYNC asyncName statementSource 
 *
 *	 statementSource is a string containing SQL-J text.
 */
  final public ijResult AsyncStatement() throws ParseException, SQLException {
        Token s = null;
        QualifiedIdentifier qi;
    jj_consume_token(ASYNC);
    qi = qualifiedIdentifier();
    s = jj_consume_token(STRING);
            {if (true) return executeAsync(stringValue(s.image), qi);}
    throw new Error("Missing return statement in function");
  }

/**
 * Wait for: the second half of Async, waits for completion
 * if needed and then supplies the result.  Only execute is done,
 * not row fetching.
 * <p>
 * Syntax:
 *   WAIT FOR asyncName 
 *
 *	 asyncName is a name used in an ASYNC statement previously
 */
  final public ijResult WaitForStatement() throws ParseException, SQLException {
        Token s = null;
        QualifiedIdentifier qi;
    jj_consume_token(WAIT);
    jj_consume_token(FOR);
    qi = qualifiedIdentifier();
                Session sn = findSession(qi.getSessionName());
                AsyncStatement as = sn.getAsyncStatement(qi.getLocalName());
                if (as == null) {if (true) throw ijException.noSuchAsyncStatement(qi.toString());}
                try {
                    as.join(); // we wait for it to finish.
                } catch (InterruptedException ie) {
                        {if (true) throw ijException.waitInterrupted(ie);}
                }
                {if (true) return as.getResult();}
    throw new Error("Missing return statement in function");
  }

/**
 * RemoveStatement is REMOVE identifier. It identifies
 * a previously prepared statement.  We would prefer a DROP
 * syntax, but SQL-J is using that word and I want to point out
 * that special processing will be needed to give that parser
 * this parser's input for unrecognized text.
 */
  final public ijResult RemoveStatement() throws ParseException, SQLException {
        QualifiedIdentifier qi;
        PreparedStatement ps;
    jj_consume_token(REMOVE);
    qi = qualifiedIdentifier();
                Session s = findSession(qi.getSessionName());
                ps = (PreparedStatement) s.getPreparedStatement(qi.getLocalName());
                JDBCDisplayUtil.checkNotNull(ps,"prepared statement "+qi);
                ps.close();
                s.removePreparedStatement(qi.getLocalName());

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public ijResult RunStatement() throws ParseException, SQLException {
        Token i;
    Token r = null;
        PreparedStatement ps;
    jj_consume_token(RUN);
    switch (jj_nt.kind) {
    case RESOURCE:
      r = jj_consume_token(RESOURCE);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    i = jj_consume_token(STRING);
                if (utilInstance==null) {if (true) return null;}
            if (r == null)
                        utilInstance.newInput(stringValue(i.image));
                else
            utilInstance.newResourceInput(stringValue(i.image));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * Autocommit lets you control this aspect of the connection.
 * REMIND: should have a general way to set all connection attributes,
 * this is a shortcut for immediate needs.
 * <p>
 * Syntax:
 *   AUTOCOMMIT [ ON | OFF ] ;
 */
  final public ijResult AutocommitStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(AUTOCOMMIT);
    switch (jj_nt.kind) {
    case ON:
      on = jj_consume_token(ON);
      break;
    case OFF:
      jj_consume_token(OFF);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                haveConnection();
                // REMIND: want to warn if unchanged?
                theConnection.setAutoCommit((on==null?false:true));

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * By default, holdability is set to true for Connection objects. This syntax NOHOLDFORCONNECTION lets you set it to close cursors at commit.
 * Syntax:
 *   NOHOLDFORCONNECTION ;
 */
  final public ijResult NoHoldForConnectionStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(NOHOLDFORCONNECTION);
                haveConnection();
                theConnection.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * Localizeddisplay controls locale sensitive data representayion
 * <p>
 * Syntax:
 *   LOCALIZEDDISPLAY [ ON | OFF ] ;
 */
  final public ijResult LocalizedDisplay() throws ParseException {
        Token on=null;
    jj_consume_token(LOCALIZEDDISPLAY);
    switch (jj_nt.kind) {
    case ON:
      on = jj_consume_token(ON);
      break;
    case OFF:
      jj_consume_token(OFF);
      break;
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                LocalizedResource.enableLocalization((on==null?false:true));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * ReadOnly lets you control this aspect of the connection.
 * REMIND: should have a general way to set all connection attributes,
 * this is a shortcut for immediate needs.
 * <p>
 * Syntax:
 *   READONLY [ ON | OFF ] ;
 */
  final public ijResult ReadOnlyStatement() throws ParseException, SQLException {
        Token on=null;
    jj_consume_token(READONLY);
    switch (jj_nt.kind) {
    case ON:
      on = jj_consume_token(ON);
      break;
    case OFF:
      jj_consume_token(OFF);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                haveConnection();
                theConnection.setReadOnly((on==null?false:true));
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * Elapsedtime on causes ij to dump out the elapsed time it takes
 * to run a user statement at the end of that statement.
 * <p>
 * Syntax:
 *   ELAPSEDTIME [ ON | OFF ] ;
 */
  final public ijResult ElapsedTimeStatement() throws ParseException {
        Token on=null;
    jj_consume_token(ELAPSEDTIME);
    switch (jj_nt.kind) {
    case ON:
      on = jj_consume_token(ON);
      break;
    case OFF:
      jj_consume_token(OFF);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                elapsedTime = (on != null);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * MaximumDisplayWidth EXACT_NUMERIC changes the maximum display width for
 * java.lang.String to the specified EXACT_NUMERIC.
 * This is only used by the console view.
 * <p>
 * Syntax:
 *   MAXIMUMDISPLAYWIDTH INTEGER ;
 */
  final public ijResult MaximumDisplayWidthStatement() throws ParseException {
        int       maxWidth;
    jj_consume_token(MAXIMUMDISPLAYWIDTH);
    maxWidth = intValue();
                JDBCDisplayUtil.setMaxDisplayWidth(maxWidth);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public int intValue() throws ParseException {
        Token t;
    t = jj_consume_token(INTEGER);
                {if (true) return Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
  }

/**
 * Bang lets you issue a system command using System.exec.
 * <p>
 * Syntax:
 *   ! 'command to issue' ;
 */
  final public ijResult Bang() throws ParseException {
        Token cmd=null;
    jj_consume_token(BANG);
    cmd = jj_consume_token(STRING);
          ijResult result = null;
          try {
                Process p = Runtime.getRuntime().exec(stringValue(cmd.image));
                LocalizedInput in = new LocalizedInput(p.getInputStream());
                int c;
                Vector v = new Vector();
                StringBuffer output = new StringBuffer();
                // echo output
                while ((c = in.read()) != -1) {
                        output.append((char)c);
                }
                in.close();
                // echo errors
                in = new LocalizedInput(p.getErrorStream());
                // echo output
                while ((c = in.read()) != -1) {
                        output.append((char)c);
                }
                in.close();
                v.addElement(output);
                result = new ijVectorResult(v,null);
                // wait for completion
                try {
                        p.waitFor();
                } catch (InterruptedException e) {
                        {if (true) throw ijException.bangException(e);}
                }
          } catch (IOException ioe) {
                {if (true) throw ijException.bangException(ioe);}
          }
          {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/**
	ExpectStatement is EXPECT [ FAIL ] {'String'}* END EXPECT
	<p>
	Will eventually detect the lines that the strings are without
	special literals, but for now this is expedient (except for the
	doubling of quotes...)
	<p>
	Used to test the previous statement's output. Note that ij must be
	in "expect" mode to use this statement, otherwise it is just
	ignored.  This is due to the overhead of tracking the prior statement's
	output.
 */
  final public ijResult ExpectStatement() throws ParseException {
        Token f = null;
        Vector stringVector = new Vector();
    jj_consume_token(EXPECT);
    switch (jj_nt.kind) {
    case FAIL:
      f = jj_consume_token(FAIL);
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    StringList(stringVector);
    jj_consume_token(END);
    jj_consume_token(EXPECT);
                if (!getExpect()) {if (true) return null;} // don't bother processing.

                // FIXME

                // Do the comparison of the string list to the prior rows of
                // output, using a row-by-row perl-regex comparison.
                boolean result = true;

                // register the result and whether it should be true or false
                // FIXME: how to find the expecter??
                noteExpect(result, f==null);

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void StringList(Vector v) throws ParseException {
    StringItem(v);
    label_1:
    while (true) {
      switch (jj_nt.kind) {
      case STRING:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_1;
      }
      StringItem(v);
    }
  }

  final public void StringItem(Vector v) throws ParseException {
        Token s;
    s = jj_consume_token(STRING);
                v.addElement(s);
  }

/**
	Haven't included: ASYNC, !, EXPECT
	Don't include: XA_*
 **/
  final public ijResult HelpStatement() throws ParseException {
    jj_consume_token(HELP);
                Vector v = new Vector();

                StringTokenizer st = new StringTokenizer(LocalizedResource.getMessage("IJ_HelpText"), "\n");
                while (st.hasMoreTokens()) {
                    v.addElement(st.nextToken());
                }

                {if (true) return new ijVectorResult(v,null);}
    throw new Error("Missing return statement in function");
  }

  final public String identifier() throws ParseException {
        Token t;
    t = jj_consume_token(IDENTIFIER);
                // identifiers are case insensitive, so we map them up.
                // ij doesn't recognize any use of delimited identifiers in its syntax.
                {if (true) return (t.image.toUpperCase(Locale.ENGLISH));}
    throw new Error("Missing return statement in function");
  }

/**
	A qualified identifier is localName [ <AT> sessionName ]
*/
  final public QualifiedIdentifier qualifiedIdentifier() throws ParseException {
        String  sn      = null;
        String  ln      = null;
    ln = identifier();
    switch (jj_nt.kind) {
    case AT:
      jj_consume_token(AT);
      sn = identifier();
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
                if (sn == null) {
                        haveConnection();
                        sn = currentConnEnv.getSession().getName();
                }

                {if (true) return new QualifiedIdentifier(sn, ln);}
    throw new Error("Missing return statement in function");
  }

/**
    A case/connection respectful identifier.

    Like an ordinary identifier(), but require a connection in order
    to extract the case policy from database meta data.
*/
  final public String caIdentifier() throws ParseException, SQLException {
    Token t = null;
    String i = null;
    switch (jj_nt.kind) {
    case ABSOLUTE:
    case AFTER:
    case ALIASES:
    case ALL:
    case AS:
    case ASYNC:
    case ATTRIBUTES:
    case AUTOCOMMIT:
    case BANG:
    case BEFORE:
    case CLOSE:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONNECTIONS:
    case CURRENT:
    case CURSOR:
    case DESCRIBE:
    case DISCONNECT:
    case DRIVER:
    case ELAPSEDTIME:
    case END:
    case EXECUTE:
    case EXIT:
    case EXPECT:
    case FAIL:
    case FIRST:
    case FOR:
    case FROM:
    case GET:
    case GETCURRENTROWNUMBER:
    case HOLD:
    case HELP:
    case IN:
    case INDEXES:
    case INSENSITIVE:
    case INTO:
    case LAST:
    case LOCALIZEDDISPLAY:
    case MAXIMUMDISPLAYWIDTH:
    case NAME:
    case NEXT:
    case NOHOLD:
    case NOHOLDFORCONNECTION:
    case OFF:
    case ON:
    case PASSWORD:
    case PERIOD:
    case PREPARE:
    case PREVIOUS:
    case PROCEDURE:
    case PROCEDURES:
    case PROPERTIES:
    case PROTOCOL:
    case QUIT:
    case READONLY:
    case RELATIVE:
    case REMOVE:
    case RESOURCE:
    case ROLLBACK:
    case RUN:
    case TO:
    case SCHEMAS:
    case SCROLL:
    case SENSITIVE:
    case SET:
    case SHOW:
    case SHUTDOWN:
    case STATEMENT:
    case SYNONYMS:
    case TABLES:
    case USER:
    case USING:
    case VIEWS:
    case WAIT:
    case WITH:
    case XA_1PHASE:
    case XA_2PHASE:
    case XA_DATASOURCE:
    case XA_CONNECT:
    case XA_COMMIT:
    case XA_DISCONNECT:
    case XA_END:
    case XA_ENDRSCAN:
    case XA_FAIL:
    case XA_FORGET:
    case XA_GETCONNECTION:
    case XA_JOIN:
    case XA_NOFLAGS:
    case XA_PREPARE:
    case XA_RECOVER:
    case XA_RESUME:
    case XA_ROLLBACK:
    case XA_START:
    case XA_STARTRSCAN:
    case XA_SUCCESS:
    case XA_SUSPEND:
    case DATASOURCE:
    case CP_DATASOURCE:
    case CP_CONNECT:
    case CP_GETCONNECTION:
    case CP_DISCONNECT:
    case WORK:
      i = keyword();
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        haveConnection();
        DatabaseMetaData dbmd = theConnection.getMetaData();
        String identifier = i;

        if(t!=null)
            identifier = t.image;
        if (dbmd.storesLowerCaseIdentifiers())
            identifier = identifier.toLowerCase(Locale.ENGLISH);
        else if (dbmd.storesUpperCaseIdentifiers())
            identifier = identifier.toUpperCase(Locale.ENGLISH);

        {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

  final public int intLiteral() throws ParseException, SQLException {
        String  sign = "";
        Token   tok;
    switch (jj_nt.kind) {
    case MINUS_SIGN:
    case PLUS_SIGN:
      sign = sign();
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    tok = jj_consume_token(INTEGER);
                /*
		** The various java parse utilities can't handle leading +,
		** so only concatenate leading -.
		*/

                String num = tok.image;

                if (sign.equals("-"))
                {
                        num = sign.concat(num);
                }

                {if (true) return Integer.parseInt(num);}
    throw new Error("Missing return statement in function");
  }

  final public Vector staticMethodName() throws ParseException, SQLException {
        Vector  list = new Vector();
    methodLeg(list);
    label_2:
    while (true) {
      jj_consume_token(PERIOD);
      methodLeg(list);
      switch (jj_nt.kind) {
      case PERIOD:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_2;
      }
    }
                {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public void methodLeg(Vector list) throws ParseException, SQLException {
        Token   id;
    id = jj_consume_token(IDENTIFIER);
                list.addElement( id.image );
  }

  final public String[] staticMethodArgs() throws ParseException, SQLException {
        Vector          list = new Vector();
        String[]        args;
    jj_consume_token(LEFT_PAREN);
    switch (jj_nt.kind) {
    case STRING:
      oneStaticArg(list);
      label_3:
      while (true) {
        switch (jj_nt.kind) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_3;
        }
        jj_consume_token(COMMA);
        oneStaticArg(list);
      }
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    jj_consume_token(RIGHT_PAREN);
                args = new String[ list.size() ];
                list.copyInto( args );

                {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  final public void oneStaticArg(Vector list) throws ParseException, SQLException {
        Token   tok;
    tok = jj_consume_token(STRING);
                list.addElement( stringValue( tok.image ) );
  }

/*
 * <A NAME="sign">sign</A>
 */
  final public String sign() throws ParseException, SQLException {
        Token   s;
    switch (jj_nt.kind) {
    case PLUS_SIGN:
      s = jj_consume_token(PLUS_SIGN);
                {if (true) return s.image;}
      break;
    case MINUS_SIGN:
      s = jj_consume_token(MINUS_SIGN);
                {if (true) return s.image;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
	Undocumented commands to help XA testing.

	This is the grammer for the XA commands

	&lt;XA_DATASOURCE&gt; 'dbname' ( &lt;CREATE&gt; | shutdown ) 
		 - get a XADataSource whose database name is dbname and make that
		XADataSource the current XADataSource

	&lt;XA_CONNECT&gt; 	[ &lt;USER&gt; 'user' ]
			[ &lt;PASSWORD&gt; 'password' ]
			[ &lt;AS&gt; xaconnid ] 
		- make an XAConnection using the current XADataSource and make
		that XAConnection the current XAConnection.  If xaconnid is 
		given, then associate xaconnid with the XAConnection.  
		(xaconnid not implemeneted)


	&lt;XA_COMMIT&gt;  ( &lt;XA_1PHASE&gt; | &lt;XA_2PHASE&gt; ) xid
		- commit a global transaction xid


	&lt;XA_DISCONNECT&gt; [ xaconnid = identifier() ] 
		- disconnect an XAConnection.  If xaconnid is given, then
		disconnect the XAConnection with the given xaconnid. 
		(xaconnid not implemeneted)


	&lt;XA_END&gt; ( &lt;XA_SUSPEND&gt; | &lt;XA_SUCCESS&gt; | &lt;XA_FAIL&gt; ) xid
		- dissociate a transaction from the current XAConnection or end
		an already suspened one 

	&lt;XA_FORGET&gt; xid		- forget about a global transaction

	&lt;XA_GETCONNECTION&gt;  [ &lt;AS&gt; connid ] 
		- get a Connection object from the current XAConnection.
		If connid is given, then associate connid with the connection.
		(connid not implemented)

	&lt;XA_PREPARE&gt; xid	- prepare a global transaction

	&lt;XA_RECOVER&gt; ( &lt;XA_NOFLAGS&gt; | &lt;XA_STARTRSCAN&gt; | &lt;XA_ENDRSCAN&gt; )
	 	- return the list of in-doubt transactions

	&lt;XA_ROLLBACK&gt; xid	- rollback a global transaction

	&lt;XA_START&gt; ( &lt;XA_NOFLAGS&gt; | &lt;XA_JOIN&gt; | &lt;XA_RESUME&gt; ) xid
		- associate a transaction or start a new global
		transaction with the current XAConnection.

	The following is for testing other JDBC2.0 ext interface, DataSource
	and ConnectionPoolDataSource.  Strictly speaking, these are not xa, but
	their functionality will be lumped into xaHelper because these are here
	only for testing purposes.

	&lt;DATASOURCE&gt; 'dbname'	[ &lt;PROTOCOL&gt; 'protocol' ]
				[ &lt;USER&gt; 'user' ]
				[ &lt;PASSWORD&gt; 'password' ]
				[ &lt;AS&gt; n=identifier() ]
		- get a data source whose database name is dbname and make that
		DataSource the current DataSource.  If &lt;PROTOCOL&gt; is specified,
		the DataSource may be remote.   Get a connection from that
		dataSource and use the user/password if specified.

	&lt;CP_DATASOURCE&gt; 'dbname' [ &lt;PROTOCOL&gt; 'protocol' ]
		- get a connection pool data source whose database name is
		dbname and make that DataSource the current CPDataSource.  
		If &lt;PROTOCOL&gt; is specified, the DataSource may be
		remote.

	&lt;CP_CONNECT&gt;	[ &lt;USER&gt; 'user' ]
			[ &lt;PASSWORD&gt; 'password' ]
			[ &lt;AS&gt; cpconnid ]
		- make a PooledConnection using the current CPDataSource and
		make that PooledConnection the current PooledConnection.
		If cpconnid is given, then associate cpconnid with the
		PooledConnection. (cpconnid not implemented).

	&lt;CP_GETCONNECTION&gt; [ &lt;AS&gt; connid ]
		- get a Connection object from the current PooledConnection.
		If connid is given, the associate connid with the connection.
		(connid not implemented)

	&lt;CP_DISCONNECT&gt; [  cpconnid = identifier() ] 
		- disconnect a PooledConnection.  If cpconnid is given, then
		disconnect the PooledConnection with the given cpconnid. 
		(cpconnid not implemented)

*/


/**
 * XA_DataSourceStatement is XA_DataSource 'dbname' ( create | shutdown )
 * We new'ed an instance of XADataSource as the current DataSource and set its
 * database name to dbname.
 */
  final public ijResult XA_DataSourceStatement() throws ParseException, SQLException {
        Token dbname = null;
        Token shut = null;
        String create = null;
    jj_consume_token(XA_DATASOURCE);
    dbname = jj_consume_token(STRING);
    switch (jj_nt.kind) {
    case SHUTDOWN:
    case IDENTIFIER:
      switch (jj_nt.kind) {
      case SHUTDOWN:
        shut = jj_consume_token(SHUTDOWN);
        break;
      case IDENTIFIER:
        create = identifier();
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
                xahelper.XADataSourceStatement(this, dbname, shut, create);

                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_ConnectStatement is XA_CONNECT (&lt;AS&gt; connid)
 * make a XAConnection using the currentXADataSource and make that XAConnection
 * the current XAConnection.  If connid is given, then associate connid with
 * the XAConnection.  This connid is not th xid.
 */
  final public ijResult XA_ConnectStatement() throws ParseException, SQLException {
        Token userT = null;
        Token passwordT = null;
        String n = null;
    jj_consume_token(XA_CONNECT);
    switch (jj_nt.kind) {
    case USER:
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[50] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PASSWORD:
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[52] = jj_gen;
      ;
    }
                xahelper.XAConnectStatement(this, userT, passwordT, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_DisconnectStatement is XA_DISCONNECT [xaconnid = identifier()]
 * disconnect the current XAConnection 
 * If xaconnid is given, then disconnect XAConnection with xaconnid (xaconnid
 *	not implemented).
 * 
 */
  final public ijResult XA_DisconnectStatement() throws ParseException, SQLException {
        String n = null;
    jj_consume_token(XA_DISCONNECT);
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n = identifier();
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
                xahelper.XADisconnectStatement(this, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_CommitStatement is XA_COMMIT [ XA_1PHASE | XA_2PHASE ] xid
 * commits a global transaction xid
 */
  final public ijResult XA_CommitStatement() throws ParseException, SQLException {
        Token onePhase=null;
        Token twoPhase=null;
        int xid = 0;
    jj_consume_token(XA_COMMIT);
    switch (jj_nt.kind) {
    case XA_1PHASE:
      onePhase = jj_consume_token(XA_1PHASE);
      break;
    case XA_2PHASE:
      twoPhase = jj_consume_token(XA_2PHASE);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    xid = intValue();
                xahelper.CommitStatement(this, onePhase, twoPhase, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_EndStatement is XA_END [ XA_SUSPEND | XA_SUCCESS | XA_FAIL] xid
 * dissociates a transaction from the current XAConnection or end an already
 * suspended one
 */
  final public ijResult XA_EndStatement() throws ParseException, SQLException {
        int flag = 0;
        int xid = 0;
    jj_consume_token(XA_END);
    flag = xatmflag();
    xid = intValue();
                xahelper.EndStatement(this, flag, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_ForgetStatement is XA_FORGET xid
 * forgets about a heuristically completed transaction
 */
  final public ijResult XA_ForgetStatement() throws ParseException, SQLException {
        int xid = 0;
    jj_consume_token(XA_FORGET);
    xid = intValue();
                xahelper.ForgetStatement(this, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_GetConnectionStatement is XA_GETCONNECTION
 * it gets a Connection from the currentXAConnection and uses that as the
 * current connection 
 */
  final public ijResult XA_GetConnectionStatement() throws ParseException, SQLException {
        String n = "XA";
    jj_consume_token(XA_GETCONNECTION);
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
                theConnection = xahelper.XAGetConnectionStatement(this, n);
                currentConnEnv.addSession(theConnection, n);

                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_PrepareStatement is XA_PREPARE xid
 * prepares a global transaction
 */
  final public ijResult XA_PrepareStatement() throws ParseException, SQLException {
        int xid = 0;
    jj_consume_token(XA_PREPARE);
    xid = intValue();
                xahelper.PrepareStatement(this, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_RecoverStatement is XA_RECOVER flag
 * displays the list of prepared transactions
 */
  final public ijResult XA_RecoverStatement() throws ParseException, SQLException {
        int flag = 0;
    jj_consume_token(XA_RECOVER);
    flag = xatmflag();
                {if (true) return xahelper.RecoverStatement(this, flag);}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_RollbackStatement is XA_Rollback xid
 * rolls back a global transaction
 */
  final public ijResult XA_RollbackStatement() throws ParseException, SQLException {
        int xid = 0;
    jj_consume_token(XA_ROLLBACK);
    xid = intValue();
                xahelper.RollbackStatement(this, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * XA_StartStatement is XA_START [ XA_NOFLAGS | XA_JOIN | XA_RESUME ] xid
 * start or associates a transaction with the current XAConnection
 */
  final public ijResult XA_StartStatement() throws ParseException, SQLException {
        int flag = 0;
        int xid = 0;
    jj_consume_token(XA_START);
    flag = xatmflag();
    xid = intValue();
                xahelper.StartStatement(this, flag, xid);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public int xatmflag() throws ParseException, SQLException {
    switch (jj_nt.kind) {
    case XA_ENDRSCAN:
      jj_consume_token(XA_ENDRSCAN);
                {if (true) return XAResource.TMENDRSCAN;}
      break;
    case XA_FAIL:
      jj_consume_token(XA_FAIL);
                {if (true) return XAResource.TMFAIL;}
      break;
    case XA_JOIN:
      jj_consume_token(XA_JOIN);
                {if (true) return XAResource.TMJOIN;}
      break;
    case XA_NOFLAGS:
      jj_consume_token(XA_NOFLAGS);
                {if (true) return XAResource.TMNOFLAGS;}
      break;
    case XA_RESUME:
      jj_consume_token(XA_RESUME);
                {if (true) return XAResource.TMRESUME;}
      break;
    case XA_STARTRSCAN:
      jj_consume_token(XA_STARTRSCAN);
                {if (true) return XAResource.TMSTARTRSCAN;}
      break;
    case XA_SUCCESS:
      jj_consume_token(XA_SUCCESS);
                {if (true) return XAResource.TMSUCCESS;}
      break;
    case XA_SUSPEND:
      jj_consume_token(XA_SUSPEND);
                {if (true) return XAResource.TMSUSPEND;}
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * DataSourceStatement is 
 *	DataSource 'dbname' 
 *		[ &lt;PROTCOL&gt; 'protocol']
 *		[ &lt;USER&gt; 'user' ]
 *		[ &lt;PASSWORD&gt; 'password' ]
 *		[ &lt;AS&gt; n=identifier() ]
 *
 * We new'ed an instance of DataSource as the current DataSource and set its
 * database name to dbname.  Also get a connection
 */
  final public ijResult DataSourceStatement() throws ParseException, SQLException {
        Token dbname = null;
        Token protocol = null;
        Token userT = null;
        Token passwordT = null;
        String n = null;
    jj_consume_token(DATASOURCE);
    dbname = jj_consume_token(STRING);
    switch (jj_nt.kind) {
    case PROTOCOL:
      jj_consume_token(PROTOCOL);
      protocol = jj_consume_token(STRING);
      break;
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case USER:
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PASSWORD:
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
                theConnection = xahelper.DataSourceStatement(this, dbname, protocol,
                        userT, passwordT, n);

                {if (true) return addSession( theConnection, n );}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_DataSourceStatement is
 *	CP_DataSource 'dbname' [ &lt;PROTOCOL&gt; 'protocol' ]
 *		- get a connection pool data source whose database name is
 *		dbname and make that DataSource the current CPDataSource.  
 *		If &lt;PROTOCOL&gt; is specified, the DataSource may be
 *		remote.
 */
  final public ijResult CP_DataSourceStatement() throws ParseException, SQLException {
        Token dbname = null;
        Token protocol = null;
    jj_consume_token(CP_DATASOURCE);
    dbname = jj_consume_token(STRING);
    switch (jj_nt.kind) {
    case PROTOCOL:
      jj_consume_token(PROTOCOL);
      protocol = jj_consume_token(STRING);
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
                xahelper.CPDataSourceStatement(this, dbname, protocol);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_ConnectStatement is
 *	&lt;CP_CONNECT&gt;	[ &lt;USER&gt; 'user' ]
 *			[ &lt;PASSWORD&gt; 'password' ]
 *			[ &lt;AS&gt; cpconnid ]
 * make a PooledConnection using the current CPDataSource and
 * make that PooledConnection the current PooledConnection.
 * If cpconnid is given, then associate cpconnid with the
 * PooledConnection. (cpconnid not implemented).
 */
  final public ijResult CP_ConnectStatement() throws ParseException, SQLException {
        Token userT = null;
        Token passwordT = null;
        String n = null;
    jj_consume_token(CP_CONNECT);
    switch (jj_nt.kind) {
    case USER:
      jj_consume_token(USER);
      userT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case PASSWORD:
      jj_consume_token(PASSWORD);
      passwordT = jj_consume_token(STRING);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[64] = jj_gen;
      ;
    }
                xahelper.CPConnectStatement(this, userT, passwordT, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_GetConnectionStatement is
 *	&lt;CP_GETCONNECTION&gt; [ &lt;AS&gt; connid ]
 * get a Connection object from the current PooledConnection.
 * If connid is given, the associate connid with the connection.
 * (connid not implemented)
 */
  final public ijResult CP_GetConnectionStatement() throws ParseException, SQLException {
        String n = "Pooled";
    jj_consume_token(CP_GETCONNECTION);
    switch (jj_nt.kind) {
    case AS:
      jj_consume_token(AS);
      n = identifier();
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
                theConnection = xahelper.CPGetConnectionStatement(this, n);
                currentConnEnv.addSession(theConnection, n);
                {if (true) return new ijConnectionResult(theConnection);}
    throw new Error("Missing return statement in function");
  }

/**
 * CP_DisconnectStatement is
 *	&lt;CP_DISCONNECT&gt; [ cpconnid = identifier() ]
 * disconnect a PooledConnection.  If cpconnid is given, then
 * disconnect the PooledConnection with the given cpconnid. 
 * (cpconnid not implemented)
 */
  final public ijResult CP_DisconnectStatement() throws ParseException, SQLException {
        String n = null;
    jj_consume_token(CP_DISCONNECT);
    switch (jj_nt.kind) {
    case IDENTIFIER:
      n = identifier();
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
                xahelper.CPDisconnectStatement(this, n);
                {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void attributeList(Properties properties) throws ParseException {
        Token tok;
        String value;
    if (getToken(2).kind == EQUALS_OPERATOR) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    property(properties);
    label_4:
    while (true) {
      switch (jj_nt.kind) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[67] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      property(properties);
    }

  }

  final public void property(Properties properties) throws ParseException {
        String key;
        String value;
    key = caseSensitiveIdentifierOrKeyword();
    jj_consume_token(EQUALS_OPERATOR);
    value = caseSensitiveIdentifierOrKeyword();
                properties.put(key, value);
  }

  final public String caseSensitiveIdentifierOrKeyword() throws ParseException {
        String value=null;
        Token tok;
    switch (jj_nt.kind) {
    case ABSOLUTE:
    case AFTER:
    case ALIASES:
    case ALL:
    case AS:
    case ASYNC:
    case ATTRIBUTES:
    case AUTOCOMMIT:
    case BANG:
    case BEFORE:
    case CLOSE:
    case COMMIT:
    case CONNECT:
    case CONNECTION:
    case CONNECTIONS:
    case CURRENT:
    case CURSOR:
    case DESCRIBE:
    case DISCONNECT:
    case DRIVER:
    case ELAPSEDTIME:
    case END:
    case EXECUTE:
    case EXIT:
    case EXPECT:
    case FAIL:
    case FIRST:
    case FOR:
    case FROM:
    case GET:
    case GETCURRENTROWNUMBER:
    case HOLD:
    case HELP:
    case IN:
    case INDEXES:
    case INSENSITIVE:
    case INTO:
    case LAST:
    case LOCALIZEDDISPLAY:
    case MAXIMUMDISPLAYWIDTH:
    case NAME:
    case NEXT:
    case NOHOLD:
    case NOHOLDFORCONNECTION:
    case OFF:
    case ON:
    case PASSWORD:
    case PERIOD:
    case PREPARE:
    case PREVIOUS:
    case PROCEDURE:
    case PROCEDURES:
    case PROPERTIES:
    case PROTOCOL:
    case QUIT:
    case READONLY:
    case RELATIVE:
    case REMOVE:
    case RESOURCE:
    case ROLLBACK:
    case RUN:
    case TO:
    case SCHEMAS:
    case SCROLL:
    case SENSITIVE:
    case SET:
    case SHOW:
    case SHUTDOWN:
    case STATEMENT:
    case SYNONYMS:
    case TABLES:
    case USER:
    case USING:
    case VIEWS:
    case WAIT:
    case WITH:
    case XA_1PHASE:
    case XA_2PHASE:
    case XA_DATASOURCE:
    case XA_CONNECT:
    case XA_COMMIT:
    case XA_DISCONNECT:
    case XA_END:
    case XA_ENDRSCAN:
    case XA_FAIL:
    case XA_FORGET:
    case XA_GETCONNECTION:
    case XA_JOIN:
    case XA_NOFLAGS:
    case XA_PREPARE:
    case XA_RECOVER:
    case XA_RESUME:
    case XA_ROLLBACK:
    case XA_START:
    case XA_STARTRSCAN:
    case XA_SUCCESS:
    case XA_SUSPEND:
    case DATASOURCE:
    case CP_DATASOURCE:
    case CP_CONNECT:
    case CP_GETCONNECTION:
    case CP_DISCONNECT:
    case WORK:
      value = keyword();
                {if (true) return value;}
      break;
    case IDENTIFIER:
      tok = jj_consume_token(IDENTIFIER);
                {if (true) return tok.image;}
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String caseSensitiveIdentifier() throws ParseException {
        Token tok;
    tok = jj_consume_token(IDENTIFIER);
                {if (true) return tok.image;}
    throw new Error("Missing return statement in function");
  }

  final public String keyword() throws ParseException {
        Token tok;
        String value= null;
    switch (jj_nt.kind) {
    case ABSOLUTE:
      tok = jj_consume_token(ABSOLUTE);
      break;
    case AFTER:
      tok = jj_consume_token(AFTER);
      break;
    case ALIASES:
      tok = jj_consume_token(ALIASES);
      break;
    case ALL:
      tok = jj_consume_token(ALL);
      break;
    case AS:
      tok = jj_consume_token(AS);
      break;
    case ASYNC:
      tok = jj_consume_token(ASYNC);
      break;
    case ATTRIBUTES:
      tok = jj_consume_token(ATTRIBUTES);
      break;
    case AUTOCOMMIT:
      tok = jj_consume_token(AUTOCOMMIT);
      break;
    case BANG:
      tok = jj_consume_token(BANG);
      break;
    case BEFORE:
      tok = jj_consume_token(BEFORE);
      break;
    case CLOSE:
      tok = jj_consume_token(CLOSE);
      break;
    case COMMIT:
      tok = jj_consume_token(COMMIT);
      break;
    case CONNECT:
      tok = jj_consume_token(CONNECT);
      break;
    case CONNECTION:
      tok = jj_consume_token(CONNECTION);
      break;
    case CONNECTIONS:
      tok = jj_consume_token(CONNECTIONS);
      break;
    case CURRENT:
      tok = jj_consume_token(CURRENT);
      break;
    case CURSOR:
      tok = jj_consume_token(CURSOR);
      break;
    case DESCRIBE:
      tok = jj_consume_token(DESCRIBE);
      break;
    case DISCONNECT:
      tok = jj_consume_token(DISCONNECT);
      break;
    case DRIVER:
      tok = jj_consume_token(DRIVER);
      break;
    case ELAPSEDTIME:
      tok = jj_consume_token(ELAPSEDTIME);
      break;
    case END:
      tok = jj_consume_token(END);
      break;
    case EXECUTE:
      tok = jj_consume_token(EXECUTE);
      break;
    case EXIT:
      tok = jj_consume_token(EXIT);
      break;
    case EXPECT:
      tok = jj_consume_token(EXPECT);
      break;
    case FAIL:
      tok = jj_consume_token(FAIL);
      break;
    case FIRST:
      tok = jj_consume_token(FIRST);
      break;
    case FOR:
      tok = jj_consume_token(FOR);
      break;
    case FROM:
      tok = jj_consume_token(FROM);
      break;
    case GET:
      tok = jj_consume_token(GET);
      break;
    case GETCURRENTROWNUMBER:
      tok = jj_consume_token(GETCURRENTROWNUMBER);
      break;
    case HOLD:
      tok = jj_consume_token(HOLD);
      break;
    case HELP:
      tok = jj_consume_token(HELP);
      break;
    case IN:
      tok = jj_consume_token(IN);
      break;
    case INDEXES:
      tok = jj_consume_token(INDEXES);
      break;
    case INSENSITIVE:
      tok = jj_consume_token(INSENSITIVE);
      break;
    case INTO:
      tok = jj_consume_token(INTO);
      break;
    case LAST:
      tok = jj_consume_token(LAST);
      break;
    case LOCALIZEDDISPLAY:
      tok = jj_consume_token(LOCALIZEDDISPLAY);
      break;
    case MAXIMUMDISPLAYWIDTH:
      tok = jj_consume_token(MAXIMUMDISPLAYWIDTH);
      break;
    case NAME:
      tok = jj_consume_token(NAME);
      break;
    case NEXT:
      tok = jj_consume_token(NEXT);
      break;
    case NOHOLD:
      tok = jj_consume_token(NOHOLD);
      break;
    case NOHOLDFORCONNECTION:
      tok = jj_consume_token(NOHOLDFORCONNECTION);
      break;
    case OFF:
      tok = jj_consume_token(OFF);
      break;
    case ON:
      tok = jj_consume_token(ON);
      break;
    case PASSWORD:
      tok = jj_consume_token(PASSWORD);
      break;
    case PERIOD:
      tok = jj_consume_token(PERIOD);
      break;
    case PREPARE:
      tok = jj_consume_token(PREPARE);
      break;
    case PREVIOUS:
      tok = jj_consume_token(PREVIOUS);
      break;
    case PROCEDURE:
      tok = jj_consume_token(PROCEDURE);
      break;
    case PROCEDURES:
      tok = jj_consume_token(PROCEDURES);
      break;
    case PROPERTIES:
      tok = jj_consume_token(PROPERTIES);
      break;
    case PROTOCOL:
      tok = jj_consume_token(PROTOCOL);
      break;
    case QUIT:
      tok = jj_consume_token(QUIT);
      break;
    case READONLY:
      tok = jj_consume_token(READONLY);
      break;
    case RELATIVE:
      tok = jj_consume_token(RELATIVE);
      break;
    case REMOVE:
      tok = jj_consume_token(REMOVE);
      break;
    case RESOURCE:
      tok = jj_consume_token(RESOURCE);
      break;
    case ROLLBACK:
      tok = jj_consume_token(ROLLBACK);
      break;
    case RUN:
      tok = jj_consume_token(RUN);
      break;
    case TO:
      tok = jj_consume_token(TO);
      break;
    case SCHEMAS:
      tok = jj_consume_token(SCHEMAS);
      break;
    case SCROLL:
      tok = jj_consume_token(SCROLL);
      break;
    case SENSITIVE:
      tok = jj_consume_token(SENSITIVE);
      break;
    case SET:
      tok = jj_consume_token(SET);
      break;
    case SHOW:
      tok = jj_consume_token(SHOW);
      break;
    case SHUTDOWN:
      tok = jj_consume_token(SHUTDOWN);
      break;
    case STATEMENT:
      tok = jj_consume_token(STATEMENT);
      break;
    case SYNONYMS:
      tok = jj_consume_token(SYNONYMS);
      break;
    case TABLES:
      tok = jj_consume_token(TABLES);
      break;
    case USER:
      tok = jj_consume_token(USER);
      break;
    case USING:
      tok = jj_consume_token(USING);
      break;
    case VIEWS:
      tok = jj_consume_token(VIEWS);
      break;
    case WAIT:
      tok = jj_consume_token(WAIT);
      break;
    case WITH:
      tok = jj_consume_token(WITH);
      break;
    case XA_1PHASE:
      tok = jj_consume_token(XA_1PHASE);
      break;
    case XA_2PHASE:
      tok = jj_consume_token(XA_2PHASE);
      break;
    case XA_DATASOURCE:
      tok = jj_consume_token(XA_DATASOURCE);
      break;
    case XA_CONNECT:
      tok = jj_consume_token(XA_CONNECT);
      break;
    case XA_COMMIT:
      tok = jj_consume_token(XA_COMMIT);
      break;
    case XA_DISCONNECT:
      tok = jj_consume_token(XA_DISCONNECT);
      break;
    case XA_END:
      tok = jj_consume_token(XA_END);
      break;
    case XA_ENDRSCAN:
      tok = jj_consume_token(XA_ENDRSCAN);
      break;
    case XA_FAIL:
      tok = jj_consume_token(XA_FAIL);
      break;
    case XA_FORGET:
      tok = jj_consume_token(XA_FORGET);
      break;
    case XA_GETCONNECTION:
      tok = jj_consume_token(XA_GETCONNECTION);
      break;
    case XA_JOIN:
      tok = jj_consume_token(XA_JOIN);
      break;
    case XA_NOFLAGS:
      tok = jj_consume_token(XA_NOFLAGS);
      break;
    case XA_PREPARE:
      tok = jj_consume_token(XA_PREPARE);
      break;
    case XA_RECOVER:
      tok = jj_consume_token(XA_RECOVER);
      break;
    case XA_RESUME:
      tok = jj_consume_token(XA_RESUME);
      break;
    case XA_ROLLBACK:
      tok = jj_consume_token(XA_ROLLBACK);
      break;
    case XA_START:
      tok = jj_consume_token(XA_START);
      break;
    case XA_STARTRSCAN:
      tok = jj_consume_token(XA_STARTRSCAN);
      break;
    case XA_SUCCESS:
      tok = jj_consume_token(XA_SUCCESS);
      break;
    case XA_SUSPEND:
      tok = jj_consume_token(XA_SUSPEND);
      break;
    case DATASOURCE:
      tok = jj_consume_token(DATASOURCE);
      break;
    case CP_DATASOURCE:
      tok = jj_consume_token(CP_DATASOURCE);
      break;
    case CP_CONNECT:
      tok = jj_consume_token(CP_CONNECT);
      break;
    case CP_GETCONNECTION:
      tok = jj_consume_token(CP_GETCONNECTION);
      break;
    case CP_DISCONNECT:
      tok = jj_consume_token(CP_DISCONNECT);
      break;
    case WORK:
      tok = jj_consume_token(WORK);
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return tok.image;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(DRIVER)) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(NOHOLDFORCONNECTION)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(GETCURRENTROWNUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(XA_DISCONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(EXPECT)) return true;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_3R_117()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(DESCRIBE)) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(PREVIOUS)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(PROTOCOL)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(AUTOCOMMIT)) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(GET)) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(XA_CONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_scan_token(LAST)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(2).kind == EQUALS_OPERATOR;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_110()) return true;
    if (jj_3R_111()) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(XA_START)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_109()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_3R_108()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_107()) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_3R_106()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_105()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_103()) return true;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(RUN)) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_3R_102()) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(AFTER)) return true;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_100()) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(SHOW)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_98()) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_97()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(CP_DISCONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_96()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_3R_95()) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(XA_DATASOURCE)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_3R_94()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(XA_ROLLBACK)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_93()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_92()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_3R_91()) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_90()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_89()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_3R_88()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_3R_87()) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_86()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(NEXT)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_3R_85()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_84()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_57()) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_83()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_3R_82()) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(REMOVE)) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(PREPARE)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_79()) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_3R_78()) return true;
    return false;
  }

  final private boolean jj_3R_24() {
    if (jj_3R_77()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    if (jj_3R_76()) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_scan_token(CP_GETCONNECTION)) return true;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(XA_RECOVER)) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    if (jj_3R_75()) return true;
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_74()) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    if (jj_3R_73()) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_3R_72()) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_71()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    if (jj_3R_69()) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(FIRST)) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    if (jj_3R_68()) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    if (jj_3R_67()) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_64()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(QUIT)) return true;
    return false;
  }

  final private boolean jj_3R_10() {
    if (jj_3R_63()) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_8() {
    if (jj_3R_61()) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    if (jj_3R_60()) return true;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(EXIT)) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) return true;
    }
    return false;
  }

  final private boolean jj_3R_6() {
    if (jj_3R_59()) return true;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(MAXIMUMDISPLAYWIDTH)) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(XA_PREPARE)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(CP_CONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(BEFORE)) return true;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_3R_58()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = getToken(1).kind == ROLLBACK &&
                        (!(getToken(3).kind == TO || getToken(3).kind == SAVEPOINT));
    lookingAhead = false;
    if (!jj_semLA || jj_3R_5()) {
    jj_scanpos = xsp;
    if (jj_3R_6()) {
    jj_scanpos = xsp;
    if (jj_3R_7()) {
    jj_scanpos = xsp;
    if (jj_3R_8()) {
    jj_scanpos = xsp;
    if (jj_3R_9()) {
    jj_scanpos = xsp;
    if (jj_3R_10()) {
    jj_scanpos = xsp;
    if (jj_3R_11()) {
    jj_scanpos = xsp;
    if (jj_3R_12()) {
    jj_scanpos = xsp;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) {
    jj_scanpos = xsp;
    if (jj_3R_15()) {
    jj_scanpos = xsp;
    if (jj_3R_16()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) {
    jj_scanpos = xsp;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) {
    jj_scanpos = xsp;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) {
    jj_scanpos = xsp;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(WAIT)) return true;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(RELATIVE)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(XA_GETCONNECTION)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(ELAPSEDTIME)) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(CP_DATASOURCE)) return true;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(DISCONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(ASYNC)) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(EXECUTE)) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(ABSOLUTE)) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(XA_FORGET)) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(READONLY)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(ROLLBACK)) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_scan_token(HELP)) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(DATASOURCE)) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(CONNECT)) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(XA_END)) return true;
    return false;
  }

  final private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(66)) {
    jj_scanpos = xsp;
    if (jj_scan_token(67)) {
    jj_scanpos = xsp;
    if (jj_scan_token(68)) {
    jj_scanpos = xsp;
    if (jj_scan_token(69)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(71)) {
    jj_scanpos = xsp;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(74)) {
    jj_scanpos = xsp;
    if (jj_scan_token(75)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) {
    jj_scanpos = xsp;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) {
    jj_scanpos = xsp;
    if (jj_scan_token(111)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) {
    jj_scanpos = xsp;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_scan_token(LOCALIZEDDISPLAY)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(COMMIT)) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(CLOSE)) return true;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(XA_COMMIT)) return true;
    return false;
  }

  public ijTokenManager token_source;
  public Token token, jj_nt;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[70];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x87e8c000,0x40000,0x0,0x0,0x0,0x0,0x0,0x100000,0x40000,0x0,0xffffc000,0x40000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x10010000,0x0,0x0,0x20020000,0x20020000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x40000,0x40000,0x0,0x0,0xffffc000,0xffffc000,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x15c2c5c7,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0xffffdfd7,0x0,0x0,0x40000,0x0,0x41000,0x41000,0x40000,0x40000,0x82008,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x100000,0x8010000,0x0,0x0,0x0,0x0,0x0,0x60000000,0x60000000,0x60000000,0x60000000,0x200,0x0,0x0,0xffffdfd7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0xffffdfd7,0xffffdfd7,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x405047c6,0x0,0x0,0x8000,0x40,0x8000000,0x0,0x0,0x0,0x1,0xffdeefff,0x0,0x26000000,0x0,0x1,0x0,0x0,0x0,0x0,0x26221010,0x0,0x0,0x0,0x0,0x80,0x8,0x40000,0x80000000,0x80000,0x0,0x0,0x0,0x10000000,0x1000008,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdeefff,0x0,0x1,0x0,0x0,0x0,0x800000,0x800000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x8000000,0x0,0x0,0x40,0x8000000,0x0,0x0,0x0,0x0,0x0,0xffdeefff,0xffdeefff,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x3e3667c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7ffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x7ffffff,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x1c9980,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x7ffffff,0x7ffffff,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x88,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x0,0x8,0x0,0x0,0x0,0x0,0x88,0x88,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x8,0x6,0x0,0x0,0x80,0x6,0x8,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x8,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[2];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public ij(CharStream stream) {
    token_source = new ijTokenManager(stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(CharStream stream) {
    token_source.ReInit(stream);
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public ij(ijTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ijTokenManager tm) {
    token_source = tm;
    token = new Token();
    token.next = jj_nt = token_source.getNextToken();
    jj_gen = 0;
    for (int i = 0; i < 70; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken = token;
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    jj_nt = token;
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if ((token = jj_nt).next != null) jj_nt = jj_nt.next;
    else jj_nt = jj_nt.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[136];
    for (int i = 0; i < 136; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 70; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 136; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, ijConstants.tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 2; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
