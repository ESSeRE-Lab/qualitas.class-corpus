<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DITA Reference//EN"
 "../dtd/reference.dtd">
<!-- 
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at      

http://www.apache.org/licenses/LICENSE-2.0  

Unless required by applicable law or agreed to in writing, software  
distributed under the License is distributed on an "AS IS" BASIS,  
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
See the License for the specific language governing permissions and  
limitations under the License.
-->
<reference id="rrefsqlj37836" xml:lang="en-us">
<title>発番列仕様</title>
<prolog><metadata>
<keywords><indexterm>Identity column attributes</indexterm><indexterm>generated-column-spec</indexterm>
</keywords>
</metadata></prolog>
<refbody>
<example> <codeblock><b>[ GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY 
[ ( START WITH 定整数
[ ,INCREMENT BY 定整数] ) ]  ]  ]
</b></codeblock></example>
<section id="sqlj69411"><title>識別子列属性</title>
<p>SMALLINT、INT、BIGINT型の列に識別子属性があると、<ph conref="../conrefs.dita#prod/productshortname"></ph>は自動的に列の値に、増加する整数値をあてます。挿入文で列の値が指定されない場合、識別子列属性は既定値と同様に振る舞い、<ph conref="../conrefs.dita#prod/productshortname"></ph>は列に自動的に値を与えます。
しかしながら、その値は定数ではありません。<ph conref="../conrefs.dita#prod/productshortname"></ph>は行に挿入する時、自動的に既定値へ加算してゆきます。</p><p>IDENTITYというキーワードは列のデータ型が次のいずれの整数である場合にのみ指定可能です。<ul>
<li>SMALLINT</li>
<li>INT</li>
<li>BIGINT</li>
</ul></p><p><ph conref="../conrefs.dita#prod/productshortname"></ph>には二種類の識別子列があります。ひとつはGENERATED ALWAYSで、もう一つはGENERATED BY DEFAULTです。<dl>
<dlentry>
<dt>GENERATED ALWAYS</dt>
<dd>GENERATED ALWAYSの識別子列は列の既定値を、挿入が行われるときごとに増加させて、その増加された値を列に記録します。他の既定値とは違い、GENERATED ALWAYSの識別子列に値を直接挿入したり、その値を変更したりすることはできません。その代わりに識別子列の値にはDEFAULTというキーワードを与えるか、識別子列を挿入する列の一覧からはずすかします。
例を挙げます。<codeblock>create table greetings
	(i int generated always as identity, ch char(50));
insert into greetings values (DEFAULT, 'hello');
insert into greetings(ch) values ('bonjour');</codeblock>GENERATED ALWAYSな識別子列に自動的に発番された値は一意です。また識別子列を作成しても、列に索引は作られません。</dd>
</dlentry><dlentry>
<dt>GENERATED BY DEFAULT</dt>
<dd><p>GENERATED BY DEFAULTの識別子列は、挿入時に列へ明示的な値が与えられなかった場合のみ、既定値を増加させて使います。GENERATED ALWAYSの列とは違い、挿入文にて明示的な値を既定値の変わりに与えることができます。</p><p>生成された既定値を使うためには、挿入時にDEFAULTというキーワードを使うか、識別子列を挿入列リストから外します。挿入する値を指定するには、その値を挿入文に含めます。例を挙げます。<codeblock>create table greetings
	(i int generated by default as identity, ch char(50));
<b>-- "1"を指定する:</b>
insert into greetings values (1, 'hi');
<b>-- 生成された既定値を使う</b>
insert into greetings values (DEFAULT, 'salut');
<b>-- 生成された既定値を使う</b>
insert into greetings(ch) values ('bonjour'); </codeblock>
GENERATED ALWAYS列とは異なり、GENERATED BY DEFAULTの列では一意性は保障されません。したがって、上記の例では<codeph>hi</codeph>および<codeph>salut</codeph>の行はどちらも同じ"1"という識別値を取ります。なぜなら、生成された列の値は"1"から始まり、ユーザが指定した値も"1"だったからです。重複を避けるために、情報のロードやインポートを行うときにテーブルを作成して、システムが自動生成するためのSTART WITHの値を与えてください。このような状況をチェックして、起きないようにするために、主キーや一意性制約をGENERATED BY DEFAULTの識別子列に使うことができます。</p></dd>
</dlentry></dl></p><p>既定では識別子列の初期値は1です。さらに増分値は1です。
列を定義するとき、初期値と増分値の両方に、START WITHとINCREMENT BYというキーワードを使って、明示的な値を指定することができます。さらに増分値に負の値を与えると、挿入毎に<ph conref="../conrefs.dita#prod/productshortname"></ph>は値を<i>減じて</i>ゆきます。
もし値が正の値であれば、挿入毎に<ph conref="../conrefs.dita#prod/productshortname"></ph>は値を増加させてゆきます。 値に0を与えると例外が発生します。</p>
<p>識別子列にて可能な最大値と最小値は、列のデータ型によります。データ型で採ることのできる範囲外の値を挿入しようとすると、例外が発生します。<table frame="all">
<title>発番列仕様にて、列でとることが可能な最大値と最小値</title>
<tgroup cols="3" colsep="1" rowsep="1"><colspec colname="1" colnum="1" colwidth="16*"/>
<colspec colname="2" colnum="2" colwidth="42*"/><colspec colname="3" colnum="3"
colwidth="42*"/>
<thead>
<row>
<entry align="left" colname="1" valign="bottom">データ型</entry>
<entry align="left" colname="2" valign="bottom">最大値</entry>
<entry align="left" colname="3" valign="bottom">最小値</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="1">SMALLINT</entry>
<entry colname="2">32767 (<i>java.lang.Short.MAX_VALUE</i>)</entry>
<entry colname="3">-32768 (<i>java.lang.Short.MIN_VALUE</i>)</entry>
</row>
<row>
<entry colname="1">INT</entry>
<entry colname="2">2147483647 (<i>java.lang.Integer.MAX_VALUE</i>)</entry>
<entry colname="3">-2147483648 (<i>java.lang.Integer.MIN_VALUE</i>)</entry>
</row>
<row>
<entry colname="1">BIGINT</entry>
<entry colname="2">9223372036854775807 (<i>java.lang.Long.MAX_VALUE</i>)</entry>
<entry colname="3">-9223372036854775808 (<i>java.lang.Long.MIN_VALUE</i>)</entry>
</row>
</tbody>
</tgroup>
</table></p><p>識別子列にて自動的に生成された値は一意です。主キー制約や一意性制約を列に定義することで、一意性を保障する事ができます。識別子列を定義しても、列の索引は<i>作られません
。</i></p>
<p><codeph>IDENTITY_VAL_LOCAL</codeph>関数は、非決定性の関数で最後に識別子列に与えられた値を返します。詳細については、<xref href="rrefidentityvallocal.dita#rrefidentityvallocal"></xref>を参照してください。</p>
<note>スキーマ・表・列の名前はデリミトされた識別子を使わない限り、常にシステム表にて大文字で記録されます。</note>
<p><ph conref="../conrefs.dita#prod/productshortname"></ph>は列に対して最後に発番された値をキャッシュに残しています。また、ディスク上では、<i>SYS.SYSCOLUMNS</i>というシステム表の<i>AUTOINCREMENTVALUE</i>という列に、次の値を記録しています。 トランザクションをロールバックしてもこの値は取り消されません。したがって、トランザクションがロールバックされると、識別子列に挿入される自動生成値には、空きが発生することとなります。
<ph conref="../conrefs.dita#prod/productshortname"></ph> はこのように動作することで、<i>SYS.SYSCOLUMNS</i>の行をトランザクションの期間中ロックし続けることを回避して、高い平行性を保っています。</p><p><indexterm>Identity
columns <indexterm>and triggers</indexterm></indexterm>トリガされたSQL文にて識別子列に値が挿入された場合、そのSQL文で挿入された値は、トリガのコード内でのみ<i>ConnectionInfo</i>から取得可能です。 
また、トリガのコードはトリガをひいた文が挿入した値を取得することもできます。
しかし、トリガをひいた文は、トリガされたSQL文が識別子列に挿入した値を知ることができません。
さらにトリガは入れ子(再帰)の場合も同じようなこととなります。
SQL文によりT1というトリガが発火され、次にT1の実行したSQLによりT2というトリガが発火されたとします。ここでT1もT2も表に識別子列に値がある行を挿入した場合、T1はT2が挿入した値を見ることはできませんが、T2はT1が挿入した値を見ることができます。それぞれの入れ子になったトリガは自分自身と、再帰的なトリガを開始したSQLを含めて、入れ子のレベルが前の処理にて生成された値を見ることができます。
なおトリガの再帰は16まで可能です。</p> </section>
<section><title>例</title><codeblock>create table greetings
  (i int generated by default as identity (START WITH 2, INCREMENT BY 1),
  ch char(50));
-- 1を指定する。
insert into greetings values (1, 'hi');
-- 生成された既定値を使う
insert into greetings values (DEFAULT, 'salut');
-- 生成された既定値を使う
insert into greetings(ch) values ('bonjour'); </codeblock></section>
</refbody>
</reference>
