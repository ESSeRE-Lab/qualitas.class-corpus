<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE reference PUBLIC "-//OASIS//DTD DITA Reference//EN"
 "../dtd/reference.dtd">
<!-- 
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at      

http://www.apache.org/licenses/LICENSE-2.0  

Unless required by applicable law or agreed to in writing, software  
distributed under the License is distributed on an "AS IS" BASIS,  
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
See the License for the specific language governing permissions and  
limitations under the License.
-->
<reference id="rrefsqlj81859" xml:lang="ja">
<title>ALTER TABLE 文</title>
<prolog><metadata>
<keywords><indexterm>ALTER TABLE statement</indexterm><indexterm>Compressing
tables</indexterm><indexterm>Tables<indexterm>altering</indexterm><indexterm>compressing</indexterm></indexterm>
<indexterm>Columns<indexterm>adding</indexterm></indexterm><indexterm>Constraints<indexterm>adding</indexterm><indexterm>dropping</indexterm><indexterm
>compressing</indexterm></indexterm><indexterm>Defaults<indexterm>adding</indexterm><indexterm>dropping</indexterm></indexterm>
<indexterm>Adding Columns</indexterm><indexterm>Adding Constraints</indexterm>
<indexterm>Dropping Constraints</indexterm><indexterm>Defaults<indexterm>setting</indexterm></indexterm>
<indexterm>Tables<indexterm>changing lock granularity for</indexterm></indexterm>
<indexterm>Data types<indexterm>modifying</indexterm></indexterm></keywords>
</metadata></prolog>
<refbody>
<section><p>The ALTER TABLE 文により次のことが可能です。<ul>
<li>表に列を追加する。</li>
<li>表に制約を追加する。</li>
<li>表の列を破棄する。</li>
<li>表にある制約を破棄する。</li>
<li>VARCHAR, CHAR VARYING, and CHARACTER VARYING 列の幅を増やす。</li>
<li>表に定義された行レベルのロックを上書きする。(あるいは上書きされた内容を破棄する。)</li>
<li>識別子列の増分値や開始値を変更する。</li>
<li>列がNull可であるか否か変更する。</li>
<li>列の規定値を変更する。</li>
</ul></p></section>
<section><title>構文</title><codeblock><b>ALTER TABLE <i><xref href="rreftablename.dita#rreftablename">表名</xref></i>
{
    ADD COLUMN <i><xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef">列定義</xref></i> |
    ADD <i><xref href="rrefsqlj13590.dita#rrefsqlj13590">CONSTRAINT節</xref></i> |
    DROP [ COLUMN ] 列名 [ CASCADE | RESTRICT ]
    DROP { PRIMARY KEY | FOREIGN KEY 制約名 | UNIQUE 
	 制約名 | CHECK 制約名 | CONSTRAINT 制約名 }
    ALTER [ COLUMN ] <i><xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860">列定義変更</xref></i> |
    LOCKSIZE { ROW | TABLE }
}</b></codeblock></section>
<example id="rrefaltercolumndef"> <title>列定義</title><codeblock><b><i><xref
href="rrefsimplecolumnname.dita#rrefsimplecolumnname">単純列名</xref></i> <i>データ型</i>
[ <i><xref href="rrefsqlj16095.dita#rrefsqlj16095">列単位制約</xref></i> ]*
[ [ WITH ] DEFAULT <varname>既定制約式</varname> ]</b></codeblock>
<p><varname>既定制約式</varname>の詳細については、<xref href="rrefsqlj30540.dita#sqlj64478">列の既定</xref>を参照してください。</p></example>
<example id="rrefsqlj37860"><title>列定義変更</title><codeblock><b><i>列名</i> SET DATA TYPE VARCHAR(integer) |
<i>column-name</i> SET INCREMENT BY 定整数 |
<i>column-name</i> RESTART WITH 定整数 |
<i>column-name</i> [ NOT ] NULL |
<i>column-name</i> [ WITH ] DEFAULT 既定値</b> </codeblock></example>
<section><p>列定義変更のSET INCREMENT BY 定整数により、識別子列のとる連続した値の間隔が設定されます。識別子列がとる次の値は、最後にとられた値に増分が加算された値となります。この場合列にはあらかじめIDENTITY属性が定義されていなければなりません。</p><p>RESTART WITH 定整数により、識別子列がとる次の値が設定されます。RESTART WITHは、GENERATED BY DEFAULTが定義された、一意キーを持つ識別子列のある表に使うと便利です。GENERATED BY DEFAULTは明示的に値を挿入することおよび、暗黙的にシステムが発番した値を挿入することのいずれをも許すため、明示的に挿入された値がシステムが発番する値との間で競合する事がありえます。この競合を回避するために、RESTART WITHにより識別子列で次に発番される値を設定する事ができるのです。自動的に発番された値と手動で挿入された情報がある、次の例について考えてみてください。
<codeblock><b>CREATE TABLE tauto(i INT GENERATED BY DEFAULT AS IDENTITY, k INT)
CREATE UNIQUE INDEX tautoInd ON tauto(i)
INSERT INTO tauto(k) values 1,2</b></codeblock></p>
<p>システムは自動的に識別子列に対して数値を発番します。しかしながら、あなたは手動で識別子列に幾つかの値を挿入しなければなりませんでした。
<codeblock><b>INSERT INTO tauto VALUES (3,3)
INSERT INTO tauto VALUES (4,4)
INSERT INTO tauto VALUES (5,5)</b></codeblock></p>
<p>識別子列にはこの時点で1から5の値があります。ここであなたがシステムに値を発番させると、システムは3という値を発番します。この値により一意キー例外が発生します。なぜなら3という値は既に手動で挿入されてしまっているからです。手動で値を挿入したので後処理として、識別子列に対してRESTART WITH 6 のALTER TABLE文を発行します。
<codeblock><b>ALTER TABLE tauto ALTER COLUMN i RESTART WITH 6</b></codeblock></p><p>ALTER
TABLE は表を参照するいかなるビューにも影響しません。これはSELECT一覧に"*"を持っていても然りです。新しく追加された列がビューから見えるようにする為には、ビューを破棄して作り直さなければなりません。</p></section>
<section><title>列の追加</title>
<p><i>追加する列の<xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefaltercolumndef">列定義</xref
></i>は、構文の上でCREATE TABLE文の列と同じです。ですから、列の制約をALTER TABLE ADD COLUMN文の新しい列に書くこともできます。しかしながら、既存のテーブルにNOT NULL制約のある列を追加することは、その列に既定値を与えた場合のみ可能です。さもなければ、ALTER TABLE文が実行されたとき、例外が発生します。</p>
<p>CREATE TABLEと同様、列定義に一意あるいは主キー制約がある場合、列はnull値をとることができません。したがって、NOT NULL属性も必要です。(SQLSTATE 42831)
</p><note>表に明示的な列一覧が指定されないUPDATEトリガが定義されていた場合、その表に列を追加すると、追加された列はUPDATEトリガの暗黙的な更新列一覧に追加されます。さらに新しい列を拾うことができるよう、推移変数への全ての参照は無効となります。</note></section>
<section><title>制約の追加</title>
<p>ALTER TABLE ADD CONSTRAINTにより表ごとの制約が既存の表に追加されます。あらゆる種類の表ごとの制約がALTER TABLEで追加できます。ただし、既存の表への制約の追加には次の機能上の制限があります。<ul>
<li>外部キーやチェック制約が既存の表に追加されるとき<ph
conref="../conrefs.dita#prod/productshortname"></ph>は既存の行が制約に違反しないか、表を調べます。もしいずれかの行が制約に違反する場合、<ph conref="../conrefs.dita#prod/productshortname"></ph>は例外を投げて制約は追加されません。</li>
<li>主キーに含まれるあらゆる列はnullでない値をとらなければならず、また一意でなければなりません。<p>ALTER TABLE ADD UNIQUEやPRIMARY KEYは、単一の列による主キーを定義する簡単な方法を提供します。もしPRIMARY KEYがCという列の定義に書かれたされた場合、これはPRIMARY KEY(C)という別の節に書いたのと同じです。列はnullの値をとってはならないので、NOT NULL属性も指定されなければなりません。</p></li>
</ul></p><p>制約の構文についての詳細は、<xref href="rrefsqlj13590.dita#rrefsqlj13590"></xref>を読んでください。
ADD TABLE ADD CONSTRAINTという書き方にて、制約を追加する場合は、表毎の制約の構文に従ってください。</p></section>
<section><title>列の破棄</title><p>ALTER TABLE DROP COLUMNにより、表から列を破棄できます。</p>
<p>COLUMNというキーワードは無くてもかまいません。</p>
<p>CASCADEやRESTRICTも、無くてかまいません。どちらも指定しなかった場合、既定はCASCADEです。</p>
<p>
RESTRICTの場合、依存しているスキーマの情報が無効になるならば、列の破棄は失敗します。</p>
<p>
CASCADEの場合、列の破棄と併せて、無効になるスキーマの情報も破棄されます。</p>
<p>
DROP COLUMN RESTRICTが失敗する原因となるスキーマの情報には、次が含まれます。
ビュー、トリガ、主キー制約、外部キー制約、一意キー制約、チェック制約、列権限。破棄する列に依存するいずれかの情報があれば、DROP COLUMN RESTRICTは失敗します。</p>
<p>
表にひとつしかない列は、破棄することができません。</p>
<p>
sqlAuthorizationが真である場合、列を削除することはできません。(DERBY-1909を参照してください。)
)</p>
<p>
列が索引にて使われているか否かにかかわらず、列の破棄はCASCADE/RESTRICTのどちらでも同じように行われます。列が破棄されるとき、索引にあるその列が取り除かれます。その列が索引にあるただひとつの列であった場合、索引全体が破棄されます。</p></section>
<section><title>制約の破棄</title><p>ALTER TABLE DROP CONSTRAINTにより表の制約を破棄できます。名前付けしていない制約を破棄するためには、<i>SYS.SYSCONSTRAINTS</i>に記録されている自動生成された制約の名前をデリミトされた識別子として指定する必要があります。</p>
<p>主キー・一意性・外部キー制約を破棄すると、その制約が機能するために存在している索引が破棄されます。(この索引は<i>支援索引</i>とも呼ばれます。)</p></section>
<section><title>列の変更</title>
<p><i><xref href="rrefsqlj81859.dita#rrefsqlj81859/rrefsqlj37860">列定義変更</xref></i>により、名前のある列を変更できます。可能な変更内容は以下のとおりです。
<ul>
<li>VARCHAR列の長さを増やすことができます。VARCHARというキーワードの代わりに、CHARACTER VARYINGやCHAR VARYINGを使うことができます。
<p>これらの列の幅を増やすためには、データ型と新しいサイズを列名の後に書きます。</p>
<p>列の幅を減らしたり、データ型を変更したりする事はできません。主キーの一部や、外部キー制約から参照されている一意キー、外部キー制約の一部である列の幅は変更できません。</p></li>
<li>識別子列のとる連続した値の間隔を指定することができます。<p>
識別子列のとる連続した値の間隔を設定するためには、定整数を与えます。あらかじめ列には識別子属性が与えられていなければなりません。(SQLSTATE 42837)もし表に既に行がある場合、列のSET INCREMENT defaultが加算された値は変更されません。</p></li>
<li>列のNullへの制約の変更
列がNullをとる事への制約を変更できます。
    <p>NOT NULL制約を既存の列に与えることができます。これを行う場合、既存のNULL値が表のその列に存在してはなりません。</p>
    <p>NOT NULL制約を既存の列から取り除くことができます。これを行う場合、その列がPRIMARY KEYやUNIQUEの制約にて使われている列であってはなりません。</p></li>
<li>列の既定値を変更する</li>
</ul></p></section>
<section><title>既定値の設定</title><p>新規の列に既定値を与えることができます。既定値とは値が指定されなかった場合に列に挿入される値です。もし明示的に既定値が与えられていなかった場合、列の既定値はNULLです。もし新しい列に既定値を与えた場合、表にある既存の行はその新列に既定値をとることとなります。</p><p>既定値のより詳細な情報については、<xref href="rrefsqlj24513.dita#rrefsqlj24513"></xref>を参照してください。</p></section>
<section><title>表のロック粒度の変更</title>
<p>もしあなたのシステムが既定の設定である行毎のロックを行うのであれば、LOCKSIZE節により表の行毎のロックを上書きすることができます。(一方あなたのシステムが表ごとのロックを行うよう設定されている場合、<ph conref="../conrefs.dita#prod/productshortname"></ph>がLOCKSIZE節に対して例外を投げなかったとしても、ロックの粒度を行単位のロックに変更することはできません。)
表の行毎のロックを上書きするには、表にロックの設定を行います。
もし表が表毎のロックで作成された場合、ALTER TABLE文にてLOCKSIZE節を使うことで、その設定を行毎の設定に戻すことができます。これが便利な場合もあるのですが、その詳細については、<cite><ph
conref="../conrefs.dita#pub/cittuning"></ph></cite>を参照してください。</p></section>
<section><title>例</title><codeblock><b><ph>-- 既存の表に列ごとの制約のある列を追加する。
-- 表に既存行があった場合、既存行の新列はNULLをとるので、
-- 例外が発生する。</ph>
ALTER TABLE CITIES ADD COLUMN REGION VARCHAR(26)
CONSTRAINT NEW_CONSTRAINT CHECK (REGION IS NOT NULL);

<ph>-- 既存の表に一意性制約を追加する。
-- 重複したキーがあった場合、例外が発生する。</ph>
ALTER TABLE SAMP.DEPARTMENT
ADD CONSTRAINT NEW_UNIQUE UNIQUE (DEPTNO);

<ph>-- Cities表に外部キー制約を追加する。
-- 行が制約を満たすか検証されて、
-- もし制約を満たさない行が見つかった場合、
-- 制約は追加されない。</ph>
ALTER TABLE CITIES ADD CONSTRAINT COUNTRY_FK
Foreign Key (COUNTRY) REFERENCES COUNTRIES (COUNTRY);

<ph>-- 主キー制約を表に追加する。
-- 最初に表が作成される。</ph>
CREATE TABLE ACTIVITIES (CITY_ID INT NOT NULL,
SEASON CHAR(2), ACTIVITY VARCHAR(32) NOT NULL);
<ph>-- もし主キーとした列にnullや重複した値がある場合、
-- この制約を追加することはできない。</ph>
ALTER TABLE Activities ADD PRIMARY KEY (city_id, activity);

<ph>-- もし依存する情報が無ければ、city_id列が破棄される。</ph>
ALTER TABLE Cities DROP COLUMN city_id RESTRICT;
<ph>-- 依存する情報と併せて、city_id列が破棄される。</ph>
ALTER TABLE Cities DROP COLUMN city_id CASCADE;

<ph>-- CITIES表の主キー制約を破棄する。</ph>
ALTER TABLE Cities DROP CONSTRAINT Cities_PK;
<ph>-- CITIES表の外部キー制約を破棄する。</ph>
ALTER TABLE Cities DROP CONSTRAINT COUNTRIES_FK;
<ph>-- 既定値を1にとるDEPTNO列を追加する。</ph>
ALTER TABLE SAMP.EMP_ACT ADD COLUMN DEPTNO INT DEFAULT 1;
<ph>-- VARCHAR型の列幅を増やす。</ph>
ALTER TABLE SAMP.EMP_PHOTO ALTER PHOTO_FORMAT SET DATA TYPE VARCHAR(30);
<ph>-- 表のロック粒度を変更する。</ph>
ALTER TABLE SAMP.SALES LOCKSIZE TABLE;

<ph>-- MANAGER列のNOT NULL制約を破棄する。</ph>
ALTER TABLE Employees ALTER COLUMN Manager NULL;
<ph>-- SSN列にNOT NULL制約を追加する。</ph>
ALTER TABLE Employees ALTER COLUMN ssn NOT NULL;

<ph>-- SALARY列の既定値を変更する。</ph>
ALTER TABLE Employees ALTER COLUMN Salary DEFAULT 1000.0

</b></codeblock></section>
<section><title>文の結果</title><p>ALTER TABLE 文により変更する表に依存する全ての文は、次回の実行にて再コンパイルされます。もし変更する表を参照する、開いたカーソルがある場合、ALTER TABLEは許可されません。</p></section>
</refbody>
</reference>
