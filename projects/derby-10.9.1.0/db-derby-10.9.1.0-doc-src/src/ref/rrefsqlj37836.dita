<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE reference PUBLIC "-//OASIS//DTD DITA Reference//EN"
 "../dtd/reference.dtd">
<!-- 
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at      

http://www.apache.org/licenses/LICENSE-2.0  

Unless required by applicable law or agreed to in writing, software  
distributed under the License is distributed on an "AS IS" BASIS,  
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
See the License for the specific language governing permissions and  
limitations under the License.
-->
<reference id="rrefsqlj37836" xml:lang="en-us">
<title>generated-column-spec</title>
<prolog><metadata>
<keywords><indexterm>Identity column attributes</indexterm><indexterm>generated-column-spec</indexterm>
</keywords>
</metadata></prolog>
<refbody>
<example> <codeblock><b>[ GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY 
[ ( START WITH IntegerConstant 
[ ,INCREMENT BY IntegerConstant] ) ]  ]  ]
</b></codeblock></example>
<section id="sqlj69411"><title>Identity column attributes</title>
<p>A table can have at most one identity column.</p><p>For SMALLINT,
INT, and BIGINT columns with identity attributes, <ph conref="../conrefs.dita#prod/productshortname"></ph> automatically
assigns increasing integer values to the column. Identity column attributes
behave like other defaults in that when an insert statement does not specify
a value for the column, <ph conref="../conrefs.dita#prod/productshortname"></ph> automatically
provides the value. However, the value is not a constant; <ph conref="../conrefs.dita#prod/productshortname"></ph> automatically
increments the default value at insertion time.</p><p>The IDENTITY keyword
can only be specified if the data type associated with the column is one of
the following exact integer types.    <ul>
<li>SMALLINT</li>
<li>INT</li>
<li>BIGINT</li>
</ul></p><p>There are two kinds of identity columns in <ph conref="../conrefs.dita#prod/productshortname"></ph>:
those which are GENERATED ALWAYS and those which are GENERATED BY DEFAULT. <dl>
<dlentry>
<dt>GENERATED ALWAYS</dt>
<dd>An identity column that is GENERATED ALWAYS will increment the default
value on every insertion and will store the incremented value into the column.
Unlike other defaults, you cannot insert a value directly into or update an
 identity column that is GENERATED ALWAYS. Instead, either specify the DEFAULT
keyword when inserting into the identity column, or leave the identity column
out of the insertion column list altogether. For example:<codeblock>create table greetings
	(i int generated always as identity, ch char(50));
insert into greetings values (DEFAULT, 'hello');
insert into greetings(ch) values ('bonjour');</codeblock>Automatically generated
values in a GENERATED ALWAYS identity column are unique. Creating an identity
column does not create an index on the column.</dd>
</dlentry><dlentry>
<dt>GENERATED BY DEFAULT</dt>
<dd><p>An identity column that is GENERATED BY DEFAULT will only increment
and use the default value on insertions when no explicit value is given. Unlike
GENERATED ALWAYS columns, you can specify a particular value in an insertion
statement to be used instead of the generated default value.</p><p>To use
the generated default, either specify the DEFAULT keyword when inserting into
the identity column, or just leave the identity column out of the insertion
column list. To specify a value, included it in the insertion statement. For
example:<codeblock>create table greetings
	(i int generated by default as identity, ch char(50));
<b>-- specify value "1":</b>
insert into greetings values (1, 'hi');
<b>-- use generated default</b>
insert into greetings values (DEFAULT, 'salut');
<b>-- use generated default</b>
insert into greetings(ch) values ('bonjour'); </codeblock>Note that unlike
a GENERATED ALWAYS column, a GENERATED BY DEFAULT column does not guarantee
uniqueness.  Thus, in the above example, the <codeph>hi</codeph> and <codeph>salut</codeph> rows
will both have an identity value of "1", because the generated column starts
at "1" and the user-specified value was also "1". To prevent duplication,
especially when loading or importing data, create the table using the START
WITH value which corresponds to the first identity value that the system should
assign. To check for this condition and disallow it, you can use a primary
key or unique constraint on the GENERATED BY DEFAULT identity column.</p></dd>
</dlentry></dl></p><p>By default, the initial value of an identity column
is 1, and the amount of the increment is 1. You can specify non-default values
for both the initial value and the interval amount when you define the column
with the key words START WITH and INCREMENT BY. And if you specify a negative
number for the increment value, <ph conref="../conrefs.dita#prod/productshortname"></ph> <i>decrements</i> the
value with each insert. If this value is positive, <ph conref="../conrefs.dita#prod/productshortname"></ph> increments
the value with each insert. A value of 0 raises a statement exception. </p><p>The maximum and minimum values allowed in
identity columns are determined by the data type of the column. Attempting
to insert a value outside the range of values supported by the data type raises
an exception. The following table shows the supported ranges.</p>
<table frame="all">
<title>Maximum and minimum values for columns with generated column
specs</title>
<desc>This table lists the maximum and minimum values for each data type for columns with generated column specs.</desc>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="1" colnum="1" colwidth="16*"/>
<colspec colname="2" colnum="2" colwidth="42*"/>
<colspec colname="3" colnum="3" colwidth="42*"/>
<thead>
<row valign="bottom">
<entry colname="1">Data Type</entry>
<entry colname="2">Maximum Value</entry>
<entry colname="3">Minimum Value</entry>
</row>
</thead>
<tbody>
<row>
<entry colname="1">SMALLINT</entry>
<entry colname="2">32767 (<i>java.lang.Short.MAX_VALUE</i>)</entry>
<entry colname="3">-32768 (<i>java.lang.Short.MIN_VALUE</i>)</entry>
</row>
<row>
<entry colname="1">INT</entry>
<entry colname="2">2147483647 (<i>java.lang.Integer.MAX_VALUE</i>)</entry>
<entry colname="3">-2147483648 (<i>java.lang.Integer.MIN_VALUE</i>)</entry>
</row>
<row>
<entry colname="1">BIGINT</entry>
<entry colname="2">9223372036854775807 (<i>java.lang.Long.MAX_VALUE</i>)</entry>
<entry colname="3">-9223372036854775808 (<i>java.lang.Long.MIN_VALUE</i>)</entry>
</row>
</tbody>
</tgroup>
</table>
<p>Automatically generated values in an identity column are unique.
Use a primary key or unique constraint on a column to guarantee uniqueness.
Creating an identity column <i>does not</i> create an index on the column.</p><p>The <codeph>IDENTITY_VAL_LOCAL</codeph> function
is a non-deterministic function that  returns the most recently assigned value
for an identity column. See <xref href="rrefidentityvallocal.dita#rrefidentityvallocal"></xref> for
more information.</p><note>Specify the schema, table, and column name using
the same case as those names are stored in the system tables--that is, all
upper case unless you used delimited identifiers when creating those database
objects.</note><p><ph conref="../conrefs.dita#prod/productshortname"></ph> keeps
track of the last increment value for a column in a cache. It also stores
the value of what the next increment value will be for the column on disk
in the <i>AUTOINCREMENTVALUE</i> column of the <i>SYS.SYSCOLUMNS</i> system
table. Rolling back a transaction does not undo this value, and thus rolled-back
transactions can leave "gaps" in the values automatically inserted into an
identity column. <ph conref="../conrefs.dita#prod/productshortname"></ph> behaves
this way to avoid locking a row in <i>SYS.SYSCOLUMNS</i> for the duration
of a transaction and keeping concurrency high. </p><p><indexterm>Identity
columns <indexterm>and triggers</indexterm></indexterm>When an insert happens
within a triggered-SQL-statement, the value inserted by the triggered-SQL-statement
into the identity column is available from <i>ConnectionInfo</i> only within
the trigger code. The trigger code is also able to see the value inserted
by the statement that caused the trigger to fire. However, the statement that
caused the trigger to fire is not able to see the value inserted by the triggered-SQL-statement
into the identity column. Likewise, triggers can be nested (or recursive).
An SQL statement can cause trigger T1 to fire. T1 in turn executes an SQL
statement that causes trigger T2 to fire. If both T1 and T2 insert rows into
a table that cause <ph conref="../conrefs.dita#prod/productshortname"></ph> to
insert into an identity column, trigger T1 cannot see the value caused by
T2's insert, but T2 can see the value caused by T1's insert. Each nesting
level can see increment values generated by itself and previous nesting levels,
all the way to the top-level SQL statement that initiated the recursive triggers.
You can only have 16 levels of trigger recursion.</p> </section>


<section><title>Example</title><codeblock>create table greetings
  (i int generated by default as identity (START WITH 2, INCREMENT BY 1),
  ch char(50));
-- specify value "1":
insert into greetings values (1, 'hi');
-- use generated default
insert into greetings values (DEFAULT, 'salut');
-- use generated default
insert into greetings(ch) values ('bonjour'); </codeblock></section>
</refbody>
</reference>
